<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JH&#39;s dev blog</title>
    <link>https://juhyeong-k.github.io/</link>
    
    <atom:link href="https://juhyeong-k.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>All about dev</description>
    <pubDate>Tue, 23 Mar 2021 08:36:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>20210323 TIL JS 예습</title>
      <link>https://juhyeong-k.github.io/2021/03/23/20210323-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/23/20210323-TIL/</guid>
      <pubDate>Tue, 23 Mar 2021 04:17:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;38-브라우저의-렌더링-과정&quot;&gt;&lt;a href=&quot;#38-브라우저의-렌더링-과정&quot; class=&quot;headerlink&quot; title=&quot;38. 브라우저의 렌더링 과정&quot;&gt;&lt;/a&gt;38. 브라우저의 렌더링 과정&lt;/h1&gt;&lt;h3 id=&quot;요청과-응답&quot;&gt;&lt;a </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="38-브라우저의-렌더링-과정"><a href="#38-브라우저의-렌더링-과정" class="headerlink" title="38. 브라우저의 렌더링 과정"></a>38. 브라우저의 렌더링 과정</h1><h3 id="요청과-응답"><a href="#요청과-응답" class="headerlink" title="요청과 응답"></a>요청과 응답</h3><p>브라우저의 핵심 기능은 필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등)를 서버에 요청(Request)하고 서버로부터 응답(Response)을 받아서 브라우저에 시각적으로 렌더링 한는 것이다. 브라우저의 주소창(URL)으로 서버에 요청을 전송할 수 있다.</p><h3 id="HTML-파싱과-DOM-생성"><a href="#HTML-파싱과-DOM-생성" class="headerlink" title="HTML 파싱과 DOM 생성"></a>HTML 파싱과 DOM 생성</h3><p>브라우저의 요청으로 서버에 존재하는 HTML 파일이 응답되는데, 서버는 브라우저가 요청한 HTML파일을 읽고 메모리에 저장한 뒤, 메모리에 저장된 바이트(2진수)를 인터넷을 경유해서 응답한다.<br>서버가 응답한 바이트로 된 HTML문서를 받은 브라우저는 응답 헤더에 담긴 meta 태그의 charset 어트리뷰트에 선언된 인코딩 방식(ex: UTF-8)을 기준으로 문자열로 변환된다.<br>문자열로 변환된 HTML 문서를 읽고 문법적 의미를 갖는 최소 단위의 코드인 토큰(token)들로 분해한다.<br>각 토큰들을 객체로 변환하여 노드(node)들을 생성하는데, 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 DOM을 구성하는 기본 요소다.<br>HTML 요소는 중첩 관계를 갖고, 그로 인해 부자 관계가 형성된다. 이러한 관계를 반영하여 모든 노드들을 트리 자료구조로 구성한다. 이 노드들로 구성된 트리 자료구조를 DOM(Document Object Model)이라 부른다.<br>즉 DOM은 HTML 문서를 파싱한 결과물이다.</p><h3 id="CSS-파싱과-CSSOM-생성"><a href="#CSS-파싱과-CSSOM-생성" class="headerlink" title="CSS 파싱과 CSSOM 생성"></a>CSS 파싱과 CSSOM 생성</h3><p>렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱(Parsing)하여 DOM을 생성해나가다가 CSS를 로드하는 link태그나 style태그를 만나면 DOM생성을 일시 중단한다. 그리고 link태그의 href어트리뷰트에 지정된 CSS파일을 서버에 요청 하고, 로드한 CSS파일(혹은 style태그 내의 CSS)을 HTML과 동일한 파싱과정(바이트-&gt;문자-&gt;토큰-&gt;노드-&gt;CSSDOM)을 거치고 해석하여 CSSOM(CSS Object Model)을 생성한다. CSS파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작해 DOM생성을 재개한다.</p><h3 id="렌더-트리-생성"><a href="#렌더-트리-생성" class="headerlink" title="렌더 트리 생성"></a>렌더 트리 생성</h3><p>렌더링 엔진에 의해 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리(render tree)로 결합된다. 렌더 트리는 결국 렌더링을 위한 트리 구조의 자료구조이므로, 브라우저 화면에 렌더링 되지 않는 노드(meta태그, script태그 등)와 CSS에 의해 비표시되는(<code>diplay: none</code>) 노드들은 포함되지 않는다. 완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치, 크기)을 계산하는데 사용되고 브라우저 화면에 픽셀을 렌더링하는 페인팅(painting)처리에 입력된다. 레이아웃 계산과 페인팅을 다시하는 리렌더링(reflow, repaint)은 비용이 많이 드는(성능에 악영향을 주는) 작업이므로, 가급적 리렌더링이 빈번하게 발생하지 않도록 주의해야 한다.</p><h3 id="자바스크립트-파싱과-실행"><a href="#자바스크립트-파싱과-실행" class="headerlink" title="자바스크립트 파싱과 실행"></a>자바스크립트 파싱과 실행</h3><p>렌더링 엔진이 DOM과 CSSOM을 생성하듯이 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성한다.</p><p>CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 script 태그(혹은 자바스크립트 코드를 담은 script 태그)를 만나면 DOM 생성을 일시 중단한다. 그리고 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하고 응답받은 파일을 파싱하기 위해 자바스크립트 엔진으로 제어권을 넘긴다.(렌더링 엔진-&gt;자바스크립트 엔진) 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 hTML파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다.</p><p>토크나이징(tokenizing)을 통해 자바스크립트 소스코드를 어휘 분석(lexical analysis)하여 문법적 의미를 갖는 코드의 최소 단위인 토큰(token)들로 분해 후, 파싱(parsing)을 통해 토큰들의 집합을 구문 분석(syntactic analysis)하여 AST를 생성한다. AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조다. 파싱의 결과물로 생성된 AST는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행된다.</p><h1 id="39-DOM"><a href="#39-DOM" class="headerlink" title="39. DOM"></a>39. DOM</h1><h3 id="노드"><a href="#노드" class="headerlink" title="노드"></a>노드</h3><p>노드 객체는 총 12개의 종류가 있다. 그 중 중요한 노드는 다음과 같이 4가지다.</p><ul><li>문서 노드(document node)<br>문서 노드는 DOM의 최상위에 존재하는 루트 노드로서, 브라우저가 렌더링한 HTML 문서 전체를 가리키는 document 객체로서 전역 객체 window의 document 프로퍼티에 바인딩 되어 있다.</li><li>요소 노드(element node)<br>요소 노드는 문서의 구조를 표현한다고 할 수 있고 HTML요소 간의 중첩에 의해 부자 관계를 가진다.</li><li>어트리뷰트 노드(attribute node)<br>어트리뷰트 노드는 부모 노드와 연결되어 있지 않고 요소 노드에만 연결되어 있기 때문에 요소 노드의 형제(sibling) 노드는 아니다. 따라서 어트리뷰트 노드에 접근하려면 요소 노드에 먼저 접근해야 한다.</li><li>텍스트 노드(text node)<br>HTML 요소의 텍스트를 가리키는 객체로서 문서의 정보를 표현한다고 할 수 있다. 텍스트 노드는 요소 노드의 자식 노드이고, 자식 노드를 가질 수 없는 리프 노드(leaf node)다. 텍스트 노드에 접근하려면 먼저 부모 노드인 요소 노드에 접근해야 한다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/23/20210323-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BAEKJOON 스택 10828번</title>
      <link>https://juhyeong-k.github.io/2021/03/22/BAEKJOON-%EC%8A%A4%ED%83%9D-10828%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/22/BAEKJOON-%EC%8A%A4%ED%83%9D-10828%EB%B2%88/</guid>
      <pubDate>Mon, 22 Mar 2021 11:30:13 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;p&gt;명령은 총 다섯 가</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.</p><p>명령은 총 다섯 가지이다.</p><ul><li>push X: 정수 X를 스택에 넣는 연산이다.</li><li>pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li><li>size: 스택에 들어있는 정수의 개수를 출력한다.</li><li>empty: 스택이 비어있으면 1, 아니면 0을 출력한다.</li><li>top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.</li></ul><p>첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.</p><p>출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(sys.stdin.readline())):</span><br><span class="line">    command = sys.stdin.readline().split()</span><br><span class="line">    <span class="keyword">if</span> command[<span class="number">0</span>] == <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">        stack.append(<span class="built_in">int</span>(command[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;pop&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            print(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(stack.pop())</span><br><span class="line">    <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;size&#x27;</span>:</span><br><span class="line">        print(<span class="built_in">len</span>(stack))</span><br><span class="line">    <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;empty&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            print(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> command[<span class="number">0</span>] == <span class="string">&#x27;top&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span>:</span><br><span class="line">            print(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(stack[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/22/BAEKJOON-%EC%8A%A4%ED%83%9D-10828%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210322 TIL JS 연습문제 풀이</title>
      <link>https://juhyeong-k.github.io/2021/03/22/20210322-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/22/20210322-TIL/</guid>
      <pubDate>Mon, 22 Mar 2021 11:27:58 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-html-생성&quot;&gt;&lt;a href=&quot;#1-html-생성&quot; class=&quot;headerlink&quot; title=&quot;1. html 생성&quot;&gt;&lt;/a&gt;1. html 생성&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-html-생성"><a href="#1-html-생성" class="headerlink" title="1. html 생성"></a>1. html 생성</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    todos.forEach(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</span><br><span class="line">        html += <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;li id=&quot;<span class="subst">$&#123;todo.id&#125;</span>&quot;&gt;</span></span><br><span class="line"><span class="string">          &lt;label&gt;&lt;input type=&quot;checkbox&quot; <span class="subst">$&#123;todo.completed ? <span class="string">&#x27;checked&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&gt;<span class="subst">$&#123;todo.content&#125;</span>&lt;/label&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;`</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(render());</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  &lt;li id=&quot;3&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;HTML&lt;/label&gt;</span></span><br><span class="line"><span class="comment">  &lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li id=&quot;2&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;label&gt;&lt;input type=&quot;checkbox&quot; checked&gt;CSS&lt;/label&gt;</span></span><br><span class="line"><span class="comment">  &lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;li id=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;label&gt;&lt;input type=&quot;checkbox&quot;&gt;Javascript&lt;/label&gt;</span></span><br><span class="line"><span class="comment">  &lt;/li&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="2-특정-프로퍼티-값-추출"><a href="#2-특정-프로퍼티-값-추출" class="headerlink" title="2. 특정 프로퍼티 값 추출"></a>2. 특정 프로퍼티 값 추출</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line"><span class="comment">//   function getValues(key) &#123;</span></span><br><span class="line"><span class="comment">//     let array = [...todos];</span></span><br><span class="line"><span class="comment">//     let answer = []</span></span><br><span class="line"><span class="comment">//         for (let i = 0; i &lt; array.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//             answer.push(array[i][key]);</span></span><br><span class="line"><span class="comment">//         &#125; ;</span></span><br><span class="line"><span class="comment">//     return answer;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getValues</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> todos.map(<span class="function"><span class="params">todo</span>=&gt;</span>todo[key])</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(getValues(<span class="string">&#x27;id&#x27;</span>)); <span class="comment">// [3, 2, 1]</span></span><br><span class="line">  <span class="built_in">console</span>.log(getValues(<span class="string">&#x27;content&#x27;</span>)); <span class="comment">// [&#x27;HTML&#x27;, &#x27;CSS&#x27;, &#x27;Javascript&#x27;]</span></span><br><span class="line">  <span class="built_in">console</span>.log(getValues(<span class="string">&#x27;completed&#x27;</span>)); <span class="comment">// [false, true, false]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-프로퍼티-정렬"><a href="#3-프로퍼티-정렬" class="headerlink" title="3. 프로퍼티 정렬"></a>3. 프로퍼티 정렬</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> newTodos = [...todos]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortBy</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newTodos.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a[key] &gt; b[key] ? <span class="number">1</span> : (a[key] &lt; b[key] ? -<span class="number">1</span> : <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;id&#x27;</span>));</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;content&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">console</span>.log(sortBy(<span class="string">&#x27;completed&#x27;</span>));</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="4-새로운-요소-추가"><a href="#4-새로운-요소-추가" class="headerlink" title="4. 새로운 요소 추가"></a>4. 새로운 요소 추가</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">newTodo</span>) </span>&#123;</span><br><span class="line">    todos = [ newTodo, ...todos];</span><br><span class="line">    <span class="keyword">return</span> todos;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addTodo(&#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">content</span>: <span class="string">&#x27;Test&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(todos);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 4, content: &#x27;Test&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="5-특정-요소-삭제"><a href="#5-특정-요소-삭제" class="headerlink" title="5. 특정 요소 삭제"></a>5. 특정 요소 삭제</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTodo</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    todos = todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id !== key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  removeTodo(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(todos);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="6-특정-요소의-프로퍼티-값-반전"><a href="#6-특정-요소의-프로퍼티-값-반전" class="headerlink" title="6. 특정 요소의 프로퍼티 값 반전"></a>6. 특정 요소의 프로퍼티 값 반전</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toggleCompletedById</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newTodos = todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.id === key)</span><br><span class="line">    newTodos[<span class="number">0</span>].completed = !newTodos[<span class="number">0</span>].completed</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toggleCompletedById(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(todos);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: false &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: false &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="7-모든-요소의-completed-프로퍼티-값을-true로-설정"><a href="#7-모든-요소의-completed-프로퍼티-값을-true로-설정" class="headerlink" title="7. 모든 요소의 completed 프로퍼티 값을 true로 설정"></a>7. 모든 요소의 completed 프로퍼티 값을 true로 설정</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toggleCompletedAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> (todo.completed = <span class="literal">true</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  toggleCompletedAll();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(todos);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  [</span></span><br><span class="line"><span class="comment">    &#123; id: 3, content: &#x27;HTML&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 2, content: &#x27;CSS&#x27;, completed: true &#125;,</span></span><br><span class="line"><span class="comment">    &#123; id: 1, content: &#x27;Javascript&#x27;, completed: true &#125;</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="8-completed-프로퍼티의-값이-true인-요소의-갯수-구하기"><a href="#8-completed-프로퍼티의-값이-true인-요소의-갯수-구하기" class="headerlink" title="8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기"></a>8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">countCompletedTodos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.completed).length;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(countCompletedTodos()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="9-id-프로퍼티의-값-중에서-최대값-구하기"><a href="#9-id-프로퍼티의-값-중에서-최대값-구하기" class="headerlink" title="9. id 프로퍼티의 값 중에서 최대값 구하기"></a>9. id 프로퍼티의 값 중에서 최대값 구하기</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> todos = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">content</span>: <span class="string">&#x27;HTML&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">content</span>: <span class="string">&#x27;CSS&#x27;</span>, <span class="attr">completed</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">content</span>: <span class="string">&#x27;Javascript&#x27;</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMaxId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> aaa = todos.map(<span class="function"><span class="params">todo</span>=&gt;</span>todo[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...aaa);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(getMaxId()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/22/20210322-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210321 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/21/20210321-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/21/20210321-TIL/</guid>
      <pubDate>Sun, 21 Mar 2021 10:34:39 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;29-Math&quot;&gt;&lt;a href=&quot;#29-Math&quot; class=&quot;headerlink&quot; title=&quot;29. Math&quot;&gt;&lt;/a&gt;29. Math&lt;/h1&gt;&lt;p&gt;표준 빌트인 객체 Math는 생성자 함수가 아니기 때문에 정적 프로퍼티와 정적 메소드만</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="29-Math"><a href="#29-Math" class="headerlink" title="29. Math"></a>29. Math</h1><p>표준 빌트인 객체 Math는 생성자 함수가 아니기 때문에 정적 프로퍼티와 정적 메소드만 제공한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 원주율 PI</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.PI); <span class="comment">// 3.141592653589793</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 절대값</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(-<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs([])); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="literal">null</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="literal">undefined</span>)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(&#123;&#125;)); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs()); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 반올림</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(-<span class="number">1.4</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="number">1.6</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round()); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 올림</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(-<span class="number">1.1</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(-<span class="number">4.8</span>)); <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil(<span class="number">4.3</span>)); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil()); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 내림</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(-<span class="number">1.1</span>)); <span class="comment">// -2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(-<span class="number">4.8</span>)); <span class="comment">// -5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="number">4.7</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.ceil()); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0부터 1미만의 실수 random</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()); <span class="comment">// 0.5782056303358767</span></span><br><span class="line"><span class="comment">// 1부터 100 까지 랜덤 정수 출력</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">100</span>) + <span class="number">1</span>); <span class="comment">// 39</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 거듭제곱</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">4</span>)); <span class="comment">// 2 ** 4 -&gt; 16</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">1</span>)); <span class="comment">// 2 ** -1 -&gt; 0.5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// max 전달받은 인수 중 가장 큰 수 반환</span></span><br><span class="line"><span class="comment">// 숫자로 암묵적 타입 변환</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&#x27;21&#x27;</span>, <span class="number">11</span>)); <span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(<span class="number">1</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max()); <span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])); <span class="comment">// 스프레드 문법 -&gt; 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// min 전달받은 인수 중 가장 작은 수 반환</span></span><br><span class="line"><span class="comment">// 숫자로 암묵적 타입 변환</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">21</span>, <span class="number">11</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min()); <span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(...[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])); <span class="comment">// 스프레드 문법 -&gt; 1</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/21/20210321-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210320 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/20/20210320-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/20/20210320-TIL/</guid>
      <pubDate>Sat, 20 Mar 2021 13:31:06 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Number&quot;&gt;&lt;a href=&quot;#Number&quot; class=&quot;headerlink&quot; title=&quot;Number&quot;&gt;&lt;/a&gt;Number&lt;/h1&gt;&lt;p&gt;Number는 빌트인 객체인 생성자 함수 객체다. new 연산자와 함께 호출하여 Number 인스</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>Number는 빌트인 객체인 생성자 함수 객체다. new 연산자와 함께 호출하여 Number 인스턴스를 생성한다. new 연산자 없이 호출하면 숫자를 반환 하는데 이를 이용하여 명시적으로 타입을 변환하기도 한다.</p><p>래퍼 객체 - 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데 원시값인 숫자나 문자열에 메소드를 사용할 수 있는 경우가 있다. 이는 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체를 생성하여 그 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다. 이 때, 문자열, 숫자, 불린 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.</p><h3 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h3><p>부동소수점으로 인해 발생하는 오차를 해결하기 위해서 사용된다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(x - y) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>) <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure><h3 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite"></a>Number.isFinite</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isFinite는 인수로 전달된 값이 정상적인 유한수인지 아닌지 불린값으로 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">null</span>)) <span class="comment">// true , null은 암묵적으로 0으로 타입 변환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="literal">Infinity</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number.isFinite는 인수를 암묵적으로 숫자로 타입 변환 하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// isFinite는 인수를 암묵적으로 숫자로 타입 변환 한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isInteger 정적 메소드는 인수로 전달된 숫자값이 정수(integer)인지 불린 값으로 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(-<span class="number">213</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">1.2</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환이 일어나지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN"></a>Number.isNaN</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number.isNaN 메소드는 인수에 전달된 숫자값이 NaN인지 불린 값으로 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//빌트인 전역함수 isNaN은 숫자로 암묵적 타입 변환이 일어나기 때문에 숫자가 아닌 값들은 NaN으로 반환된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">123</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&#x27;asd&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed"></a>Number.prototype.toFixed</h3><p>toFixed 메소드는 숫자를 반올림 해서 문자열로 반환한다. 인수로 0~20사이의 정수값을 줄 수 있고 기본값은 0이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">123.123</span>).toFixed()); <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자에 처음 .은 소수 구분 기호로 구분되고 두번 째 .은 프로퍼티 접근 연산자로 해석된다.</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">123.123</span>.toFixed(<span class="number">2</span>))) <span class="comment">// &#x27;123.12&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString"></a>Number.prototype.toString</h3><p>toString 메소드는 숫자를 문자열로 반환하는 메소드다. 인수에 2~36사이의 정수값으로 진법을 나타낼 수 있고, 기본 값은 10진법으로 지정된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">10</span>).toString()); <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 2진법</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">20</span>).toString(<span class="number">2</span>)); <span class="comment">// 10100</span></span><br><span class="line"><span class="comment">// 8진법</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">20</span>).toString(<span class="number">8</span>)); <span class="comment">// 24</span></span><br><span class="line"><span class="comment">// 16진법</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">30</span>).toString(<span class="number">16</span>)); <span class="comment">//1e</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/20/20210320-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210319 TIL JS 6회차</title>
      <link>https://juhyeong-k.github.io/2021/03/19/20210319-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/19/20210319-TIL/</guid>
      <pubDate>Fri, 19 Mar 2021 11:13:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;배열의-메소드&quot;&gt;&lt;a href=&quot;#배열의-메소드&quot; class=&quot;headerlink&quot; title=&quot;배열의 메소드&quot;&gt;&lt;/a&gt;배열의 메소드&lt;/h1&gt;&lt;h3 id=&quot;Array-prototype-sort&quot;&gt;&lt;a href=&quot;#Array-prototy</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="배열의-메소드"><a href="#배열의-메소드" class="headerlink" title="배열의 메소드"></a>배열의 메소드</h1><h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h3><p>sort 메소드는 원본 배열을 변경하는 mutator, 바뀐 배열을 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">33</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [ 1, 10, 2, 22, 3, 33, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, 10, 2, 22, 3, 33, 5 ]</span></span><br></pre></td></tr></table></figure><blockquote><p>문자열이 아닌 숫자를 정렬했는데 왜 저런 순서로 정렬되었을까?</p></blockquote><p>sort 메소드는 배열의 요소가 숫자 타입이라 할지라도 배열의 요소를 일시적으로 문자열로 변환 후 유니코드 코드 포인트의 순서를 기준으로 정렬한다.<br>숫자 요소를 정렬할 때는 sort 메소드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다. </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열의 오름차순 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)); <span class="comment">// [ 1,  2,  3, 5, 10, 22, 33 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열의 내림차순 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)); <span class="comment">// [ 33, 22, 10, 5, 3,  2,  1 ]</span></span><br></pre></td></tr></table></figure><p>sort 메소드는 함수를 전달 받았기 때문에 고차 함수(Higher-Order Function, HOF)다.</p><h3 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수"></a>배열 고차 함수</h3><p>고차 함수는 함수를 인자로 전달 받거나 함수를 반환하는 함수를 말한다. 외부 상태의 변경(인수로 객체를 전달했을 경우 함수 내부에서 재할당없이 자유자재로 변경이 가능)이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍을 기반에 두고 있다.<br>함수형 프로그래밍은 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.</p><h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h3><p>forEach 메소드는 반복문을 추상화한 고차 함수로서 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야할 처리를 콜백 함수로 전달받아서 반복 호출한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> pows = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.</span></span><br><span class="line">numbers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> pows.push(item ** <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pows); <span class="comment">// [1, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach와 같은 기능을 하는 함수를 만들어 보자.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a funciton`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">numbers.myForEach(<span class="function"><span class="params">v</span> =&gt;</span> pows.push(v ** <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pows); <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure><p>forEach 메소드의 반환값은 언제나 <code>defined</code>다.</p><h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><p>map 메소드는 콜백함수의 반환값들로 구성된 새로운 배열을 반환한다. 반환된 새로운 배열의 length 프로퍼티 값은 map 메서드를 호출한 배열의 length 프로퍼티 값과 일치한다. 1:1 매핑(mapping)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map과 같은 기능을 하는 myMap을 만들어보자.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        res.push(fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers.myMap(<span class="function"><span class="params">v</span> =&gt;</span> v ** <span class="number">4</span>));</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><p>filter 메소드는 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. filter 메소드가 생성하여 반환한 새로운 배열의 length 프로퍼티 값은 filter 메소드를 호출한 배열의 length 프로퍼티 값과 같거나 작다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter와 같은 기능을 하는 myFilter</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers.myFilter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p>reduce 메소드는 2개의 값을 이용해서 행동을 한다. map과 filter와 다르게 누계를 해야 하기 때문에 4개의 파라미터를 받는다(accumulator, currentValue, index, array)</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/19/20210319-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210318 TIL JS 내용 정리</title>
      <link>https://juhyeong-k.github.io/2021/03/18/20210318-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/18/20210318-TIL/</guid>
      <pubDate>Thu, 18 Mar 2021 03:58:07 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;16-프로퍼티-어트리뷰트&quot;&gt;&lt;a href=&quot;#16-프로퍼티-어트리뷰트&quot; class=&quot;headerlink&quot; title=&quot;16. 프로퍼티 어트리뷰트&quot;&gt;&lt;/a&gt;16. 프로퍼티 어트리뷰트&lt;/h1&gt;&lt;h3 id=&quot;내부-슬롯과-내부-메소드&quot;&gt;&lt;a h</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="16-프로퍼티-어트리뷰트"><a href="#16-프로퍼티-어트리뷰트" class="headerlink" title="16. 프로퍼티 어트리뷰트"></a>16. 프로퍼티 어트리뷰트</h1><h3 id="내부-슬롯과-내부-메소드"><a href="#내부-슬롯과-내부-메소드" class="headerlink" title="내부 슬롯과 내부 메소드"></a>내부 슬롯과 내부 메소드</h3><p>내부 슬롯(internal slot)과 내부 메소드(internal method)는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 pseudo property, pseudo method이다. 대괄호 두개로 감싼 이름들이 이에 해당한다. ex) <code>[[Prototype]]</code></p><p>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 로직이기 때문에 직접적인 접근은 제공하지 않고 일부 내부 슬롯과 내부 메소드에 한해서 간접적으로 접근할 수 있는 방법을 제공한다. 예를 들어 <code>[[Prototype]]</code>내부 슬롯은 <code>__proto__</code> 접근자 프로퍼티로 간접적으로 접근이 가능하다.</p><p>프로퍼티를 생성할 대 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</p><table><thead><tr><th align="center">프로퍼티 상태</th><th align="center">내부 상태값(meta-property)</th></tr></thead><tbody><tr><td align="center">프로퍼티 값</td><td align="center">[[Value]]</td></tr><tr><td align="center">값의 갱신 가능 여부</td><td align="center">[[Writable]]</td></tr><tr><td align="center">열거 가능 여부</td><td align="center">[[Enumerable]]</td></tr><tr><td align="center">재정의 가능 여부</td><td align="center">[[Configurable]]</td></tr></tbody></table><p>프로퍼티 어트리뷰트에 직접 접근할 수 없지만 <code>Object.getOwnPropertyDescriptor</code>메소드를 이용해서 간접적으로 접근 가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Kim&#x27;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123; value: &#x27;Kim&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">     name: &#123; value: &#x27;Kim&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">     age: &#123; value: 27, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>이와 같이 반환된 객체를 프로퍼티 디스크립터(PropertyDescriptor)라 한다.</p><h3 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h3><p>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 나눌 수 있다.</p><p>데이터 프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티로, <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code>, [[Configurable]]의 프로퍼티 어트리뷰트를 갖는다.</p><p>접근자 프로퍼티는 자체적으로는 값을 갖지 않고 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다. <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code>, <code>[[Configurable]]</code>의 프로퍼티 어트리뷰트를 갖는다.</p><p>일반 객체의 <code>__proto__</code>는 접근자 프로퍼티, 함수 객체의 <code>prototype</code>은 데이터 프로퍼티다.</p><p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다. <code>Object.defineProperty</code>, <code>Object.definePropertues</code>를 활용해서 정의할 수 있다.</p><p>객체는 재할당 없이 직접 변경이 가능한데, 이를 방지하는 메소드가 있다.</p><table><thead><tr><th align="center">메소드</th><th align="center">설명</th></tr></thead><tbody><tr><td align="center"><code>Object.preventExtension</code></td><td align="center">객체 확장 금지, 프로퍼티 추가만 금지한다</td></tr><tr><td align="center"><code>Object.seal</code></td><td align="center">객체 밀봉, 프로퍼티 갱신과 프로퍼티 읽기만 가능하다</td></tr><tr><td align="center"><code>Object.freeze</code></td><td align="center">객체 동결, 프로퍼티 읽기만 가능하다</td></tr></tbody></table><p>객체 변경 방지 메소드는 얕은 변경 방지(shallow only)이기 때문에 깊은 변경 방지를 하기 위해서는 재귀를 사용해야 한다. <code>Object.freeze</code> 메소드와 깊은 변경 방지를 이용해서 불변 객체를 구현할 수 있다.</p><p>프로토타입<br>추상연산은 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/18/20210318-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210317 TIL JS 5회차</title>
      <link>https://juhyeong-k.github.io/2021/03/17/20210317-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/17/20210317-TIL/</guid>
      <pubDate>Wed, 17 Mar 2021 05:47:10 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;for문 대신에 reduce, filter, map으로 반복문 대체 가능&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>for문 대신에 reduce, filter, map으로 반복문 대체 가능</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  만약 재귀를 한다면 add와 foo중 어느 것을 쓰는게 나을까?</span></span><br><span class="line"><span class="comment">  스코프 관점에서 보면 foo 쓰는게 낫다. 굳이 스코프 체인을 통해</span></span><br><span class="line"><span class="comment">  전역으로 가서 확인할 필요가 없다.</span></span><br><span class="line"><span class="comment">  하지만 애초에 함수 표현식에서 함수 이름은 생략이 가능하기 때문에</span></span><br><span class="line"><span class="comment">  함수 이름을 생략하고 변수로 사용하는게 나을 것 같다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="27-배열"><a href="#27-배열" class="headerlink" title="27. 배열"></a>27. 배열</h1><p>자바스크립트에서 배열은 값으로 올 수 있는 모든 값이 올 수 있고 요소들의 타입이 일치하지 않아도 된다. 다만, 자바스크립트에서 배열을 쓰는 이유는 length 프로퍼티를 이용해서 looping(반복)하기 위해 사용하는거라 다름 없기 때문에 배열의 타입을 일치 시키는게 좋다.</p><p>자료구조(Data Structure)에서의 배열과 자바스크립트의 배열은 다르다. 자료구조에서의 배열은 동일한 크기의 메모리공간이 빈틈없이 연속적으로 나열된 자료구조라서 선두 메모리 어드레스와 메모리 크기만 알고 있다면 빠른 접근이 가능하다. 자바스크립트에서의 배열은 같은 크기를 가지고 있다면 배열로 만들고, 타입과 크기가 다르다면 해쉬 테이블로 만든다고 한다.</p><p>일반적인 배열은 인덱스로 요소에 빠르게 접근할 수 있지만, 특정 요소를 검색하거나 요소를 삽입, 삭제하는 경우에는 비효율적이다.<br>자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 접근하는 경우 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적 단점이 있지만, 특정 요소를 검색하거나 요소를 삽입, 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p><p>인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화를 구현했다.</p><p>REST 파라미터와 스프레드 문법</p><p>프로토타입</p><p>배열의 mutator와 accessor</p><p>splice(), 스프레드 문법으로 얕은 복사(shallow copy)가능 하다.<br>얕은 복사는 한 단계까지만 가능하다.</p><p>깊은 복사를 하려면 재귀를 써야 한다.<br>typeOf메소드로 객체인지 확인 후 객체라면 그 객체의 프로퍼티에 다시 접근 후 객체라면 다시…<br>기존에 만들어진 library를 사용해도 된다.(Lodash 라이브러리의 .clonedeep)<br>라이브러리에 만들어진 함수들을 직접 구현해보는 연습을 한다면 많은 도움이 된다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/17/20210317-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210316 TIL JS 예습</title>
      <link>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/</guid>
      <pubDate>Tue, 16 Mar 2021 01:27:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;17-생성자-함수에-의한-객체-생성&quot;&gt;&lt;a href=&quot;#17-생성자-함수에-의한-객체-생성&quot; class=&quot;headerlink&quot; title=&quot;17. 생성자 함수에 의한 객체 생성&quot;&gt;&lt;/a&gt;17. 생성자 함수에 의한 객체 생성&lt;/h1&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="17-생성자-함수에-의한-객체-생성"><a href="#17-생성자-함수에-의한-객체-생성" class="headerlink" title="17. 생성자 함수에 의한 객체 생성"></a>17. 생성자 함수에 의한 객체 생성</h1><p>생성자 함수(constructor)란 <code>new</code> 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.<br>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수를 제공한다.</p><p><code>new</code>연산자와 함께 호출하지 않으면 일반 함수로 호출된다.</p><blockquote><p>Object 생성자 함수를 사용해서 객체를 생성하는 것 보다 객체 리터럴을 이용하는게 더 직관적이고 편한 것 같은데 생성자 함수로 생성해야되는 이유가 있을까?</p></blockquote><p>공통된 프로퍼티를 여러 객체가 가져야 할 경우, 생성자 함수를 이용하면 간편하게 생성할 수 있다. 객체 리터럴은 직관적이고 편리하지만, 공통된 프로퍼티들을 갖는 여러 객체들에게 각각 프로퍼티를 입력해줘야 하는 단점이 있다.</p><p>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수고, 생성된 인스턴스를 초기화하는 것은 옵션이다.</p><p>생성자 함수의 인스턴스 생성 과정</p><ul><li>인스턴스 생성과 this 바인딩은 런타임 이전에 암묵적으로 자바스크립트 엔진에 의해 실행된다.</li><li>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 한 뒤(this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드 추가) 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li><li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스의 바인딩 된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환되기 때문에 생성자 함수의 기본 동작을 훼손하지 않으려면 생성자 함수 내부에서 return문을 반드시 생략해야 한다. 단, 원시값을 return 하면 무시되고 this가 암묵적으로 반환된다.</li></ul><p>객체에는 일반 객체와 함수 객체가 있는데, 둘을 구분할 수 있는 기준은 호출이 가능한지 아닌지로 할 수 있다. 즉 객체 내부 메소드 <code>[[call]]</code>을 가지고 있는 객체를 함수 객체라 할 수 있다. 함수 객체에서 일반함수와 생성자 함수를 구분하자면, constructor와 non-constructor로 구분할 수 있다. constructor는 내부 메서드 <code>[[construct]]</code>를 갖는 함수 객체로 생성자 함수로서 호출할 수 있는 함수를 말하고, non-constructor는 <code>[[construct]]</code>를 갖지 않는, 생성자 함수로서 호출할 수 없는 함수를 의미한다. </p><ul><li>constructor : 함수 선언문, 함수 표현식, 클래스</li><li>non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수</li></ul><p>프로퍼티 값으로 함수를 사용하면 일반적으로 메소드라 칭하는데, ECMAScript의 사양에서 메소드는 ES6의 메서드 축약 표현만 의미한다.</p><p>사실 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하는지 안하는지에 따라 달라지기 때문이다. 즉, new 연산자 없이 constructor를 호출하면 일반 함수로 호출되고, new 연산자와 함께 cosntructor를 호출하면 생성자 함수로 호출된다.<br>생성자 함수와 일반 함수를 구별하기 위해서 생성자 함수의 이름을 파스칼 케이스로 명명하지만, 실수는 언제나 발생할 수 있다. 이런 위험성을 회피하기 위해 ES6에서 <code>new.target</code>을 지원한다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었을 때 함수 자신을 가리키고, new 연산자 없이 일반 함수로 호출되었다면 undefined를 의미한다. 따라서 함수 내부에서 new 연산자와 함께 재귀 호출을 통해 생성자 함수로 호출할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());</span><br></pre></td></tr></table></figure><h1 id="25-ES6-함수의-추가-기능"><a href="#25-ES6-함수의-추가-기능" class="headerlink" title="25. ES6 함수의 추가 기능"></a>25. ES6 함수의 추가 기능</h1><h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>화살표 함수(arrow function)는 function 키워드 대신 화살표(<code>=&gt;</code>,fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의 할 수 있고, 내부 동작도 기존의 함수보다 간략하다. 특히 콜백 함수 내부에서 <code>this</code>전역 객체를 가리키는 문제를 해결하기 위한 대안으로 많이 사용된다.</p><p>화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 매개변수가 여러 개인 경우 소괄호 안에 매개변수 선언한다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 한 개인 경우 소괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">x</span> =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 없는 경우 소괄호 생략 불가능</span></span><br><span class="line">cosnt arrow = <span class="function">() =&gt;</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>함수 몸체가 값으로 평가되는 표현식인 문이라면 중괄호(<code>&#123;&#125;</code>)를 생략할 수 있고 암묵적으로 반환되지만, 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> x ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">//동일한 표현</span></span><br><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> x ** <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식이 아닌 문은 반환할 수 없기 때문에 중괄호 생략 불가능하다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> <span class="keyword">const</span> x = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123; <span class="keyword">const</span> x = <span class="number">1</span>; &#125; <span class="comment">// 맞는 표현</span></span><br></pre></td></tr></table></figure><p>객체 리터럴을 반환할 때 소괄호(<code>()</code>)로 감싸야 한다. 그렇지 않으면 객체 리터럴의 중괄호(<code>&#123;&#125;</code>)를 함수 몸체를 감싸는 중괄호로 잘못 해석하기 때문에 쉼표를 함수 몸체 내의 쉼표 연산문으로 해석한다.</p><h1 id="26-배열"><a href="#26-배열" class="headerlink" title="26. 배열"></a>26. 배열</h1><p>배열(array)은 여러 개의 값을 순차적으로 나열한 자료 구조다. 배열이 가지고 있는 값을 요소(element)라고 부르고, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.</p><p>자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// -&gt; object</span></span><br></pre></td></tr></table></figure><p>배열은 객체지만 일반 객체와는 구별되는 특징이 있다. 구분하는 가장 명확한 차이는 “값의 순서”와 “length 프로퍼티”다.</p><h3 id="자바스크립트-배열은-배열이-아니다"><a href="#자바스크립트-배열은-배열이-아니다" class="headerlink" title="자바스크립트 배열은 배열이 아니다"></a>자바스크립트 배열은 배열이 아니다</h3><p>자료구조(data structure)에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(dense array)이라 한다.</p><blockquote><p>검색 대상의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수</p></blockquote><p>예를 들어 메모리 주소 1000에서 시작하고 각 요소의 크기가 8바이트인 배열을 생각해보면,</p><ul><li>인덱스가 0인 요소의 메모리 주소: 1000 + 0 * 8 = 1000</li><li>인덱스가 1인 요소의 메모리 주소: 1000 + 1 * 8 = 1008</li><li>인덱스가 2인 요소의 메모리 주소: 1000 + 2 * 8 = 1016</li></ul><p>이렇게 표현될 수 있다. 이처럼 배열은 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있고 시간 복잡도 <code>O(1)</code>라고 표현할 수 있다. 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형검색(linear search), 시간 복잡도 <code>O(n)</code>)해야 한다. 또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소들을 이동시켜야 하는 단점도 있다.</p><p>자바스크립트에서의 배열은 위에서 설명한 일반적인 의미의 배열과 다르다. 자바스크립트에서의 배열은 배열의 요소를 위한 각각의 메모리 공간을 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열(sparse array)이라 한다.<br><strong>자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.</strong></p><p>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, 배열의 요소를 프로퍼티 값으로 갖고, length 프로퍼티를 갖는 특수한 객체다.</p><p>정리하자면 일반적인 배열은 인덱스로 배열 요소에 접근이 빠른 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않지만, 자바스크립트 배열은 인덱스로 배열 요소에 접근이 느린 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p><p>자바스크립트 배열의 length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제할 때 자동으로 갱신된다.<br>length 프로퍼티의 값은 배열의 길이를 바탕으로 결정되지만, 임의의 숫자 값을 명시적으로 할당할 수도 있다. 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>반대로 현재 legth 프로퍼티 값보다 큰 숫자 값을 할당하면 length 프로퍼티의 값은 변경이 되지만 실제 배열의 길이가 늘어나지는 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 4, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p><code>&lt;4 empty items&gt;</code>는 실제로 추가된 배열의 요소가 아니다. length 프로퍼티 값이 변경됐다고 해도 값 없이 비어 있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [,, <span class="number">3</span>,, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5 ]</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p>일반적인 배열의 length는 배열의 요소의 개수와 언제나 일치하지만, 희소 배열은 length와 배열의 요소 개수와 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.</p><p>자바스크립트는 문법적으로 희소 배열을 허용하지만 희소 배열은 사용하지 않는 것이 좋다. 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.</p><h3 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h3><p>객체와 마찬가지로 배열도 다양한 생성 방식이 있는데, 가장 일반적이고 간단한 배열 생성 방식은 배열 리터럴을 사용하는 것이다. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분해서 대괄호(<code>[ ]</code>)로 묶는다.</p><p>Object 생성자 함수를 통해 객체를 생성할 수 있듯이 Array 생성자 함수를 통해 배열을 생성할 수도 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">대부분의 빌트인 생성자 함수(Object, Function, Array, Date, RegExp, Promise 등)는 </span></span><br><span class="line"><span class="comment">new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. </span></span><br><span class="line"><span class="comment">생성자 함수 내부에서 new.target을 확인하기 때문이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>Array 생성자 함수에 전달되는 인수가 1개이고 숫자인 경우, length 프로퍼티 값이 인수인 배열을 생성한다. length 프로퍼티 값이 0은 아니지만 실제로 배열의 요소는 존재하지 않는 희소 배열이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br></pre></td></tr></table></figure><p>전달된 인수가 없는 경우 length 프로퍼티 값이 0인 빈 배열을 생성한다. 즉 배열 리터럴(<code>[ ]</code>)과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전달되는 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전달되는 인수가 1개지만, 숫자가 아닌 인수이기 때문에 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ &#123;&#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="string">&#x27;string&#x27;</span>));</span><br></pre></td></tr></table></figure><p><code>Array.of</code>는 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr1));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: &#x27;a&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: &#x27;b&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: &#x27;c&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;]</span></span><br></pre></td></tr></table></figure><p>ES6에서 도입된 <code>Array.from</code>메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달 받아서 배열로 변환 후, 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 길이에 맞게 undefined를 요소로 채운다.</span></span><br><span class="line"><span class="keyword">const</span> arr3 = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환 값으로 구성된 배열을 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 요소의 참조</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 인덱스가 2인 요소를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 존재하지 않는 요소에 접근하면 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열도 마찬가지</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>,,<span class="number">3</span>,,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr2));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;4&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 5, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="comment">//배열 요소 추가</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="string">&#x27;1&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">arr[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">arr.bar = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1.1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, foo: 3, bar: 4, &#x27;1.1&#x27;: 5, &#x27;-1&#x27;: 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티는 배열의 length에 영향을 주지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 2, writable: true, enumerable: false, configurable: false &#125;,</span></span><br><span class="line"><span class="comment">  foo: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  bar: &#123; value: 4, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1.1&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;-1&#x27;: &#123; value: 6, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>인덱스는 요소의 위치를 나타내기 때문에 반드시 0 이상의 정수(정수 형태 문자열)를 사용해야 한다. 정수 이외에 값을 인덱스처럼 사용한다면 요소가 생성되는게 아닌 프로퍼티가 추가된다. 추가된 프로퍼티는 요소가 아니기 때문에 배열의 length 프로퍼티에 영향을 미치지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, &lt;1 empty item&gt;, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>배열도 객체이기 때문에 <code>delete</code>연산자를 이용해서 요소를 삭제할 수 있다. 위의 경우 1번 인덱스의 값을 삭제하면서 희소 배열이 되고 length 프로퍼티의 값은 변하지 않는다. 희소 배열을 만드는 delete 연산자는 사용하지 않는게 좋다. 만약 희소 배열로 만들지 않고 배열의 특정 요소를 완전히 삭제하려면 <code>Array.prototype.splice</code>메소드를 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.slplice(삭제를 시작 할 인덱스, 삭제할 요소 개수)</span></span><br><span class="line">arr1.splice(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1번 인덱스부터 2개 삭제</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열로 만들어지는 경우</span></span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, &lt;2 empty items&gt;, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본을 직접 변경하는 push 메소드</span></span><br><span class="line">arr1.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 배열을 생성하는 concat 메소드</span></span><br><span class="line"><span class="keyword">const</span> result = arr2.concat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>자바스크립트에서 배열 메소드는 결과물을 반환하는 패턴이 두 가지 있다. 원본 배열(배열 메소드를 호추한 배열, 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method)와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method)가 있다.<br>원본을 직접 변경하는 메소드는 외부 상태를 직접 변경하는 부수 효과(side effect)가 있으므로 가급적 원본 배열을 직접 변경하지 않는 메소드를 사용하는 편이 좋다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.push</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line">arr1.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr1 performance test: 0.134ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [arr.length] </span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line">arr2[arr2.length] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr2 performance test: 0.01ms</span></span><br></pre></td></tr></table></figure><p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.<br>마지막 요소로 추가할 요소가 하나뿐이라면 push 메소드보다 length 프로퍼티를 사용해서 배열의 마지막에 요소를 직접 추가하는게 더 빠르다.(push 메소드는 성능 면에서 좋지 않다.)</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210315 TIL JS 4회차</title>
      <link>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/</guid>
      <pubDate>Mon, 15 Mar 2021 04:57:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;12-함수&quot;&gt;&lt;a href=&quot;#12-함수&quot; class=&quot;headerlink&quot; title=&quot;12. 함수&quot;&gt;&lt;/a&gt;12. 함수&lt;/h1&gt;&lt;p&gt;인수(argument)는 함수 밖에서 함수 매개변수(parameter)에 순서대로 할당된다.&lt;br&gt;매</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="12-함수"><a href="#12-함수" class="headerlink" title="12. 함수"></a>12. 함수</h1><p>인수(argument)는 함수 밖에서 함수 매개변수(parameter)에 순서대로 할당된다.<br>매개변수는 0개 이상<br>함수 정의만으로 함수가 실행되지 않고 함수를 호출해야 실행이 된다.</p><p>변수 호이스팅과 함수 호이스팅은 미묘한 차이가 있다.<br>변수 선언문은 런타임 이전에 변수가 <code>undefined</code>로 초기화가 되고, 런타임에 값이 할당 되어지지만, 함수 선언문은 runtime 이전에 정의가 되어지기 때문에 함수 정의가 어느 위치에 있던 런타임 시 첫째줄에 호출을 해도 실행이 된다.</p><p>함수 표현식을 사용하면 변수 호이스팅이 발생해서 runtime 이전에 변수에 undefined로 초기화되고 런타임에 순서에 맞게 함수가 정의가 된다. 즉, 함수 표현식은 정의 이전에 호출할 수 없다.</p><p>함수 이름은 함수 몸체 안에서만 유효하다. 그래서 함수 표현식에서 함수 이름은 생략이 가능하다. 함수 몸체 안에서 사용할 때는 재귀를 사용할때 정도로 생각할 수 있는데, 굳이 함수 이름이 아닌 식별자로 넣어줘도 문제 없기 때문에, 함수 표현식에서 함수 이름은 생략한다.</p><p>함수 리터럴 - 함수객체를 생성하는 것</p><p>일반 객체와 함수 객체의 차이는 호출 가능/불가능 차이</p><blockquote><p>함수 선언문과 함수 표현식 둘 중 어떤걸 사용하는게 좋을까?<br>함수 선언문은 함수 객체가 런타임 이전에 만들어지고 함수 표현식은 런타임 때 만들어진다. 결국 함수 객체를 생성하는 시점에 차이가 있다. 둘 중 어느걸 사용해도 상관은 없지만 일관성 있게 사용해야 한다.(결국 나중에 애로우 함수를 사용할 것이기 때문에..)</p></blockquote><p>함수가 호출이 되면 함수가 정의된 부분으로 돌아가서 함수 코드블록을 실행하기 때문에, 함수도 제어문의 일종이라고 볼 수 있다.</p><blockquote><p>{ }는 블록문일까 객체 리터럴일까?</p></blockquote><p><code>&#123; &#125;</code>는 블록문 일수도 객체 리터럴일 수도 있다. <code>&#123; &#125;</code>는 중의적 표현이기 때문에 자바스크립트 엔진이 코드의 문맥에 따라 해석을 달리한다. <code>&#123; &#125;</code>가 단독을 존재하면 블록문으로 해석하고, <code>&#123; &#125;</code>가 값으로 평가되어야 할 문맥(할당연산자의 우변)에서 피연산자로 사용되면 객체 리터럴로 해석한다.</p><p>자바스크립트는 매개변수(parameter)와 인수(arguments)의 개수가 일치하지 않아도 오류가 발생하지 않는다.<br>매개변수보다 인수가 적을 경우, 함수를 호출하면서 파라미터에 있는 변수를 선언하기 때문에 <code>undefined</code>로 초기화가 되고, 값이 전달되지 않은 파라미터 변수는 <code>undefined</code>를 가지고 진행한다.</p><p>매개변수보다 인수가 많을 경우, 파라미터를 초과하는 값들은 사라지게 될 것 같지만 함수 내에서 <code>arguments</code>를 불러보면 유사 배열 객체로 인수들이 저장되어 있는 것을 확인할 수 있다.</p><p>이렇게 자바스크립트에서 매개변수와 인수의 개수가 맞지 않거나 입력 받는 타입이 다를 때 오류를 발생시키지 않기 때문에, 함수 내부에서 확인을 하고 오류를 발생시키는 것도 좋은 방법이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure><p>위와 같이 매개변수로 <code>...args</code>를 주면, 파이썬의 <code>*args</code>와 비슷하게 여러 개의 매개변수를 받을 수 있고, 배열로 저장된다.</p><p>함수에서 <code>return</code>이 생략되어도 자바스크립트 엔진이 마지막에 <code>return</code>을 만들어 줘서 <code>undefined</code>값이 리턴된다.</p><p>jQuery에서 파라미터를 하나만 받는 이유</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span> &#125;,</span><br><span class="line">  cache: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파라미터로 하나의 객체에 담아서 주는 이유?</span></span><br><span class="line"><span class="comment">// 프로퍼티가 여러 개 들어갈수록 순서를 지켜야 하고, 타입도 생각을 해야하기 때문에</span></span><br><span class="line"><span class="comment">// 파라미터를 하나만 줘서 가독성 좋게 만들었다.</span></span><br><span class="line"><span class="comment">// 프로퍼티 키가 프로퍼티 값을 설명해주고, 순서를 지키지 않아도 되기 때문에 파라미터는 적을수록 좋다.</span></span><br><span class="line"><span class="comment">// 단점으로 객체 참조할 수 있기 때문에 함수를 거쳐서 원본이 수정될 수 있다.</span></span><br><span class="line"><span class="comment">// 그래서 원본이 수정되지 않게 객체를 동결시켜야하는 경우가 있다. Object.freeze()</span></span><br><span class="line"><span class="comment">// 혹은 객체를 카피(깊은 복사)해서 따로 관리하게 할 수도 있다.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>변수는 값을 재사용하는 것 처럼, 함수는 로직을 재사용하는 것이다.</p><p>중첩함수(nested function)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.</p><p>콜백 함수(callback function)<br>함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라 하고, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복 호출한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f(i); <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure><h1 id="13-스코프"><a href="#13-스코프" class="headerlink" title="13. 스코프"></a>13. 스코프</h1><p>모든 식별자(변수 이름, 함수 이름, 클래스 이름)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는 것을 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.(식별자를 검색하는 규칙)</p><p>전역 변수 - 함수 내부가 아닌 모든 변수<br>지역 변수 - 함수 몸체 내부의 변수</p><p><code>var</code>키워드는 같은 스코프 내에서 중복 선언이 허용되지만, <code>let</code>과 <code>const</code>키워드는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p><p>모든 스코프는 하나의 계측적 구조로 연결되고, 모든 지역 스코프의 최상위 스코프는 전역 스코프다. 스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 한다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.</p><p>렉시컬 환경(Lexical Environment)<br>스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결(chaining)한 것이다.</p><p>블록 레벨 스코프(block level scope)와 함수 레벨 스코프(function level scope)<br>모든 코드 블록(if, for, while, try 등)이 지역 스코프를 만드는 것을 블록 레벨 스코프라 하고, 함수의 코드 블록에서 만 지역 스코프를 만드는 것을 함수 레벨 스코프라 한다.</p><p>자바스크립트에서 <code>var</code>키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. for반복문 안에서 사용되는 <code>i</code>변수는 반복문 안에서만 사용되지만, <code>var</code>키워드로 선언하면 전역 변수가 되기 때문에 의도치 않은 전역 변수 값이 할당된다.<br>ES6에서ES6에 도입된 <code>let</code>, <code>const</code>키워드는 블록 레벨 스코프를 지원한다.</p><p>렉시컬 스코프(lexical scope)와 동적 스코프(dynamic scope)<br>렉시컬 스코프는 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하고, 동적 스코프는 함수를 어디서 정의 했는지에 따라 함수의 상위 스코프를 결정한다.<br>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.<br>결국 렉시컬 스코프는 함수가 호출된 위치는 상위 스코프 경정에 어떠한 영향도 주지 않고 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.<br>이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문, 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.</p><h1 id="15-let-const와-블록-레벨-스코프"><a href="#15-let-const와-블록-레벨-스코프" class="headerlink" title="15. let, const와 블록 레벨 스코프"></a>15. let, const와 블록 레벨 스코프</h1><p><code>var</code>키워드의 문제점은 변수의 중복 선언을 허용하고, 함수 레벨 스코프를 지원하고, 변수 호이스팅이 발생하기 때문에 문제가 된다.</p><p>이러한 단점을 보안하기 위해 ES6에서 나온게 <code>let</code>, <code>const</code>키워드다.<br><code>let</code>, <code>const</code>키워드는 중복 선언을 금지하고, 블록 레벨 스코프를 지원한다. 그리고 변수 호이스팅이 발생하지 않는 것 처럼 보이는데, <code>let</code>키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. 이러한 구간을 일시적 사각지대(Temporal Dead Zone, TDZ)라고 부른다.</p><p><code>let</code>키워드는 재할당이 가능하다.<br><code>const</code>키워드는 재할당이 금지된 변수</p><blockquote><p>왜 const는 상수가 아닐까?</p></blockquote><p><code>const</code>키워드로 변수에 객체를 할당하면 객체는 참조되는 값이기 때문에 수정이 가능하다. 재할당이 금지된거지 참조가 금지된게 아니라서 상수라고 표현할 수 없다.</p><p><code>const</code>로 선언하고, 재할당이 필요하다고 인지할 때 <code>let</code>으로 바꾸는 걸 추천. 생각보다 재할당 할 일이 없다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
