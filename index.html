<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"juhyeong-k.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="All about dev">
<meta property="og:type" content="website">
<meta property="og:title" content="JH&#39;s dev blog">
<meta property="og:url" content="https://juhyeong-k.github.io/index.html">
<meta property="og:site_name" content="JH&#39;s dev blog">
<meta property="og:description" content="All about dev">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Kim Ju Hyeong">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://juhyeong-k.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>JH's dev blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-93XKT8K1JW"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-93XKT8K1JW');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="JH's dev blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JH's dev blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">All about dev</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kim Ju Hyeong</p>
  <div class="site-description" itemprop="description">All about dev</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/20/20210320-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/20/20210320-TIL/" class="post-title-link" itemprop="url">20210320 TIL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-20 22:31:06 / Modified: 23:09:22" itemprop="dateCreated datePublished" datetime="2021-03-20T22:31:06+09:00">2021-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/20/20210320-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/20/20210320-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>Number는 빌트인 객체인 생성자 함수 객체다. new 연산자와 함께 호출하여 Number 인스턴스를 생성한다. new 연산자 없이 호출하면 숫자를 반환 하는데 이를 이용하여 명시적으로 타입을 변환하기도 한다.</p>
<p>래퍼 객체 - 원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데 원시값인 숫자나 문자열에 메소드를 사용할 수 있는 경우가 있다. 이는 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체를 생성하여 그 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다. 이 때, 문자열, 숫자, 불린 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라 한다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/19/20210319-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/19/20210319-TIL/" class="post-title-link" itemprop="url">20210319 TIL JS 6회차</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-19 20:13:50 / Modified: 21:42:24" itemprop="dateCreated datePublished" datetime="2021-03-19T20:13:50+09:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/19/20210319-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/19/20210319-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="배열의-메소드"><a href="#배열의-메소드" class="headerlink" title="배열의 메소드"></a>배열의 메소드</h1><h3 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort"></a>Array.prototype.sort</h3><p>sort 메소드는 원본 배열을 변경하는 mutator, 바뀐 배열을 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort()); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">33</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort()); <span class="comment">// [ 1, 10, 2, 22, 3, 33, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, 10, 2, 22, 3, 33, 5 ]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>문자열이 아닌 숫자를 정렬했는데 왜 저런 순서로 정렬되었을까?</p>
</blockquote>
<p>sort 메소드는 배열의 요소가 숫자 타입이라 할지라도 배열의 요소를 일시적으로 문자열로 변환 후 유니코드 코드 포인트의 순서를 기준으로 정렬한다.<br>숫자 요소를 정렬할 때는 sort 메소드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다. </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">33</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열의 오름차순 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)); <span class="comment">// [ 1,  2,  3, 5, 10, 22, 33 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자 배열의 내림차순 정렬</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a)); <span class="comment">// [ 33, 22, 10, 5, 3,  2,  1 ]</span></span><br></pre></td></tr></table></figure>
<p>sort 메소드는 함수를 전달 받았기 때문에 고차 함수(Higher-Order Function, HOF)다.</p>
<h3 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수"></a>배열 고차 함수</h3><p>고차 함수는 함수를 인자로 전달 받거나 함수를 반환하는 함수를 말한다. 외부 상태의 변경(인수로 객체를 전달했을 경우 함수 내부에서 재할당없이 자유자재로 변경이 가능)이나 가변(mutable) 데이터를 피하고 불변성(immutability)을 지향하는 함수형 프로그래밍을 기반에 두고 있다.<br>함수형 프로그래밍은 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.</p>
<h3 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach"></a>Array.prototype.forEach</h3><p>forEach 메소드는 반복문을 추상화한 고차 함수로서 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야할 처리를 콜백 함수로 전달받아서 반복 호출한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> pows = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach 메서드는 numbers 배열의 모든 요소를 순회하면서 콜백 함수를 반복 호출한다.</span></span><br><span class="line">numbers.forEach(<span class="function"><span class="params">item</span> =&gt;</span> pows.push(item ** <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pows); <span class="comment">// [1, 4, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach와 같은 기능을 하는 함수를 만들어 보자.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a funciton`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">numbers.myForEach(<span class="function"><span class="params">v</span> =&gt;</span> pows.push(v ** <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(pows); <span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>forEach 메소드의 반환값은 언제나 <code>defined</code>다.</p>
<h3 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map"></a>Array.prototype.map</h3><p>map 메소드는 콜백함수의 반환값들로 구성된 새로운 배열을 반환한다. 반환된 새로운 배열의 length 프로퍼티 값은 map 메서드를 호출한 배열의 length 프로퍼티 값과 일치한다. 1:1 매핑(mapping)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map과 같은 기능을 하는 myMap을 만들어보자.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;fn&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        res.push(fn(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers.myMap(<span class="function"><span class="params">v</span> =&gt;</span> v ** <span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter"></a>Array.prototype.filter</h3><p>filter 메소드는 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. filter 메소드가 생성하여 반환한 새로운 배열의 length 프로퍼티 값은 filter 메소드를 호출한 배열의 length 프로퍼티 값과 같거나 작다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter와 같은 기능을 하는 myFilter</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">`<span class="subst">$&#123;callback&#125;</span> is not a function`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback(<span class="built_in">this</span>[i], i, <span class="built_in">this</span>)) res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(numbers.myFilter(<span class="function"><span class="params">v</span> =&gt;</span> v &gt; <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce"></a>Array.prototype.reduce</h3><p>reduce 메소드는 2개의 값을 이용해서 행동을 한다. map과 filter와 다르게 누계를 해야 하기 때문에 4개의 파라미터를 받는다(accumulator, currentValue, index, array)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/18/20210318-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/18/20210318-TIL/" class="post-title-link" itemprop="url">20210318 TIL JS 내용 정리</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-18 12:58:07 / Modified: 20:09:24" itemprop="dateCreated datePublished" datetime="2021-03-18T12:58:07+09:00">2021-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/18/20210318-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/18/20210318-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-프로퍼티-어트리뷰트"><a href="#16-프로퍼티-어트리뷰트" class="headerlink" title="16. 프로퍼티 어트리뷰트"></a>16. 프로퍼티 어트리뷰트</h1><h3 id="내부-슬롯과-내부-메소드"><a href="#내부-슬롯과-내부-메소드" class="headerlink" title="내부 슬롯과 내부 메소드"></a>내부 슬롯과 내부 메소드</h3><p>내부 슬롯(internal slot)과 내부 메소드(internal method)는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 pseudo property, pseudo method이다. 대괄호 두개로 감싼 이름들이 이에 해당한다. ex) <code>[[Prototype]]</code></p>
<p>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 로직이기 때문에 직접적인 접근은 제공하지 않고 일부 내부 슬롯과 내부 메소드에 한해서 간접적으로 접근할 수 있는 방법을 제공한다. 예를 들어 <code>[[Prototype]]</code>내부 슬롯은 <code>__proto__</code> 접근자 프로퍼티로 간접적으로 접근이 가능하다.</p>
<p>프로퍼티를 생성할 대 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.</p>
<table>
<thead>
<tr>
<th align="center">프로퍼티 상태</th>
<th align="center">내부 상태값(meta-property)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">프로퍼티 값</td>
<td align="center">[[Value]]</td>
</tr>
<tr>
<td align="center">값의 갱신 가능 여부</td>
<td align="center">[[Writable]]</td>
</tr>
<tr>
<td align="center">열거 가능 여부</td>
<td align="center">[[Enumerable]]</td>
</tr>
<tr>
<td align="center">재정의 가능 여부</td>
<td align="center">[[Configurable]]</td>
</tr>
</tbody></table>
<p>프로퍼티 어트리뷰트에 직접 접근할 수 없지만 <code>Object.getOwnPropertyDescriptor</code>메소드를 이용해서 간접적으로 접근 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Kim&#x27;</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123; value: &#x27;Kim&#x27;, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(person));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">     name: &#123; value: &#x27;Kim&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">     age: &#123; value: 27, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>이와 같이 반환된 객체를 프로퍼티 디스크립터(PropertyDescriptor)라 한다.</p>
<h3 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h3><p>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 나눌 수 있다.</p>
<p>데이터 프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티로, <code>[[Value]]</code>, <code>[[Writable]]</code>, <code>[[Enumerable]]</code>, [[Configurable]]의 프로퍼티 어트리뷰트를 갖는다.</p>
<p>접근자 프로퍼티는 자체적으로는 값을 갖지 않고 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(accessor function)로 구성된 프로퍼티다. <code>[[Get]]</code>, <code>[[Set]]</code>, <code>[[Enumerable]]</code>, <code>[[Configurable]]</code>의 프로퍼티 어트리뷰트를 갖는다.</p>
<p>일반 객체의 <code>__proto__</code>는 접근자 프로퍼티, 함수 객체의 <code>prototype</code>은 데이터 프로퍼티다.</p>
<p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다. <code>Object.defineProperty</code>, <code>Object.definePropertues</code>를 활용해서 정의할 수 있다.</p>
<p>객체는 재할당 없이 직접 변경이 가능한데, 이를 방지하는 메소드가 있다.</p>
<table>
<thead>
<tr>
<th align="center">메소드</th>
<th align="center">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Object.preventExtension</code></td>
<td align="center">객체 확장 금지, 프로퍼티 추가만 금지한다</td>
</tr>
<tr>
<td align="center"><code>Object.seal</code></td>
<td align="center">객체 밀봉, 프로퍼티 갱신과 프로퍼티 읽기만 가능하다</td>
</tr>
<tr>
<td align="center"><code>Object.freeze</code></td>
<td align="center">객체 동결, 프로퍼티 읽기만 가능하다</td>
</tr>
</tbody></table>
<p>객체 변경 방지 메소드는 얕은 변경 방지(shallow only)이기 때문에 깊은 변경 방지를 하기 위해서는 재귀를 사용해야 한다. <code>Object.freeze</code> 메소드와 깊은 변경 방지를 이용해서 불변 객체를 구현할 수 있다.</p>
<p>프로토타입<br>추상연산은 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/17/20210317-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/20210317-TIL/" class="post-title-link" itemprop="url">20210317 TIL JS 5회차</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-17 14:47:10 / Modified: 20:34:40" itemprop="dateCreated datePublished" datetime="2021-03-17T14:47:10+09:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/17/20210317-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/17/20210317-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>for문 대신에 reduce, filter, map으로 반복문 대체 가능</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  만약 재귀를 한다면 add와 foo중 어느 것을 쓰는게 나을까?</span></span><br><span class="line"><span class="comment">  스코프 관점에서 보면 foo 쓰는게 낫다. 굳이 스코프 체인을 통해</span></span><br><span class="line"><span class="comment">  전역으로 가서 확인할 필요가 없다.</span></span><br><span class="line"><span class="comment">  하지만 애초에 함수 표현식에서 함수 이름은 생략이 가능하기 때문에</span></span><br><span class="line"><span class="comment">  함수 이름을 생략하고 변수로 사용하는게 나을 것 같다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="27-배열"><a href="#27-배열" class="headerlink" title="27. 배열"></a>27. 배열</h1><p>자바스크립트에서 배열은 값으로 올 수 있는 모든 값이 올 수 있고 요소들의 타입이 일치하지 않아도 된다. 다만, 자바스크립트에서 배열을 쓰는 이유는 length 프로퍼티를 이용해서 looping(반복)하기 위해 사용하는거라 다름 없기 때문에 배열의 타입을 일치 시키는게 좋다.</p>
<p>자료구조(Data Structure)에서의 배열과 자바스크립트의 배열은 다르다. 자료구조에서의 배열은 동일한 크기의 메모리공간이 빈틈없이 연속적으로 나열된 자료구조라서 선두 메모리 어드레스와 메모리 크기만 알고 있다면 빠른 접근이 가능하다. 자바스크립트에서의 배열은 같은 크기를 가지고 있다면 배열로 만들고, 타입과 크기가 다르다면 해쉬 테이블로 만든다고 한다.</p>
<p>일반적인 배열은 인덱스로 요소에 빠르게 접근할 수 있지만, 특정 요소를 검색하거나 요소를 삽입, 삭제하는 경우에는 비효율적이다.<br>자바스크립트 배열은 해시 테이블로 구현된 객체이므로 인덱스로 접근하는 경우 일반적인 배열보다 성능적인 면에서 느릴 수 밖에 없는 구조적 단점이 있지만, 특정 요소를 검색하거나 요소를 삽입, 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p>
<p>인덱스로 배열 요소에 접근할 때 일반적인 배열보다 느릴 수 밖에 없는 구조적 단점을 보완하기 위해 대부분의 모던 자바스크립트 엔진은 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화를 구현했다.</p>
<p>REST 파라미터와 스프레드 문법</p>
<p>프로토타입</p>
<p>배열의 mutator와 accessor</p>
<p>splice(), 스프레드 문법으로 얕은 복사(shallow copy)가능 하다.<br>얕은 복사는 한 단계까지만 가능하다.</p>
<p>깊은 복사를 하려면 재귀를 써야 한다.<br>typeOf메소드로 객체인지 확인 후 객체라면 그 객체의 프로퍼티에 다시 접근 후 객체라면 다시…<br>기존에 만들어진 library를 사용해도 된다.(Lodash 라이브러리의 .clonedeep)<br>라이브러리에 만들어진 함수들을 직접 구현해보는 연습을 한다면 많은 도움이 된다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/16/20210316-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/16/20210316-TIL/" class="post-title-link" itemprop="url">20210316 TIL JS 예습</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-16 10:27:10" itemprop="dateCreated datePublished" datetime="2021-03-16T10:27:10+09:00">2021-03-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-18 12:56:43" itemprop="dateModified" datetime="2021-03-18T12:56:43+09:00">2021-03-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/16/20210316-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/16/20210316-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="17-생성자-함수에-의한-객체-생성"><a href="#17-생성자-함수에-의한-객체-생성" class="headerlink" title="17. 생성자 함수에 의한 객체 생성"></a>17. 생성자 함수에 의한 객체 생성</h1><p>생성자 함수(constructor)란 <code>new</code> 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.<br>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수를 제공한다.</p>
<p><code>new</code>연산자와 함께 호출하지 않으면 일반 함수로 호출된다.</p>
<blockquote>
<p>Object 생성자 함수를 사용해서 객체를 생성하는 것 보다 객체 리터럴을 이용하는게 더 직관적이고 편한 것 같은데 생성자 함수로 생성해야되는 이유가 있을까?</p>
</blockquote>
<p>공통된 프로퍼티를 여러 객체가 가져야 할 경우, 생성자 함수를 이용하면 간편하게 생성할 수 있다. 객체 리터럴은 직관적이고 편리하지만, 공통된 프로퍼티들을 갖는 여러 객체들에게 각각 프로퍼티를 입력해줘야 하는 단점이 있다.</p>
<p>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수고, 생성된 인스턴스를 초기화하는 것은 옵션이다.</p>
<p>생성자 함수의 인스턴스 생성 과정</p>
<ul>
<li>인스턴스 생성과 this 바인딩은 런타임 이전에 암묵적으로 자바스크립트 엔진에 의해 실행된다.</li>
<li>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 한 뒤(this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드 추가) 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스의 바인딩 된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환되기 때문에 생성자 함수의 기본 동작을 훼손하지 않으려면 생성자 함수 내부에서 return문을 반드시 생략해야 한다. 단, 원시값을 return 하면 무시되고 this가 암묵적으로 반환된다.</li>
</ul>
<p>객체에는 일반 객체와 함수 객체가 있는데, 둘을 구분할 수 있는 기준은 호출이 가능한지 아닌지로 할 수 있다. 즉 객체 내부 메소드 <code>[[call]]</code>을 가지고 있는 객체를 함수 객체라 할 수 있다. 함수 객체에서 일반함수와 생성자 함수를 구분하자면, constructor와 non-constructor로 구분할 수 있다. constructor는 내부 메서드 <code>[[construct]]</code>를 갖는 함수 객체로 생성자 함수로서 호출할 수 있는 함수를 말하고, non-constructor는 <code>[[construct]]</code>를 갖지 않는, 생성자 함수로서 호출할 수 없는 함수를 의미한다. </p>
<ul>
<li>constructor : 함수 선언문, 함수 표현식, 클래스</li>
<li>non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수</li>
</ul>
<p>프로퍼티 값으로 함수를 사용하면 일반적으로 메소드라 칭하는데, ECMAScript의 사양에서 메소드는 ES6의 메서드 축약 표현만 의미한다.</p>
<p>사실 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하는지 안하는지에 따라 달라지기 때문이다. 즉, new 연산자 없이 constructor를 호출하면 일반 함수로 호출되고, new 연산자와 함께 cosntructor를 호출하면 생성자 함수로 호출된다.<br>생성자 함수와 일반 함수를 구별하기 위해서 생성자 함수의 이름을 파스칼 케이스로 명명하지만, 실수는 언제나 발생할 수 있다. 이런 위험성을 회피하기 위해 ES6에서 <code>new.target</code>을 지원한다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었을 때 함수 자신을 가리키고, new 연산자 없이 일반 함수로 호출되었다면 undefined를 의미한다. 따라서 함수 내부에서 new 연산자와 함께 재귀 호출을 통해 생성자 함수로 호출할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());</span><br></pre></td></tr></table></figure>
<h1 id="25-ES6-함수의-추가-기능"><a href="#25-ES6-함수의-추가-기능" class="headerlink" title="25. ES6 함수의 추가 기능"></a>25. ES6 함수의 추가 기능</h1><h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>화살표 함수(arrow function)는 function 키워드 대신 화살표(<code>=&gt;</code>,fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의 할 수 있고, 내부 동작도 기존의 함수보다 간략하다. 특히 콜백 함수 내부에서 <code>this</code>전역 객체를 가리키는 문제를 해결하기 위한 대안으로 많이 사용된다.</p>
<p>화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 매개변수가 여러 개인 경우 소괄호 안에 매개변수 선언한다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 한 개인 경우 소괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">x</span> =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 없는 경우 소괄호 생략 불가능</span></span><br><span class="line">cosnt arrow = <span class="function">() =&gt;</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>함수 몸체가 값으로 평가되는 표현식인 문이라면 중괄호(<code>&#123;&#125;</code>)를 생략할 수 있고 암묵적으로 반환되지만, 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> x ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">//동일한 표현</span></span><br><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> x ** <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식이 아닌 문은 반환할 수 없기 때문에 중괄호 생략 불가능하다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> <span class="keyword">const</span> x = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123; <span class="keyword">const</span> x = <span class="number">1</span>; &#125; <span class="comment">// 맞는 표현</span></span><br></pre></td></tr></table></figure>

<p>객체 리터럴을 반환할 때 소괄호(<code>()</code>)로 감싸야 한다. 그렇지 않으면 객체 리터럴의 중괄호(<code>&#123;&#125;</code>)를 함수 몸체를 감싸는 중괄호로 잘못 해석하기 때문에 쉼표를 함수 몸체 내의 쉼표 연산문으로 해석한다.</p>
<h1 id="26-배열"><a href="#26-배열" class="headerlink" title="26. 배열"></a>26. 배열</h1><p>배열(array)은 여러 개의 값을 순차적으로 나열한 자료 구조다. 배열이 가지고 있는 값을 요소(element)라고 부르고, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.</p>
<p>자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// -&gt; object</span></span><br></pre></td></tr></table></figure>
<p>배열은 객체지만 일반 객체와는 구별되는 특징이 있다. 구분하는 가장 명확한 차이는 “값의 순서”와 “length 프로퍼티”다.</p>
<h3 id="자바스크립트-배열은-배열이-아니다"><a href="#자바스크립트-배열은-배열이-아니다" class="headerlink" title="자바스크립트 배열은 배열이 아니다"></a>자바스크립트 배열은 배열이 아니다</h3><p>자료구조(data structure)에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(dense array)이라 한다.</p>
<blockquote>
<p>검색 대상의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수</p>
</blockquote>
<p>예를 들어 메모리 주소 1000에서 시작하고 각 요소의 크기가 8바이트인 배열을 생각해보면,</p>
<ul>
<li>인덱스가 0인 요소의 메모리 주소: 1000 + 0 * 8 = 1000</li>
<li>인덱스가 1인 요소의 메모리 주소: 1000 + 1 * 8 = 1008</li>
<li>인덱스가 2인 요소의 메모리 주소: 1000 + 2 * 8 = 1016</li>
</ul>
<p>이렇게 표현될 수 있다. 이처럼 배열은 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있고 시간 복잡도 <code>O(1)</code>라고 표현할 수 있다. 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형검색(linear search), 시간 복잡도 <code>O(n)</code>)해야 한다. 또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소들을 이동시켜야 하는 단점도 있다.</p>
<p>자바스크립트에서의 배열은 위에서 설명한 일반적인 의미의 배열과 다르다. 자바스크립트에서의 배열은 배열의 요소를 위한 각각의 메모리 공간을 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열(sparse array)이라 한다.<br><strong>자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.</strong></p>
<p>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, 배열의 요소를 프로퍼티 값으로 갖고, length 프로퍼티를 갖는 특수한 객체다.</p>
<p>정리하자면 일반적인 배열은 인덱스로 배열 요소에 접근이 빠른 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않지만, 자바스크립트 배열은 인덱스로 배열 요소에 접근이 느린 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p>
<p>자바스크립트 배열의 length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제할 때 자동으로 갱신된다.<br>length 프로퍼티의 값은 배열의 길이를 바탕으로 결정되지만, 임의의 숫자 값을 명시적으로 할당할 수도 있다. 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>반대로 현재 legth 프로퍼티 값보다 큰 숫자 값을 할당하면 length 프로퍼티의 값은 변경이 되지만 실제 배열의 길이가 늘어나지는 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 4, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;4 empty items&gt;</code>는 실제로 추가된 배열의 요소가 아니다. length 프로퍼티 값이 변경됐다고 해도 값 없이 비어 있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [,, <span class="number">3</span>,, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5 ]</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>
<p>일반적인 배열의 length는 배열의 요소의 개수와 언제나 일치하지만, 희소 배열은 length와 배열의 요소 개수와 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.</p>
<p>자바스크립트는 문법적으로 희소 배열을 허용하지만 희소 배열은 사용하지 않는 것이 좋다. 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.</p>
<h3 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h3><p>객체와 마찬가지로 배열도 다양한 생성 방식이 있는데, 가장 일반적이고 간단한 배열 생성 방식은 배열 리터럴을 사용하는 것이다. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분해서 대괄호(<code>[ ]</code>)로 묶는다.</p>
<p>Object 생성자 함수를 통해 객체를 생성할 수 있듯이 Array 생성자 함수를 통해 배열을 생성할 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">대부분의 빌트인 생성자 함수(Object, Function, Array, Date, RegExp, Promise 등)는 </span></span><br><span class="line"><span class="comment">new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. </span></span><br><span class="line"><span class="comment">생성자 함수 내부에서 new.target을 확인하기 때문이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>Array 생성자 함수에 전달되는 인수가 1개이고 숫자인 경우, length 프로퍼티 값이 인수인 배열을 생성한다. length 프로퍼티 값이 0은 아니지만 실제로 배열의 요소는 존재하지 않는 희소 배열이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br></pre></td></tr></table></figure>
<p>전달된 인수가 없는 경우 length 프로퍼티 값이 0인 빈 배열을 생성한다. 즉 배열 리터럴(<code>[ ]</code>)과 같다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전달되는 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전달되는 인수가 1개지만, 숫자가 아닌 인수이기 때문에 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ &#123;&#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="string">&#x27;string&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><code>Array.of</code>는 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr1));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: &#x27;a&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: &#x27;b&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: &#x27;c&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>ES6에서 도입된 <code>Array.from</code>메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달 받아서 배열로 변환 후, 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 길이에 맞게 undefined를 요소로 채운다.</span></span><br><span class="line"><span class="keyword">const</span> arr3 = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환 값으로 구성된 배열을 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 요소의 참조</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 인덱스가 2인 요소를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 존재하지 않는 요소에 접근하면 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열도 마찬가지</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>,,<span class="number">3</span>,,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr2));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;4&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 5, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="comment">//배열 요소 추가</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="string">&#x27;1&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">arr[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">arr.bar = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1.1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, foo: 3, bar: 4, &#x27;1.1&#x27;: 5, &#x27;-1&#x27;: 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티는 배열의 length에 영향을 주지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 2, writable: true, enumerable: false, configurable: false &#125;,</span></span><br><span class="line"><span class="comment">  foo: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  bar: &#123; value: 4, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1.1&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;-1&#x27;: &#123; value: 6, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>인덱스는 요소의 위치를 나타내기 때문에 반드시 0 이상의 정수(정수 형태 문자열)를 사용해야 한다. 정수 이외에 값을 인덱스처럼 사용한다면 요소가 생성되는게 아닌 프로퍼티가 추가된다. 추가된 프로퍼티는 요소가 아니기 때문에 배열의 length 프로퍼티에 영향을 미치지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, &lt;1 empty item&gt;, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>배열도 객체이기 때문에 <code>delete</code>연산자를 이용해서 요소를 삭제할 수 있다. 위의 경우 1번 인덱스의 값을 삭제하면서 희소 배열이 되고 length 프로퍼티의 값은 변하지 않는다. 희소 배열을 만드는 delete 연산자는 사용하지 않는게 좋다. 만약 희소 배열로 만들지 않고 배열의 특정 요소를 완전히 삭제하려면 <code>Array.prototype.splice</code>메소드를 사용한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.slplice(삭제를 시작 할 인덱스, 삭제할 요소 개수)</span></span><br><span class="line">arr1.splice(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1번 인덱스부터 2개 삭제</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열로 만들어지는 경우</span></span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, &lt;2 empty items&gt;, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본을 직접 변경하는 push 메소드</span></span><br><span class="line">arr1.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 배열을 생성하는 concat 메소드</span></span><br><span class="line"><span class="keyword">const</span> result = arr2.concat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>자바스크립트에서 배열 메소드는 결과물을 반환하는 패턴이 두 가지 있다. 원본 배열(배열 메소드를 호추한 배열, 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method)와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method)가 있다.<br>원본을 직접 변경하는 메소드는 외부 상태를 직접 변경하는 부수 효과(side effect)가 있으므로 가급적 원본 배열을 직접 변경하지 않는 메소드를 사용하는 편이 좋다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.push</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line">arr1.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr1 performance test: 0.134ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [arr.length] </span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line">arr2[arr2.length] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr2 performance test: 0.01ms</span></span><br></pre></td></tr></table></figure>
<p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.<br>마지막 요소로 추가할 요소가 하나뿐이라면 push 메소드보다 length 프로퍼티를 사용해서 배열의 마지막에 요소를 직접 추가하는게 더 빠르다.(push 메소드는 성능 면에서 좋지 않다.)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/15/20210315-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/15/20210315-TIL/" class="post-title-link" itemprop="url">20210315 TIL JS 4회차</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-15 13:57:29" itemprop="dateCreated datePublished" datetime="2021-03-15T13:57:29+09:00">2021-03-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-17 09:57:22" itemprop="dateModified" datetime="2021-03-17T09:57:22+09:00">2021-03-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/15/20210315-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/15/20210315-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="12-함수"><a href="#12-함수" class="headerlink" title="12. 함수"></a>12. 함수</h1><p>인수(argument)는 함수 밖에서 함수 매개변수(parameter)에 순서대로 할당된다.<br>매개변수는 0개 이상<br>함수 정의만으로 함수가 실행되지 않고 함수를 호출해야 실행이 된다.</p>
<p>변수 호이스팅과 함수 호이스팅은 미묘한 차이가 있다.<br>변수 선언문은 런타임 이전에 변수가 <code>undefined</code>로 초기화가 되고, 런타임에 값이 할당 되어지지만, 함수 선언문은 runtime 이전에 정의가 되어지기 때문에 함수 정의가 어느 위치에 있던 런타임 시 첫째줄에 호출을 해도 실행이 된다.</p>
<p>함수 표현식을 사용하면 변수 호이스팅이 발생해서 runtime 이전에 변수에 undefined로 초기화되고 런타임에 순서에 맞게 함수가 정의가 된다. 즉, 함수 표현식은 정의 이전에 호출할 수 없다.</p>
<p>함수 이름은 함수 몸체 안에서만 유효하다. 그래서 함수 표현식에서 함수 이름은 생략이 가능하다. 함수 몸체 안에서 사용할 때는 재귀를 사용할때 정도로 생각할 수 있는데, 굳이 함수 이름이 아닌 식별자로 넣어줘도 문제 없기 때문에, 함수 표현식에서 함수 이름은 생략한다.</p>
<p>함수 리터럴 - 함수객체를 생성하는 것</p>
<p>일반 객체와 함수 객체의 차이는 호출 가능/불가능 차이</p>
<blockquote>
<p>함수 선언문과 함수 표현식 둘 중 어떤걸 사용하는게 좋을까?<br>함수 선언문은 함수 객체가 런타임 이전에 만들어지고 함수 표현식은 런타임 때 만들어진다. 결국 함수 객체를 생성하는 시점에 차이가 있다. 둘 중 어느걸 사용해도 상관은 없지만 일관성 있게 사용해야 한다.(결국 나중에 애로우 함수를 사용할 것이기 때문에..)</p>
</blockquote>
<p>함수가 호출이 되면 함수가 정의된 부분으로 돌아가서 함수 코드블록을 실행하기 때문에, 함수도 제어문의 일종이라고 볼 수 있다.</p>
<blockquote>
<p>{ }는 블록문일까 객체 리터럴일까?</p>
</blockquote>
<p><code>&#123; &#125;</code>는 블록문 일수도 객체 리터럴일 수도 있다. <code>&#123; &#125;</code>는 중의적 표현이기 때문에 자바스크립트 엔진이 코드의 문맥에 따라 해석을 달리한다. <code>&#123; &#125;</code>가 단독을 존재하면 블록문으로 해석하고, <code>&#123; &#125;</code>가 값으로 평가되어야 할 문맥(할당연산자의 우변)에서 피연산자로 사용되면 객체 리터럴로 해석한다.</p>
<p>자바스크립트는 매개변수(parameter)와 인수(arguments)의 개수가 일치하지 않아도 오류가 발생하지 않는다.<br>매개변수보다 인수가 적을 경우, 함수를 호출하면서 파라미터에 있는 변수를 선언하기 때문에 <code>undefined</code>로 초기화가 되고, 값이 전달되지 않은 파라미터 변수는 <code>undefined</code>를 가지고 진행한다.</p>
<p>매개변수보다 인수가 많을 경우, 파라미터를 초과하는 값들은 사라지게 될 것 같지만 함수 내에서 <code>arguments</code>를 불러보면 유사 배열 객체로 인수들이 저장되어 있는 것을 확인할 수 있다.</p>
<p>이렇게 자바스크립트에서 매개변수와 인수의 개수가 맞지 않거나 입력 받는 타입이 다를 때 오류를 발생시키지 않기 때문에, 함수 내부에서 확인을 하고 오류를 발생시키는 것도 좋은 방법이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>위와 같이 매개변수로 <code>...args</code>를 주면, 파이썬의 <code>*args</code>와 비슷하게 여러 개의 매개변수를 받을 수 있고, 배열로 저장된다.</p>
<p>함수에서 <code>return</code>이 생략되어도 자바스크립트 엔진이 마지막에 <code>return</code>을 만들어 줘서 <code>undefined</code>값이 리턴된다.</p>
<p>jQuery에서 파라미터를 하나만 받는 이유</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span> &#125;,</span><br><span class="line">  cache: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파라미터로 하나의 객체에 담아서 주는 이유?</span></span><br><span class="line"><span class="comment">// 프로퍼티가 여러 개 들어갈수록 순서를 지켜야 하고, 타입도 생각을 해야하기 때문에</span></span><br><span class="line"><span class="comment">// 파라미터를 하나만 줘서 가독성 좋게 만들었다.</span></span><br><span class="line"><span class="comment">// 프로퍼티 키가 프로퍼티 값을 설명해주고, 순서를 지키지 않아도 되기 때문에 파라미터는 적을수록 좋다.</span></span><br><span class="line"><span class="comment">// 단점으로 객체 참조할 수 있기 때문에 함수를 거쳐서 원본이 수정될 수 있다.</span></span><br><span class="line"><span class="comment">// 그래서 원본이 수정되지 않게 객체를 동결시켜야하는 경우가 있다. Object.freeze()</span></span><br><span class="line"><span class="comment">// 혹은 객체를 카피(깊은 복사)해서 따로 관리하게 할 수도 있다.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>변수는 값을 재사용하는 것 처럼, 함수는 로직을 재사용하는 것이다.</p>
<p>중첩함수(nested function)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.</p>
<p>콜백 함수(callback function)<br>함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라 하고, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복 호출한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f(i); <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>
<h1 id="13-스코프"><a href="#13-스코프" class="headerlink" title="13. 스코프"></a>13. 스코프</h1><p>모든 식별자(변수 이름, 함수 이름, 클래스 이름)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는 것을 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.(식별자를 검색하는 규칙)</p>
<p>전역 변수 - 함수 내부가 아닌 모든 변수<br>지역 변수 - 함수 몸체 내부의 변수</p>
<p><code>var</code>키워드는 같은 스코프 내에서 중복 선언이 허용되지만, <code>let</code>과 <code>const</code>키워드는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>
<p>모든 스코프는 하나의 계측적 구조로 연결되고, 모든 지역 스코프의 최상위 스코프는 전역 스코프다. 스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 한다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.</p>
<p>렉시컬 환경(Lexical Environment)<br>스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결(chaining)한 것이다.</p>
<p>블록 레벨 스코프(block level scope)와 함수 레벨 스코프(function level scope)<br>모든 코드 블록(if, for, while, try 등)이 지역 스코프를 만드는 것을 블록 레벨 스코프라 하고, 함수의 코드 블록에서 만 지역 스코프를 만드는 것을 함수 레벨 스코프라 한다.</p>
<p>자바스크립트에서 <code>var</code>키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. for반복문 안에서 사용되는 <code>i</code>변수는 반복문 안에서만 사용되지만, <code>var</code>키워드로 선언하면 전역 변수가 되기 때문에 의도치 않은 전역 변수 값이 할당된다.<br>ES6에서ES6에 도입된 <code>let</code>, <code>const</code>키워드는 블록 레벨 스코프를 지원한다.</p>
<p>렉시컬 스코프(lexical scope)와 동적 스코프(dynamic scope)<br>렉시컬 스코프는 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하고, 동적 스코프는 함수를 어디서 정의 했는지에 따라 함수의 상위 스코프를 결정한다.<br>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.<br>결국 렉시컬 스코프는 함수가 호출된 위치는 상위 스코프 경정에 어떠한 영향도 주지 않고 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.<br>이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문, 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.</p>
<h1 id="15-let-const와-블록-레벨-스코프"><a href="#15-let-const와-블록-레벨-스코프" class="headerlink" title="15. let, const와 블록 레벨 스코프"></a>15. let, const와 블록 레벨 스코프</h1><p><code>var</code>키워드의 문제점은 변수의 중복 선언을 허용하고, 함수 레벨 스코프를 지원하고, 변수 호이스팅이 발생하기 때문에 문제가 된다.</p>
<p>이러한 단점을 보안하기 위해 ES6에서 나온게 <code>let</code>, <code>const</code>키워드다.<br><code>let</code>, <code>const</code>키워드는 중복 선언을 금지하고, 블록 레벨 스코프를 지원한다. 그리고 변수 호이스팅이 발생하지 않는 것 처럼 보이는데, <code>let</code>키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. 이러한 구간을 일시적 사각지대(Temporal Dead Zone, TDZ)라고 부른다.</p>
<p><code>let</code>키워드는 재할당이 가능하다.<br><code>const</code>키워드는 재할당이 금지된 변수</p>
<blockquote>
<p>왜 const는 상수가 아닐까?</p>
</blockquote>
<p><code>const</code>키워드로 변수에 객체를 할당하면 객체는 참조되는 값이기 때문에 수정이 가능하다. 재할당이 금지된거지 참조가 금지된게 아니라서 상수라고 표현할 수 없다.</p>
<p><code>const</code>로 선언하고, 재할당이 필요하다고 인지할 때 <code>let</code>으로 바꾸는 걸 추천. 생각보다 재할당 할 일이 없다.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/" class="post-title-link" itemprop="url">[BAEKJOON] 이진수 변환 10829번</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-14 18:13:50 / Modified: 18:54:04" itemprop="dateCreated datePublished" datetime="2021-03-14T18:13:50+09:00">2021-03-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/BAEKJOON/" itemprop="url" rel="index"><span itemprop="name">BAEKJOON</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/14/BAEKJOON-이진수-변환-10829번/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>자연수 N이 주어진다. N을 이진수로 바꿔서 출력하는 프로그램을 작성하시오.</p>
<p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000,000,000,000)</p>
<p>N을 이진수로 바꿔서 출력한다. 이진수는 0으로 시작하면 안 된다.</p>
<h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>문제를 보고 제일 처음 생각난 건 파이썬 내장함수 <code>bin()</code>을 활용하면 바로 풀 수 있겠다는 생각이 들었다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파이썬 내장함수 bin() 활용</span></span><br><span class="line">print(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">input</span>()))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 성공</span></span><br></pre></td></tr></table></figure>
<p>제출에 통과는 했지만 이렇게 푸는 건 도움이 되지 않는다 생각되어서 다른 방법을 생각해봤다.</p>
<p>10진수에서 2진수로 변환할 때 보통 소인수분해를 이용해서 구한다. 53을 2로 나눈 값과 나머지를 구하고 나눈 값을 또 다시 나눠서 값과 나머지를 구하고… 이렇게 나눠지지 않을 때 까지 나눈 뒤에 나머지 값들을 역순으로 정렬하면 이진수 값이 나온다. 이 방법 그대로 재귀함수를 사용하면 풀 수 있다고 생각하고 탈출 조건으로 몫이 0일 때 <code>return</code>한다고 하고 pseudo 코드를 작성하고 그 코드로 실행을 해봤다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;out:</span></span><br><span class="line"><span class="string">53</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for +: &#x27;NoneType&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>예상과 다르게 <code>TypeError</code>가 발생했다. 생각해보니 <code>return</code> 값으로 <code>None</code>이 나오기 때문에 타입이 다른 문자열 타입과 더하지 못했다. <code>return</code> 값으로 타입을 맞추기 위해 빈 문자열(<code>&#39;&#39;</code>)을 주고 다시 실행해봤다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;out:</span></span><br><span class="line"><span class="string">53</span></span><br><span class="line"><span class="string">110101</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>예상대로 출력이 잘 되었고 제출 후 통과했다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 이진수 변환 - 10829번</span></span><br><span class="line"><span class="comment"># 첫째 줄에 자연수 N이 주어진다.</span></span><br><span class="line"><span class="comment"># N을 이진수로 바꿔 출력하고</span></span><br><span class="line"><span class="comment"># 이진수는 0으로 시작하면 안된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이썬 내장함수 bin() 활용</span></span><br><span class="line">print(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">input</span>()))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - 변수를 사용한 방법</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - 변수를 사용하지 않는 방법</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(n % <span class="number">2</span>)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - str대신 f-string으로</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="string">f&#x27;<span class="subst">&#123;n % <span class="number">2</span>&#125;</span>&#x27;</span></span><br><span class="line">print(factorization(n))</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/14/20210314-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/14/20210314-TIL/" class="post-title-link" itemprop="url">20210314 TIL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-14 09:40:08" itemprop="dateCreated datePublished" datetime="2021-03-14T09:40:08+09:00">2021-03-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-15 13:57:17" itemprop="dateModified" datetime="2021-03-15T13:57:17+09:00">2021-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/14/20210314-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/14/20210314-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JS-예습-정리"><a href="#JS-예습-정리" class="headerlink" title="JS 예습 정리"></a>JS 예습 정리</h1><h2 id="12-함수"><a href="#12-함수" class="headerlink" title="12. 함수"></a>12. 함수</h2><h3 id="함수란"><a href="#함수란" class="headerlink" title="함수란?"></a>함수란?</h3><p>함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.</p>
<p>함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 함수는 값이며 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.<br>매개변수(parameter)와 인수(argument)를 잘 구별해서 사용하자.</p>
<h3 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h3><p>함수는 필요할 때 여러번 호출할 수 있다. 즉, 실행 시점을 개발자가 결정할 수 있고 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 여러번 작성하는 것이 아니라 미리 정의된 함수를 재사용하는 것이 효율적이다. 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용 측면에서 유용하다. 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</p>
<h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.<br>함수이름 - 함수 이름은 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다. 함수 이름은 생략할 수 있고, 이름이 있는 함수를 기명 함수(named function), 이름이 없는 함수를 무명/익명 함수(anonymous function)라고 한다.</p>
<blockquote>
<p>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다?</p>
</blockquote>
<p>매개변수 목록 - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 함수를 호출할 때 각 매개변수에는 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 결국 <strong>매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.</strong></p>
<p>함수 몸체 - 함수 몸체는 함수 호출에 의해 실행된다.</p>
<p>리터럴은 값을 생성하기 위한 표기법. 함수 리터럴도 평가되어 값을 생성하고 이 값은 객체다. 함수는 객체다.</p>
<blockquote>
<p>함수는 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다?</p>
</blockquote>
<h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><p>함수를 호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 반환될 값을 지정하는 것을 함수 정의라고 한다. 정의 된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.<br>함수 정의 -&gt; 함수 객체</p>
<ul>
<li>함수 선언문(function declaration)</li>
<li>함수 표현식(function expression)</li>
<li>Function 생성자 함수(function constructor)</li>
<li>화살표 함수(arrow funtion) ES6</li>
</ul>
<p>선언 vs 정의<br>선언(declaration)과 정의(definition)를 간단히 구분하려면 ‘메모리 주소에 할당하는가?’로 구분할 수 있다. C언어에서 컴파일러를 통해 식별자의 존재만 알리는 거라면 선언한다고 하고, 컴파일러가 변수를 생성해 식별자와 메모리 주소가 연결되면 정의로 구분한다. 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 이 경계가 모호하다.</p>
<p>함수 리터럴과 함수 선언문의 차이<br>함수 리터럴과 함수 선언문 동작 방식</p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>자바스크립트의 함수는 값처럼 변수에 할당할 수 도 있고, 프로퍼티 값이 될 수 도 있다.</p>
<blockquote>
<p>함수가 배열의 요소도 될 수 있다?</p>
</blockquote>
<p>이처럼 값의 성질을 갖는 객체를 일급 객체(first-cass object)라 한다. 자바스크립트의 함수는 일급 객체다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.</p>
<p>함수 선언문과 함수 표현식이 생성되는 시점이 다르다.(호이스팅)</p>
<p>함수 호이스팅과 변수 호이스팅의 미묘한 차이</p>
<p>함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅 발생</p>
<p>함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기 때문에 함수 선언문 대신에 함수 표현식을 사용할 것을 권장한다.</p>
<h3 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h3><blockquote>
<p>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다?<br>함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만, 그렇지 않은 겨우에도 에러가 발생하지 않는다. 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 <code>undefined</code>다.</p>
</blockquote>
<p>파이썬에서는 매개변수와 인수의 개수가 다르면 에러가 발생하는데… 파이썬의 <code>Asterisk(*)</code>와 비슷한 건가?</p>
<blockquote>
<p>자바스크립트에서 초과된 인수는 암묵적으로 argumnets 객체의 프로퍼티로 보관된다?</p>
</blockquote>
<p>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다<br>자바스크립트는 동적 타입 언어다. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</p>
<p>함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수 없고 에러는 런타임에 발생하게 되므로, 타입스크립트와 같은 정적 타입을 선언할 수 있는 자바스크립트의 상위 확장을 도입해서 캄파일 시점에 부적절한 호출을 방지하는 것도 하나의 방법이다.</p>
<p>인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.</p>
<h3 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h3><p>매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받기 때문에 유지보수성이 나빠진다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.(이상적인 매개변수 개수는 0개이며 적을 수록 좋다)</p>
<h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p>함수 호출은 표현식이다. 함수 호출 표현식은 <code>return</code> 키워드가 반환한 표현식의 평가 결과, 즉 반환값으로 평가된다.</p>
<p>반환문의 두 가지 역할</p>
<ul>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>반환뮨은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li>
</ul>
<p>return 키워드와 반환값으로 사용할 표현식 사이에 줄바꿈이 있다면 세미콜론 자동 삽입 기능(ASI)에 의해서 세미콜론이 쿠가되어 의도치 않은 결과가 발생할 수 있다.</p>
<h3 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a>참조에 의한 전달과 외부 상태의 변경</h3><p>매개변수에 값을 전달하는 방식으로 원시값은 값의 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다. 원시 타입의 인수를 전달 받은 매개변수는 변경 불가능한(immutable) 값이기 때문에, 재할당을 통해 새로운 원시값으로 교체하고, 객체 타입의 인수를 전달 받은 매개변수는 변경 가능한(mutable) 값이므로 참조를 통해 원본에 직접 접근해 변경 추가 가능하다.</p>
<p>이와 같이 객체 타입 인수는 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원복 객체가 변경되는 부수 효과(side effect)가 발생한다. 이렇게 되면 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 함수 내부의 동작을 유심히 관찰하지 않으면 외부 상태가 변하는지 아닌지 알기 어렵기 때문이다. 이런 문제를 해결하는 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.</p>
<p>외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라고 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.</p>
<h3 id="즉시-실행-함수"><a href="#즉시-실행-함수" class="headerlink" title="즉시 실행 함수"></a>즉시 실행 함수</h3><p>즉시 실행 함수는 함수 정의와 동시에 즉시 호출되는 함수를 말한다. 즉시 실행 함수는 단 한 번만 호출되고 다시 호출할 수 없다. 즉시 실행 함수는 반드시 그룹 연산자<code>(...)</code>로 감싸야 한다. 자바스크립트 엔진이 암묵적으로 수행하는 ASI에 의해 함수 선언문이 끝나는 위치, 즉 함수 코드 블록의 닫는 중괄호 뒤에 <code>;</code>세미콜론이 암묵적으로 추가되기 때문이다. 그룹 연산자의 피연산자는 값으로 평가되므로 기명, 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h3 id="재귀-함수"><a href="#재귀-함수" class="headerlink" title="재귀 함수"></a>재귀 함수</h3><p>함수가 자기 자신을 호출하는 것을 재귀 호출(recursive call)이라 한다. 재귀 함수(recursive function)는 재귀 호출을 수행하는 함수를 말한다.</p>
<p>재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있고, 이로 인해 스택 오버플로 에러를 발생시킬 수 있으므로 반복문을 사용하는 것 보다 재귀 함수를 사용한는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.</p>
<h3 id="콜백-함수"><a href="#콜백-함수" class="headerlink" title="콜백 함수"></a>콜백 함수</h3><p>콜백 함수와 고차 함수…</p>
<h3 id="순수-함수와-비순수-함수"><a href="#순수-함수와-비순수-함수" class="headerlink" title="순수 함수와 비순수 함수"></a>순수 함수와 비순수 함수</h3><p>어떤 외부 상태에 의존, 변경하지 않는, 즉 부수 효과가 없는 함수를 순수 함수(pure function)라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수를 비순수 함수(impure function)라 한다.</p>
<blockquote>
<p>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다? 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환값을 만든다. 함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다.</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/13/20210313-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/13/20210313-TIL/" class="post-title-link" itemprop="url">20210313 TIL - 제어문 문제풀이</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-13 22:28:59" itemprop="dateCreated datePublished" datetime="2021-03-13T22:28:59+09:00">2021-03-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 13:33:53" itemprop="dateModified" datetime="2021-03-14T13:33:53+09:00">2021-03-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/13/20210313-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/13/20210313-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JS-제어문-연습문제"><a href="#JS-제어문-연습문제" class="headerlink" title="JS 제어문 연습문제"></a>JS 제어문 연습문제</h1><p>exercise 1 ~ 10 풀이</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</span></span><br><span class="line"><span class="comment">// 변수 하나에 짝수를 계속 더해주는데, 문자열로 바꿔서 더한다.</span></span><br><span class="line"><span class="keyword">var</span> even_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        even_str = even_str + (i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(even_str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">    i--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    sumOfNum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        sumOfNum += i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span> || i % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        sumOfNum += i</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + j === <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`[ <span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span> ]`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/12/20210312-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/12/20210312-TIL/" class="post-title-link" itemprop="url">20210312 TIL - JS 3회차</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-12 15:45:45" itemprop="dateCreated datePublished" datetime="2021-03-12T15:45:45+09:00">2021-03-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-14 20:02:11" itemprop="dateModified" datetime="2021-03-14T20:02:11+09:00">2021-03-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/12/20210312-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/12/20210312-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="8-제어문"><a href="#8-제어문" class="headerlink" title="8. 제어문"></a>8. 제어문</h1><h3 id="블록문-block-statement-compound-statement"><a href="#블록문-block-statement-compound-statement" class="headerlink" title="블록문(block statement/compound statement)"></a>블록문(block statement/compound statement)</h3><p>0 개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부른다. 블록문은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.</p>
<h3 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h3><p>if..else문</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if문</span></span><br><span class="line"><span class="keyword">if</span> (조건식) &#123;코드블록&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if..else문</span></span><br><span class="line"><span class="keyword">if</span> (조건식) &#123;</span><br><span class="line">  <span class="comment">// 조건식이 참이면 코드블록 실행</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식이 거짓이면 이 코드블록 실행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>조건식 - <code>true</code>,<code>false</code>로 평가되는 표현식<br>만약 조건식이 불린 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 불린 값으로 암묵적 타입변환이 일어난다.</p>
<p>들여쓰기는 2칸이 일반적이다.(callback hell)</p>
<h3 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h3><p>for문</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (변수 선언문 또는 할당문; 조건식; 증감식) &#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for문 실행 순서</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">1. i 선언 후 0값 할당</span></span><br><span class="line"><span class="string">2. 조건식 비교(true)</span></span><br><span class="line"><span class="string">3. true값이기 때문에 코드블록 실행</span></span><br><span class="line"><span class="string">4. 증감식에 의해 i값 +1(i=1)</span></span><br><span class="line"><span class="string">5. 조건식 비교(true)</span></span><br><span class="line"><span class="string">6. true값이기 때문에 코드블록 실행</span></span><br><span class="line"><span class="string">7. 증감식에 의해 i값 +1(i=2)</span></span><br><span class="line"><span class="string">8. 조건식 비교(false)</span></span><br><span class="line"><span class="string">9. false이므로 for 문의 실행 종료</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>while문</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건식) &#123;</span><br><span class="line">  조건식이 참이면 반복 실행될 문;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// count가 3이면 코드 블록 탈출</span></span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure>
<p>break - 코드블록 탈출<br>많은 횟수를 반복하게 되면 stackoverflow 에러가 발생한다고 한다.</p>
<p>for문은 몇 번 반복해야 되는지 알 때, while문은 몇 번 반복해야 되는지 모를 때 사용한다.</p>
<h1 id="9-타입-변환과-단축-평가"><a href="#9-타입-변환과-단축-평가" class="headerlink" title="9. 타입 변환과 단축 평가"></a>9. 타입 변환과 단축 평가</h1><h3 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h3><p>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit coercion)이라 하고 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것을 암묵적 타입 변환(implicit coercion)이라고 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 명시적 타입 변환</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = y + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br></pre></td></tr></table></figure>
<p>숫자 타입은 연산 목적, 문자 타입은 표시 목적, 타입마다 사용하려고 하는 의미가 다르다.</p>
<p>문자열 연결 연산자에서 암묵적 타입 변환이 일어났더라도 변수에 부수 효과(side effect)가 생기지 않는다. (한 번 쓰고 버린다)</p>
<p>자바스크립트 엔진은 불린 타입이 아닌 값을 Truthy 값(참) 또는 Falsy 값(거짓)으로 구분한다.<br>Falsy 값으로는</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>‘’(빈 문자열)<br>나머지는 Truthy 값이다.</li>
</ul>
<p><code>null</code>과 <code>undefined</code>는 둘 다 Falsy 값이지만, <code>null</code>은 숫자로 타입 변환하면 0이지만, <code>undefined</code>는 <code>NaN</code>이다.</p>
<p>암묵적 타입 변환을 보면 사용하지 않을 것 같지만, 실제로 암묵적 타입 변환을 이용해서 명시적 타입으로 변환하는 경우가 많다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자</span></span><br><span class="line">+<span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불린</span></span><br><span class="line">!<span class="string">&#x27;0&#x27;</span> / !!<span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h3><p>논리 연산자를 사용한 단축 평가로 논리합(<code>||</code>)연산자와 논리곱(<code>&amp;&amp;</code>)연산자가 사용된다. 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.</p>
<p>논리곱(<code>&amp;&amp;</code>)연산자는 두 개의 피연산자 모두 true로 평가 될 때 true를 반환한다. 먼저 오는 피연산자가 true로 평가된다면, 뒤에 오는 피연산자에 의해 결정이 되기 때문에 뒤에 오는 피연산자가 반환된다.<br>논리합(<code>||</code>)연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환하기 때문에, 먼저오는 피연산자가 true로 평가되면, 먼저 오는 피연산자가 반환되고, 먼저 오는 피연산자가 false, 뒤에 오는 피연산자가 true라면 뒤에 오는 피연산자가 반환된다.</p>
<p>이처럼 논리곱(<code>&amp;&amp;</code>)연산자와 논리합(<code>||</code>)연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 피연산자의 값 그대로 반환한다. 이를 단축 평가(short-circuit evaluation)라 한다.<br>단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||)</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Cat</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Dog</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="literal">false</span>  <span class="comment">// Cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;)</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Dog</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>단축 평가를 사용하면 if문을 대체할 수 있다. 어떤 조건이 Truthy값일 때 무언가를 해야 한다면 논리곱(<code>&amp;&amp;</code>)연산자 표현식으로, 조건이 Falsy값일 때 무언가를 해야 한다면 논리합(<code>||</code>)연산자 표현식으로 if문을 대체할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 조건이 true일 때</span></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">// done이 true라면 message에 &#x27;완료&#x27;를 할당</span></span><br><span class="line">message = done &amp;&amp; <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 조건이 false일 때</span></span><br><span class="line"><span class="keyword">if</span> (!done) message = <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">// done이 false라면 message에 &#x27;미완료&#x27;를 할당</span></span><br><span class="line">message = done || <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 미완료</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문</span></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>      message = <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문은 삼항 조건 연산자로 대체 가능하다.</span></span><br><span class="line">message = done ? <span class="string">&#x27;완료&#x27;</span> : <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br></pre></td></tr></table></figure>
<h1 id="10-객체-리터럴"><a href="#10-객체-리터럴" class="headerlink" title="10. 객체 리터럴"></a>10. 객체 리터럴</h1><p>다른 언어들이 클래스 기반의 객체 지향 언어라면, 자바스크립트는 프로토 타입 기반의 객체 지향 언어다.<br>인스턴스 - class로 뽑아낸 메모리 상에 존재하는 실체</p>
<p>JS의 장점 - 문자열, 객체 리터럴(class기반 언어보다 훨씬 낫다. 왜?)</p>
<p>리터럴 - 값을 만들어 내는 표기법</p>
<p>객체 리터럴({}) - 클래스가 없는 객체, 코드블럭과 햇갈리면 안된다.</p>
<p>우리가 관심이 있는 것을 추상화 해서 나열한 것을 객체라고 한다.<br>비슷한 것들을 묶어 하나로 표현한게 객체다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&#x27;Kim&#x27;</span>; <span class="comment">// 프로퍼티 값의 갱신</span></span><br><span class="line">person.location <span class="comment">// undefined</span></span><br><span class="line">person.location = <span class="string">&#x27;INCHEON&#x27;</span> <span class="comment">// 프로퍼티의 동적 추가</span></span><br><span class="line"></span><br><span class="line">consoel.log(person.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p><code>.</code> - 프로퍼티 접근 연산자(마침표 표기법)<br>자바스크립트는 인스턴스가 만들어진 이후에도 프로퍼티를 갱신하고 추가할 수 있다.(프로퍼티 동적 추가)<br>자바스크립트 객체의 프로퍼티 값은 값으로 평가될 수 있는 모든 것이 올 수 있다. 함수도 값으로 평가되기 때문에 올 수 있다.</p>
<p><code>delete</code>명령으로 프로퍼티를 삭제할 수 있지만, 굳이 지울 필요는 없는 것 같다.(Anti-pattern)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello! <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 이후 부터 </span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello! <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>this.name</code> - 자신의 프로퍼티에 접근하려면 <code>this</code>로 표현</p>
<p>프로퍼티 키는 문법적으로 식별자는 아니지만, 식별자의 의미를 갖고 있다. 식별자 명령 규칙에 맞는 프로퍼티 키라면 따옴표 생략이 가능하다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;JH&#x27;</span>, <span class="comment">// 식별자 명령 규칙을 따랐기 때문에 따옴표 생략 가능</span></span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Kim&#x27;</span> <span class="comment">// 식별자 명령 규칙에 위배되기 때문에 따옴표로 감싸서 문자열로 만들어줌</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName) <span class="comment">// JH</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;firstName&#x27;</span>]) <span class="comment">// JH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;last-name&#x27;</span>]) <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>
<p>불편한 대괄호 표기법 사용보다 네이밍 규칙을 지켜서 마침표 표기법을 사용하는게 편하다.<br>예외 경우가 있는데, 숫자가 프로퍼티 키로 온다면 유사 배열 객체로 사용 가능</p>
<p>메소드 - 프로퍼티 값이 함수로 표현된 프로퍼티를 메소드라고 부른다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>; <span class="comment">// Anti-pattern</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y; y</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="11-원시값과-객체의-비교"><a href="#11-원시값과-객체의-비교" class="headerlink" title="11. 원시값과 객체의 비교"></a>11. 원시값과 객체의 비교</h1><p>자바스크립트에서 제공하는 7가지 데이터 타입은 크게 원시 타입(primitive type)과 객체(object / reference type)타입 으로 구분할 수 있다.</p>
<h3 id="원시값"><a href="#원시값" class="headerlink" title="원시값"></a>원시값</h3><p>원시 타입 - 변경 불가능한 값(immutable value), 한번 생성된 원시값은 읽기 전용값으로 변경할 수 없다.<br>원시 값을 변경할 수 없는 것이지, 변수 값을 변경할 수 없는 건 아니다. 변수는 언제든지 재할당을 통해 교체할 수 있다.</p>
<p>문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 접근할 수 있다.<br>유사 배열 객체(array-like object) - 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.</p>
<p>값에 의한 전달(Pass by vlaue)<br>원시값을 갖는 변수를 다른 변수에 할당 했을 때, 같은 주소를 가리키는게 아닌 새로운 주소로 원시값이 할당되고 그 주소를 가리키기 때문에, 두 개의 변수의 값은 서로 영향을 끼치지 않는다.</p>
<p>정확히 표현하면 값에 의한 전달은 값을 전달하는게 아닌 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.</p>
<h3 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h3><p>변수에 객체를 할당하게 되면 객체가 값으로 할당되는게 아닌, 객체를 값으로 갖고 있는 메모리 주소를 변수의 값으로 갖게 되고, 그 메모리 주소를 참조해서 접근할 수 있다.</p>
<p>객체의 메모리 주소값이 변수의 값이고, 그 값은 원시값이기 때문에, 해당 변수를 다른 변수에 할당 한다면, 객체가 아닌 객체의 메모리 주소가 복사되어서 결국 두 개의 변수가 하나의 객체를 참조하게 되고, 하나의 객체에 변경이 생기면 양쪽의 변수에 영향을 끼치게 된다.</p>
<p>값을 할당했을 때 메모리 주소가 바뀌냐 안 바뀌냐에 따라 immutable vlaue, mutable value로 나뉘게 된다.</p>
<p>객체는 메모리 뒷 공간에 여유를 갖고 있는 힙에 저장이 되고, 스택은 확정된 메모리 공간으로 공간 없이 쌓이기 때문에 원시값 같은 값들이 들어갈 수 있다.</p>
<blockquote>
<p>만약 100개의 변수가 하나의 객체를 참조한다면, 어느 변수가 객체의 변경을 만들어 냈는지 확인하기 힘들텐데, 이런 부작용을 생각을 못했던 걸까? 도대체 왜 객체를 이렇게 만들었을까?</p>
</blockquote>
<p>우선 객체는 메모리 크기가 정해져 있지 않아서 사이즈 값이 클 때, 원시값으로 복사된다면 메모리가 감당하기 힘들고 원시값이 하는 일의 수십배 가까운 힘이 들기 때문에 하나의 값을 참조해서 효율을 높혔다.</p>
<p>객체를 원시값으로 만들면 좋았지만 옛날에는 메모리가 KB단위였고, 메모리도 비쌌기 때문에 눈물을 머금고 독특한 동작으로 만들었을 뿐이라고 한다. 현대에 와서는 메모리가 GB단위로 메모리에 큰 부담이 없어서 객체를 원시값으로 바꾸려는 움직임도 있다고 한다.(메모리보단 퍼포먼스)</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kim Ju Hyeong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://juhyeong-k.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
