<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"juhyeong-k.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta name="description" content="17. 생성자 함수에 의한 객체 생성생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp">
<meta property="og:type" content="article">
<meta property="og:title" content="20210316 TIL JS 예습">
<meta property="og:url" content="https://juhyeong-k.github.io/2021/03/16/20210316-TIL/index.html">
<meta property="og:site_name" content="JH&#39;s dev blog">
<meta property="og:description" content="17. 생성자 함수에 의한 객체 생성생성자 함수(constructor)란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-16T01:27:10.000Z">
<meta property="article:modified_time" content="2021-03-18T03:56:43.353Z">
<meta property="article:author" content="Kim Ju Hyeong">
<meta property="article:tag" content="TIL">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://juhyeong-k.github.io/2021/03/16/20210316-TIL/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>
<title>20210316 TIL JS 예습 | JH's dev blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-93XKT8K1JW"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-93XKT8K1JW');
      }
    </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="JH's dev blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JH's dev blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">All about dev</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1"><span class="nav-number">1.</span> <span class="nav-text">17. 생성자 함수에 의한 객체 생성</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-ES6-%ED%95%A8%EC%88%98%EC%9D%98-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5"><span class="nav-number">2.</span> <span class="nav-text">25. ES6 함수의 추가 기능</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98"><span class="nav-number">2.0.1.</span> <span class="nav-text">화살표 함수</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%EB%B0%B0%EC%97%B4"><span class="nav-number">3.</span> <span class="nav-text">26. 배열</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%B0%EC%97%B4%EC%9D%80-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4"><span class="nav-number">3.0.1.</span> <span class="nav-text">자바스크립트 배열은 배열이 아니다</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EB%B0%B0%EC%97%B4-%EC%83%9D%EC%84%B1"><span class="nav-number">3.0.2.</span> <span class="nav-text">배열 생성</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EB%B0%B0%EC%97%B4-%EB%A9%94%EC%86%8C%EB%93%9C"><span class="nav-number">3.0.3.</span> <span class="nav-text">배열 메소드</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Kim Ju Hyeong</p>
  <div class="site-description" itemprop="description">All about dev</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyeong-k.github.io/2021/03/16/20210316-TIL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Kim Ju Hyeong">
      <meta itemprop="description" content="All about dev">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JH's dev blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          20210316 TIL JS 예습
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-16 10:27:10" itemprop="dateCreated datePublished" datetime="2021-03-16T10:27:10+09:00">2021-03-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-18 12:56:43" itemprop="dateModified" datetime="2021-03-18T12:56:43+09:00">2021-03-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TIL/" itemprop="url" rel="index"><span itemprop="name">TIL</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2021/03/16/20210316-TIL/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2021/03/16/20210316-TIL/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="17-생성자-함수에-의한-객체-생성"><a href="#17-생성자-함수에-의한-객체-생성" class="headerlink" title="17. 생성자 함수에 의한 객체 생성"></a>17. 생성자 함수에 의한 객체 생성</h1><p>생성자 함수(constructor)란 <code>new</code> 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.<br>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수를 제공한다.</p>
<p><code>new</code>연산자와 함께 호출하지 않으면 일반 함수로 호출된다.</p>
<blockquote>
<p>Object 생성자 함수를 사용해서 객체를 생성하는 것 보다 객체 리터럴을 이용하는게 더 직관적이고 편한 것 같은데 생성자 함수로 생성해야되는 이유가 있을까?</p>
</blockquote>
<p>공통된 프로퍼티를 여러 객체가 가져야 할 경우, 생성자 함수를 이용하면 간편하게 생성할 수 있다. 객체 리터럴은 직관적이고 편리하지만, 공통된 프로퍼티들을 갖는 여러 객체들에게 각각 프로퍼티를 입력해줘야 하는 단점이 있다.</p>
<p>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수고, 생성된 인스턴스를 초기화하는 것은 옵션이다.</p>
<p>생성자 함수의 인스턴스 생성 과정</p>
<ul>
<li>인스턴스 생성과 this 바인딩은 런타임 이전에 암묵적으로 자바스크립트 엔진에 의해 실행된다.</li>
<li>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 한 뒤(this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드 추가) 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스의 바인딩 된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환되기 때문에 생성자 함수의 기본 동작을 훼손하지 않으려면 생성자 함수 내부에서 return문을 반드시 생략해야 한다. 단, 원시값을 return 하면 무시되고 this가 암묵적으로 반환된다.</li>
</ul>
<p>객체에는 일반 객체와 함수 객체가 있는데, 둘을 구분할 수 있는 기준은 호출이 가능한지 아닌지로 할 수 있다. 즉 객체 내부 메소드 <code>[[call]]</code>을 가지고 있는 객체를 함수 객체라 할 수 있다. 함수 객체에서 일반함수와 생성자 함수를 구분하자면, constructor와 non-constructor로 구분할 수 있다. constructor는 내부 메서드 <code>[[construct]]</code>를 갖는 함수 객체로 생성자 함수로서 호출할 수 있는 함수를 말하고, non-constructor는 <code>[[construct]]</code>를 갖지 않는, 생성자 함수로서 호출할 수 없는 함수를 의미한다. </p>
<ul>
<li>constructor : 함수 선언문, 함수 표현식, 클래스</li>
<li>non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수</li>
</ul>
<p>프로퍼티 값으로 함수를 사용하면 일반적으로 메소드라 칭하는데, ECMAScript의 사양에서 메소드는 ES6의 메서드 축약 표현만 의미한다.</p>
<p>사실 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하는지 안하는지에 따라 달라지기 때문이다. 즉, new 연산자 없이 constructor를 호출하면 일반 함수로 호출되고, new 연산자와 함께 cosntructor를 호출하면 생성자 함수로 호출된다.<br>생성자 함수와 일반 함수를 구별하기 위해서 생성자 함수의 이름을 파스칼 케이스로 명명하지만, 실수는 언제나 발생할 수 있다. 이런 위험성을 회피하기 위해 ES6에서 <code>new.target</code>을 지원한다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었을 때 함수 자신을 가리키고, new 연산자 없이 일반 함수로 호출되었다면 undefined를 의미한다. 따라서 함수 내부에서 new 연산자와 함께 재귀 호출을 통해 생성자 함수로 호출할 수 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());</span><br></pre></td></tr></table></figure>
<h1 id="25-ES6-함수의-추가-기능"><a href="#25-ES6-함수의-추가-기능" class="headerlink" title="25. ES6 함수의 추가 기능"></a>25. ES6 함수의 추가 기능</h1><h3 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h3><p>화살표 함수(arrow function)는 function 키워드 대신 화살표(<code>=&gt;</code>,fat arrow)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의 할 수 있고, 내부 동작도 기존의 함수보다 간략하다. 특히 콜백 함수 내부에서 <code>this</code>전역 객체를 가리키는 문제를 해결하기 위한 대안으로 많이 사용된다.</p>
<p>화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 매개변수가 여러 개인 경우 소괄호 안에 매개변수 선언한다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 한 개인 경우 소괄호 생략 가능</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function"><span class="params">x</span> =&gt;</span> &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 매개변수가 없는 경우 소괄호 생략 불가능</span></span><br><span class="line">cosnt arrow = <span class="function">() =&gt;</span> &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>함수 몸체가 값으로 평가되는 표현식인 문이라면 중괄호(<code>&#123;&#125;</code>)를 생략할 수 있고 암묵적으로 반환되지만, 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> x ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">//동일한 표현</span></span><br><span class="line"><span class="keyword">const</span> power = <span class="function"><span class="params">x</span> =&gt;</span> &#123; <span class="keyword">return</span> x ** <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 표현식이 아닌 문은 반환할 수 없기 때문에 중괄호 생략 불가능하다.</span></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> <span class="keyword">const</span> x = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrow = <span class="function">() =&gt;</span> &#123; <span class="keyword">const</span> x = <span class="number">1</span>; &#125; <span class="comment">// 맞는 표현</span></span><br></pre></td></tr></table></figure>

<p>객체 리터럴을 반환할 때 소괄호(<code>()</code>)로 감싸야 한다. 그렇지 않으면 객체 리터럴의 중괄호(<code>&#123;&#125;</code>)를 함수 몸체를 감싸는 중괄호로 잘못 해석하기 때문에 쉼표를 함수 몸체 내의 쉼표 연산문으로 해석한다.</p>
<h1 id="26-배열"><a href="#26-배열" class="headerlink" title="26. 배열"></a>26. 배열</h1><p>배열(array)은 여러 개의 값을 순차적으로 나열한 자료 구조다. 배열이 가지고 있는 값을 요소(element)라고 부르고, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.</p>
<p>자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// -&gt; object</span></span><br></pre></td></tr></table></figure>
<p>배열은 객체지만 일반 객체와는 구별되는 특징이 있다. 구분하는 가장 명확한 차이는 “값의 순서”와 “length 프로퍼티”다.</p>
<h3 id="자바스크립트-배열은-배열이-아니다"><a href="#자바스크립트-배열은-배열이-아니다" class="headerlink" title="자바스크립트 배열은 배열이 아니다"></a>자바스크립트 배열은 배열이 아니다</h3><p>자료구조(data structure)에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(dense array)이라 한다.</p>
<blockquote>
<p>검색 대상의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수</p>
</blockquote>
<p>예를 들어 메모리 주소 1000에서 시작하고 각 요소의 크기가 8바이트인 배열을 생각해보면,</p>
<ul>
<li>인덱스가 0인 요소의 메모리 주소: 1000 + 0 * 8 = 1000</li>
<li>인덱스가 1인 요소의 메모리 주소: 1000 + 1 * 8 = 1008</li>
<li>인덱스가 2인 요소의 메모리 주소: 1000 + 2 * 8 = 1016</li>
</ul>
<p>이렇게 표현될 수 있다. 이처럼 배열은 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있고 시간 복잡도 <code>O(1)</code>라고 표현할 수 있다. 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형검색(linear search), 시간 복잡도 <code>O(n)</code>)해야 한다. 또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소들을 이동시켜야 하는 단점도 있다.</p>
<p>자바스크립트에서의 배열은 위에서 설명한 일반적인 의미의 배열과 다르다. 자바스크립트에서의 배열은 배열의 요소를 위한 각각의 메모리 공간을 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열(sparse array)이라 한다.<br><strong>자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.</strong></p>
<p>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, 배열의 요소를 프로퍼티 값으로 갖고, length 프로퍼티를 갖는 특수한 객체다.</p>
<p>정리하자면 일반적인 배열은 인덱스로 배열 요소에 접근이 빠른 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않지만, 자바스크립트 배열은 인덱스로 배열 요소에 접근이 느린 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p>
<p>자바스크립트 배열의 length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제할 때 자동으로 갱신된다.<br>length 프로퍼티의 값은 배열의 길이를 바탕으로 결정되지만, 임의의 숫자 값을 명시적으로 할당할 수도 있다. 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>반대로 현재 legth 프로퍼티 값보다 큰 숫자 값을 할당하면 length 프로퍼티의 값은 변경이 되지만 실제 배열의 길이가 늘어나지는 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 4, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;4 empty items&gt;</code>는 실제로 추가된 배열의 요소가 아니다. length 프로퍼티 값이 변경됐다고 해도 값 없이 비어 있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [,, <span class="number">3</span>,, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5 ]</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure>
<p>일반적인 배열의 length는 배열의 요소의 개수와 언제나 일치하지만, 희소 배열은 length와 배열의 요소 개수와 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.</p>
<p>자바스크립트는 문법적으로 희소 배열을 허용하지만 희소 배열은 사용하지 않는 것이 좋다. 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.</p>
<h3 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h3><p>객체와 마찬가지로 배열도 다양한 생성 방식이 있는데, 가장 일반적이고 간단한 배열 생성 방식은 배열 리터럴을 사용하는 것이다. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분해서 대괄호(<code>[ ]</code>)로 묶는다.</p>
<p>Object 생성자 함수를 통해 객체를 생성할 수 있듯이 Array 생성자 함수를 통해 배열을 생성할 수도 있다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">대부분의 빌트인 생성자 함수(Object, Function, Array, Date, RegExp, Promise 등)는 </span></span><br><span class="line"><span class="comment">new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. </span></span><br><span class="line"><span class="comment">생성자 함수 내부에서 new.target을 확인하기 때문이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>Array 생성자 함수에 전달되는 인수가 1개이고 숫자인 경우, length 프로퍼티 값이 인수인 배열을 생성한다. length 프로퍼티 값이 0은 아니지만 실제로 배열의 요소는 존재하지 않는 희소 배열이다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br></pre></td></tr></table></figure>
<p>전달된 인수가 없는 경우 length 프로퍼티 값이 0인 빈 배열을 생성한다. 즉 배열 리터럴(<code>[ ]</code>)과 같다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전달되는 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전달되는 인수가 1개지만, 숫자가 아닌 인수이기 때문에 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ &#123;&#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="string">&#x27;string&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p><code>Array.of</code>는 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr1));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: &#x27;a&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: &#x27;b&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: &#x27;c&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>ES6에서 도입된 <code>Array.from</code>메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달 받아서 배열로 변환 후, 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 길이에 맞게 undefined를 요소로 채운다.</span></span><br><span class="line"><span class="keyword">const</span> arr3 = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환 값으로 구성된 배열을 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 요소의 참조</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 인덱스가 2인 요소를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 존재하지 않는 요소에 접근하면 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열도 마찬가지</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>,,<span class="number">3</span>,,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr2));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;4&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 5, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="comment">//배열 요소 추가</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="string">&#x27;1&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">arr[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">arr.bar = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1.1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, foo: 3, bar: 4, &#x27;1.1&#x27;: 5, &#x27;-1&#x27;: 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티는 배열의 length에 영향을 주지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 2, writable: true, enumerable: false, configurable: false &#125;,</span></span><br><span class="line"><span class="comment">  foo: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  bar: &#123; value: 4, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1.1&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;-1&#x27;: &#123; value: 6, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>인덱스는 요소의 위치를 나타내기 때문에 반드시 0 이상의 정수(정수 형태 문자열)를 사용해야 한다. 정수 이외에 값을 인덱스처럼 사용한다면 요소가 생성되는게 아닌 프로퍼티가 추가된다. 추가된 프로퍼티는 요소가 아니기 때문에 배열의 length 프로퍼티에 영향을 미치지 않는다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, &lt;1 empty item&gt;, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>배열도 객체이기 때문에 <code>delete</code>연산자를 이용해서 요소를 삭제할 수 있다. 위의 경우 1번 인덱스의 값을 삭제하면서 희소 배열이 되고 length 프로퍼티의 값은 변하지 않는다. 희소 배열을 만드는 delete 연산자는 사용하지 않는게 좋다. 만약 희소 배열로 만들지 않고 배열의 특정 요소를 완전히 삭제하려면 <code>Array.prototype.splice</code>메소드를 사용한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.slplice(삭제를 시작 할 인덱스, 삭제할 요소 개수)</span></span><br><span class="line">arr1.splice(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1번 인덱스부터 2개 삭제</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열로 만들어지는 경우</span></span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, &lt;2 empty items&gt;, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본을 직접 변경하는 push 메소드</span></span><br><span class="line">arr1.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 배열을 생성하는 concat 메소드</span></span><br><span class="line"><span class="keyword">const</span> result = arr2.concat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>
<p>자바스크립트에서 배열 메소드는 결과물을 반환하는 패턴이 두 가지 있다. 원본 배열(배열 메소드를 호추한 배열, 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method)와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method)가 있다.<br>원본을 직접 변경하는 메소드는 외부 상태를 직접 변경하는 부수 효과(side effect)가 있으므로 가급적 원본 배열을 직접 변경하지 않는 메소드를 사용하는 편이 좋다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.push</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line">arr1.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr1 performance test: 0.134ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [arr.length] </span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line">arr2[arr2.length] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr2 performance test: 0.01ms</span></span><br></pre></td></tr></table></figure>
<p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.<br>마지막 요소로 추가할 요소가 하나뿐이라면 push 메소드보다 length 프로퍼티를 사용해서 배열의 마지막에 요소를 직접 추가하는게 더 빠르다.(push 메소드는 성능 면에서 좋지 않다.)</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/TIL/" rel="tag"># TIL</a>
              <a href="/tags/JS/" rel="tag"># JS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/15/20210315-TIL/" rel="prev" title="20210315 TIL JS 4회차">
                  <i class="fa fa-chevron-left"></i> 20210315 TIL JS 4회차
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/17/20210317-TIL/" rel="next" title="20210317 TIL JS 5회차">
                  20210317 TIL JS 5회차 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kim Ju Hyeong</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://juhyeong-k.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://juhyeong-k.github.io/2021/03/16/20210316-TIL/";
    this.page.identifier = "2021/03/16/20210316-TIL/";
    this.page.title = "20210316 TIL JS 예습";
    };
  NexT.utils.loadComments('#disqus_thread', () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://juhyeong-k.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
