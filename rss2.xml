<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JH&#39;s dev blog</title>
    <link>https://juhyeong-k.github.io/</link>
    
    <atom:link href="https://juhyeong-k.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>All about dev</description>
    <pubDate>Mon, 08 Mar 2021 11:01:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[BAEKJOON] 유기농 배추 1012번</title>
      <link>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</guid>
      <pubDate>Mon, 08 Mar 2021 10:51:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.</p><p>(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)</p><p>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.</p><p>예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.</p><p>(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)</p><p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.</p><p>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>처음에 든 생각은 2차원 배열에서 인접해 있는 요소를 어떻게 표현해야될 지 고민이 많았다.<br>알고리즘에 대해서 공부하고 푸는 문제가 아니기 때문에 여러 고민을 해봤다.<br>입력 값으로 받는 배열의 크기 없이, 배추의 갯수만으로 좌표를 받아서 찾아도 문제를 해결할 수 있을 것 같아 설계를 해봤다. 고민을 하다보니 인접해 있는 배추를 찾을 때, 그 인접한 배추도 다시 인접한 배추를 찾아야 된다고 생각해서 재귀함수를 사용하는 방법으로 고민을 해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_cabbage</span>(<span class="params">cabbage_location, cabbage_group, index_tuple</span>):</span></span><br><span class="line">    x, y = index_tuple</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &lt; <span class="number">9</span> <span class="keyword">and</span> (x+<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x+<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x+<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x-<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> (x-<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x-<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x-<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x, y+<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &lt; <span class="number">9</span> <span class="keyword">and</span> (x, y+<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y+<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y+<span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">if</span> (x, y-<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &gt; <span class="number">0</span> <span class="keyword">and</span> (x, y-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y-<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y-<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 탈출 조건...?</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    cabbage_num = <span class="built_in">input</span>().split()[<span class="number">2</span>]</span><br><span class="line">    cabbage_location = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(cabbage_num)):</span><br><span class="line">        x, y = <span class="built_in">input</span>().split()</span><br><span class="line">        cabbage_location.append((x, y))</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(cabbage_location) &gt; <span class="number">0</span>:</span><br><span class="line">        cabbage_group = []</span><br><span class="line">        cabbage_group.append(cabbage_location.pop())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            search_cabbage(cabbage_location, cabbage_group, cabbage_group[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>재귀 함수 탈출 조건을 구현하지 못해서 일단 여기까지 작성해보고 다음에 알고리즘 공부 후 다시 풀어봐야겠다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210308 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/</guid>
      <pubDate>Mon, 08 Mar 2021 01:16:44 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;[BAEKJOON]유기농 양배추 1012번 문제 풀이&lt;/del&gt;&lt;/li&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>[BAEKJOON]유기농 양배추 1012번 문제 풀이</del></li><li><del>JS 강의 내용 정리</del></li></ul><h1 id="JS-수업-내용-정리"><a href="#JS-수업-내용-정리" class="headerlink" title="JS 수업 내용 정리"></a>JS 수업 내용 정리</h1><p>수업 중에 나오는 개발 용어를 잘 정리하자</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">20</span></span><br></pre></td></tr></table></figure><p>우리는 <code>10 + 20</code>의 결과를 30이라고 바로 생각해내서 과정이 없는 것 처럼 느껴지지만, 사실 <code>10</code>이라는 문자가 무엇인지, <code>+</code>와 ‘20’이 무엇인지 알고 계산하는 과정을 거쳐야 한다.<br>비슷하게 컴퓨터는 <code>10</code>이라는 문자를 보고 <code>passing</code>을 통해 숫자 <code>10</code>이라는 것을 인지한다. 정확히 말하면 자바스크립트 엔진이 <code>10 + 20</code>을 보고 <code>+</code>연산을 하기 전에 <code>10</code>과 <code>20</code>을 기억하고, <code>+</code>연산을 하게 된다.</p><ul><li>메모리<br>메모리는 데이터를 저장할 수 있는 메모리 셀(cell)의 집합체다. 메모리 셀 하나의 크기는 1Byte(8bit)이고, 컴퓨터는 메모리 셀 하나의 크기로 데이터를 저장(write)하거나 읽는다.(read)<br>각 셀은 메모리 공간의 위치를 나타내는 메모리 주소(memory address)를 갖는다. 4GB기준 약 0~43억개의 메모리 주소를 갖는다.</li></ul><p>컴퓨터에서 기억은 메모리가 담당하고, 연산은 CPU가 담당한다.</p><blockquote><p>왜 메모리 셀의 단위는 1bit, 5bit, 10bit 등 계산하기 쉬운 단위가 아닌 8bit라고 할까?<br>아스키코드, 유니코드 관련</p></blockquote><p><code>10 + 20</code>의 과정을 살펴보면,<br><code>10</code>을 2진수로 바꿔서 메모리 셀에 저장하는데, OS가 그 역할을 한다. JS엔진이 OS에게 메모리에 저장해달라고 요청을 하면 OS가 빈 위치에 2진수로 변환된 <code>10</code>을 저장한다.<br><code>20</code>도 마찬가지로 2진수로 바꿔서 메모리 셀에 저장된다.<br><code>+</code>연산은 CPU가 담당하는데, 메모리에 저장된 <code>10</code>과<code>20</code>을 CPU에 있는 고속메모리에 잠깐 저장하고, <code>+</code>연산을 해서 나온 결과값을 다시 메모리 셀에 저장하고 고속메모리에 저장된 <code>10</code>과 <code>20</code>은 버려진다.</p><p>여기서 메모리 셀에 <code>30</code>이라는 결과가 저장되었지만, 메모리 주소를 알 수 없기 때문에 재사용할 수 없다.</p><p>만약 메모리 주소를 알고 직접 접근하는 것은 매우 위험하다. 만약 운영체제가 사용하고 있는 값을 변경하게 되면 시스템을 멈추게 하는 치명적인 오류가 발생하고 있기 때문에 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.</p><ul><li>변수<br>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여서 재사용하기 위해 변수라는 메커니즘을 제공한다.</li></ul><p>변수의 정의로는</p><ol><li>하나의 값을 저장하기 위해 확보한 메모리 공간</li><li>메모리 공간을 식별하기 위해 붙인 이름<br><code>a = 1</code>을 예시로 보면 <code>1</code>은 하나의 값을 저장하기 위해 메모리에 확보된 값이고, <code>a</code>는 그 공간을 식별하기 위해 붙인 이름이다. 둘 사이의 <code>=</code>가 있기 때문에 두 개의 정의가 나올 수 있다.<br>변수는 하나의 값을 저장하는데, 여러 개의 값을 저장하고 싶다면 객체 같은 자료구조를 사용하면 하나의 그룹으로 저장할 수 있다.</li></ol><p>변수에 값을 저장하는 것을 할당(assignment)한다 하고, 변수에 저장된 값을 일어 들이는 것을 참조(reference)라고 한다.</p><ul><li>식별자<br>변수 이름을 식별자(identifier)라고도 한다. 식별자는 어던 값을 구분해서 식별할 수 있는 고유한 이름을 말하고, 변수 이름 뿐만 아니라 메모리에 중복 없이 접근이 가능한 것들도 식별자라 한다. (함수, 클래스 등)</li></ul><p>식별자는 값이 아니라 메모리 주소를 기억하고 있다. 식별자가 기억하고 있는 메모리 주소를 통해서 메모리 공간에 저장된 값에 접근할 수 있다.</p><ul><li>변수 선언<br>저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>변수를 선언할 때 <code>var</code>,<code>const</code>,<code>let</code> keyword를 사용한다.<br>keyword - 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">10</span> + <span class="number">20</span></span><br><span class="line"><span class="comment">// var -&gt; keyword, result -&gt; 식별자, &#x27;=&#x27; -&gt; 할당 연산자</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score;</span><br></pre></td></tr></table></figure>변수를 선언 후 값을 할당하지 않았기 때문에 확보된 메모리 공간은 비어있을 것으로 추측되지만, <strong>확보된 메모리 공간에는 <code>undefined</code>라는 암묵적인 값이 할당 되어 초기화된다.</strong></li></ul><p>메모리 공간은 지운다라는 개념이 없고 덮어씌운다라는 개념이 존재하기 때문에, C언어에서는 변수를 선언 하면서 값을 초기화 해주지 않으면, 그 변수는 예상치 못한 값이 나올 수도 있다.</p><blockquote><p>숫자형은 메모리 공간에 8Byte를 차지하는데, undefined는 얼마를 차지할까?<br>모른다. ES에도 정의가 되어 있지 않다. 결국 브라우저 마다 알아서 정의를 하기 때문에 알 수가 없다.</p></blockquote><ul><li>호이스팅<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> score;</span><br></pre></td></tr></table></figure>위의 실행 결과로 <code>NameError</code>를 예상할 수 있지만, 결과값으로 <code>undefined</code>가 나오는 것을 확인할 수 있다.<br>자바스크립트는 인터프리터 언어라서 위에서 한 줄씩 읽어나갈텐데, 왜 <code>score</code>변수가 먼저 선언된 것 처럼 보일까?<br>그 이유는 그렇게 만들었기 때문이다. 다시 말하지만 자바스크립트는 애초에 비개발자를 위한 언어로 만들어져서 변수 선언을 뒤에 할 경우 에러가 발생하는 것을 막기 위해<br><strong>자바스크립트의 선언문은 runtime 이전에 먼저 실행된다.</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;score&quot;</span>);</span><br></pre></td></tr></table></figure>위의 결과로는<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">100</span><br></pre></td></tr></table></figure>어떻게 이런 값이 나왔을까? <code>var score = 100;</code>은 <code>shortcut</code>이다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 위와 아래는 동일한 명령</span></span><br><span class="line"><span class="keyword">var</span> score;</span><br><span class="line">score = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>선언문인 <code>var score</code>가 runtime전에 실행되면서 위의 <code>console.log(&quot;score&quot;)</code>결과로 <code>undefined</code>가 출력되고, 그 다음 순서인 <code>score = 100;</code>이 실행되면서 아래의 <code>console.log(&quot;score&quot;)</code>의 값으로 <code>100</code>이 출력되는 것이다.</li></ul><p>자바스크립트는 어디서 만들어졌나? 각 브라우저별로 알아서 개발함. 그래서 자바스크립트의 실행 환경은 브라우저마다 다 다르다. 다만, ECMA Script 표준을 지키고 있다.<br>ES는 버전이 ES1<del>3, 5</del>11까지 있고, 6부터 모던 자바스크립트라고 부를 정도로 5와 6사이에 많은 변화가 있었다.<br>ES5에서 변수 선언은 <code>var</code>만 가능했지만, 6에서 <code>let</code>, <code>const</code> 추가 도입됨.<br>보통 파이썬 2버전과 3버전에서 지원하는 것과 안하는 것이 있는 것 처럼 Breakpoint가 있는데, 자바스크립트는 그런 것 없이 하위호환성을 유지하기 때문에 <code>var</code> 변수 선언도 지금까지 유지되고 있다.(자바스크립트의 과거 문법도 공부해야 한다)</p><p>자바스크립트는 애초에 개발자가 아닌 비개발자가 사용할 것이라는 전제 하에 만들어진 언어라서, 오류를 최대한 내지 않기 위해 실수를 해도 알아서 커버해주는 <strong>암묵적인 행동</strong>을 한다.(오류를 내지 않기 때문에 코드를 이해하기 어렵다) 그래서 자바스크립트에서 더욱이 기본 개념과 동작원리를 잘 알아야 한다.</p><p>ECMA Script - JS의 표준 명쇄. 줄여서 ES<br>breakpoint - 하위, 상위 호환성을 지원하지 않을 수도 있는 point<br>legasy - 기존에 있던 코드</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTML/CSS 강의에 대한 회고</title>
      <link>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/</link>
      <guid>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/</guid>
      <pubDate>Sun, 07 Mar 2021 10:42:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;2주 동안 들었던 HTML/CSS 강의 에 대한 회고를 작성해보려고 한다.&lt;/p&gt;
&lt;p&gt;사실 강의를 듣기 전까지, HTML과 CSS에 크게 관심이 없었다. HTML과 CSS를 온라인 강의로 잠깐 접해본 적이 있는데, 그 당시만 해도 이걸 배워서 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>2주 동안 들었던 HTML/CSS 강의 에 대한 회고를 작성해보려고 한다.</p><p>사실 강의를 듣기 전까지, HTML과 CSS에 크게 관심이 없었다. HTML과 CSS를 온라인 강의로 잠깐 접해본 적이 있는데, 그 당시만 해도 이걸 배워서 어떻게 써먹어야될지도 몰랐고 재미도 없어서 그냥 이론만 듣고 말았다. 그래서 이번 HTML/CSS 강의도 그런 내용이겠구나 생각하고 있었다. 첫 날, 둘 째날 강의를 계속 들으면서 HTML이 어떻게 만들어졌고 어떤 역사를 가지고 지금까지 발전을 했는지, HTML을 작성할 때 어떤 흐름으로 작성을 해야되는지 설명을 들으면서 강의 자체에 재미를 붙이게 됐다.</p><p>2주라는 기간 동안 배운 많은 내용들을 내가 전부 흡수하지 못해 아쉬움이 크지만, 이번 강의를 들으면서 내가 HTML을 작성할 때는 어떤 흐름으로 작성을 하고 어떤 부분을 고려해서 작성을 해야되는지 감을 잡는 계기가 됐고, CSS도 배우기 전까지는 정말 어렵다고 생각됐는데, 내가 보여지는 것만 보고 판단을 해서 어렵게 느껴졌었고, 내가 사용한 property들의 목적을 알고 있어야 문제가 생겨도 왜 문제가 생겼는지 원인을 판단할 수 있고, 특히, CSS에서는 본래의 목적으로 사용하는게 아닌, 다른 용도(<del>꼼수</del>)로 사용하는 경우도 많기 때문에 왜 이런 property를 사용하는지 정확하게 알고 있어야 한다는걸 알게 됐다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/Retrospective/">Retrospective</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      <category domain="https://juhyeong-k.github.io/tags/Retrospective/">Retrospective</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210307 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/</guid>
      <pubDate>Sun, 07 Mar 2021 04:39:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;[BAEKJOON] 국영수 10825번 글 내용 추가(sort, sorted)</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>[BAEKJOON] 국영수 10825번 글 내용 추가(sort, sorted)</del></li><li><del>20210304 TIL, 20210303 TIL 수업 내용 정리 추가</del></li><li><del>HTML, CSS 회고 작성</del></li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 국영수 10825번</title>
      <link>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/</guid>
      <pubDate>Fri, 05 Mar 2021 03:36:26 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로그램을 작성하시오.</p><p>국어 점수가 감소하는 순서로<br>국어 점수가 같으면 영어 점수가 증가하는 순서로<br>국어 점수와 영어 점수가 같으면 수학 점수가 감소하는 순서로<br>모든 점수가 같으면 이름이 사전 순으로 증가하는 순서로 (단, 아스키 코드에서 대문자는 소문자보다 작으므로 사전순으로 앞에 온다.)</p><p>첫째 줄에 도현이네 반의 학생의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 한 줄에 하나씩 각 학생의 이름, 국어, 영어, 수학 점수가 공백으로 구분해 주어진다. 점수는 1보다 크거나 같고, 100보다 작거나 같은 자연수이다. 이름은 알파벳 대소문자로 이루어진 문자열이고, 길이는 10자리를 넘지 않는다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>처음 든 생각은 <code>input()</code>으로 들어오는 값을 어떤 방식으로 저장할지 고민이었다.<br><code>dictionary</code>로 저장할 경우 순서를 구분하기 힘들 것 같고, <code>list</code>로 저장할 경우 <code>key:value</code>를 구분하기 힘들 것 같아서, 그냥 둘 다 써보기로 했다.</p><p>입력받은 이름과 국영수 점수들을 <code>dict</code>에 <code>&#123;name: [국, 영, 수]&#125;</code>형태로 저장하고, list에는<code>[[국, 영,수]]</code> 국영수 점수만 저장했다.</p><p>이제 어떻게 정렬할지 고민을 해봤는데, 쉽게 떠오르지는 않았다.<br><code>input()</code>을 입력 받을 때, <code>current_score</code>라는 이름의 <code>list</code>를 두고 위에 저장된 <code>list</code>의 값과 비교해보기로 했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">subject_score_dict = &#123;&#125;</span><br><span class="line">subject_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    name, korean_score, english_score, math_score = <span class="built_in">input</span>().split()</span><br><span class="line">    korean_score, english_score, math_score = <span class="built_in">int</span>(korean_score), <span class="built_in">int</span>(english_score), <span class="built_in">int</span>(math_score)</span><br><span class="line">    subject_score_dict[name] = [korean_score, english_score, math_score]</span><br><span class="line">    current_score = [korean_score, english_score, math_score]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subject_score_list) == <span class="number">0</span>:</span><br><span class="line">        subject_score_list.append(current_score)</span><br><span class="line">        print(<span class="string">&#x27;첫 번째 값&#x27;</span>,subject_score_list) <span class="comment">###</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> score_index, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(subject_score_list):</span><br><span class="line">            <span class="comment"># 국어 점수 비교</span></span><br><span class="line">            <span class="keyword">if</span> current_score[<span class="number">0</span>] &gt; score[<span class="number">0</span>]:</span><br><span class="line">                subject_score_list.insert(score_index, current_score)</span><br><span class="line">                print(<span class="string">&#x27;cs[0]&gt;s[0]&#x27;</span>,subject_score_list) <span class="comment">###</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] &lt; score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] == score[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 영어 점수 비교</span></span><br><span class="line">                <span class="keyword">if</span> current_score[<span class="number">1</span>] &lt; score[<span class="number">1</span>]:</span><br><span class="line">                    subject_score_list.insert(score_index, current_score)</span><br><span class="line">                    print(<span class="string">&#x27;cs[1]&lt;s[1]&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] &gt; score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                        subject_score_list.append(current_score)</span><br><span class="line">                        print(<span class="string">&#x27;cs[1]&gt;s[1]이지만, 마지막 요소라서 리스트 맨뒤에 추가&#x27;</span>, subject_score_list)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] == score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 수학 점수 비교</span></span><br><span class="line">                    <span class="keyword">if</span> current_score[<span class="number">2</span>] &gt; score[<span class="number">2</span>]:</span><br><span class="line">                        subject_score_list.insert(score_index, current_score)</span><br><span class="line">                        print(<span class="string">&#x27;cs[2]&gt;s[2]&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] &lt; score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                            subject_score_list.append(current_score)</span><br><span class="line">                            print(<span class="string">&#x27;cs[2]&lt;s[2]이지만, 마지막 요소라서 리스트 맨뒤에 추가&#x27;</span>, subject_score_list)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] == score[<span class="number">2</span>]:</span><br><span class="line">                        print(<span class="string">&#x27;cs[2]==s[2] 중복된 값이라서 추가x&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>정해진 순서대로 점수들을 배치하고, 중복된 점수들은 value값을 <code>dict</code>에서 찾아서 key값들을 같이 불러올거라서 제외했다.</p><p>이제 국영수 점수가 똑같은 사람들의 이름과 각 점수에 해당하는 사람들의 이름을 불러오면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 중복되는 값을 제거하고, dict에서 이름 찾을 때, 중복된 값이면 여러개가 저장될 텐데 거기서 네임 정렬 후 출력해주면 될 듯</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> subject_score_list:</span><br><span class="line">    name_list = []</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> subject_score_dict.items():</span><br><span class="line">        <span class="keyword">if</span> value == score:</span><br><span class="line">            name_list.append(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name_list) &gt; <span class="number">1</span>:</span><br><span class="line">        name_list.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> name_list:</span><br><span class="line">            print(a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(name_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>중복된 점수의 이름을 불러올 때, 내림차순으로 정렬 후 출력해주고, 중복된 점수가 아닐 때는 해당하는 이름만 불러오면 끝이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">subject_score_dict = &#123;&#125;</span><br><span class="line">subject_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    name, korean_score, english_score, math_score = <span class="built_in">input</span>().split()</span><br><span class="line">    korean_score, english_score, math_score = <span class="built_in">int</span>(korean_score), <span class="built_in">int</span>(english_score), <span class="built_in">int</span>(math_score)</span><br><span class="line">    subject_score_dict[name] = [korean_score, english_score, math_score]</span><br><span class="line">    current_score = [korean_score, english_score, math_score]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subject_score_list) == <span class="number">0</span>:</span><br><span class="line">        subject_score_list.append(current_score)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> score_index, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(subject_score_list):</span><br><span class="line">            <span class="keyword">if</span> current_score[<span class="number">0</span>] &gt; score[<span class="number">0</span>]:</span><br><span class="line">                subject_score_list.insert(score_index, current_score)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] &lt; score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] == score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> current_score[<span class="number">1</span>] &lt; score[<span class="number">1</span>]:</span><br><span class="line">                    subject_score_list.insert(score_index, current_score)</span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] &gt; score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                        subject_score_list.append(current_score)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] == score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> current_score[<span class="number">2</span>] &gt; score[<span class="number">2</span>]:</span><br><span class="line">                        subject_score_list.insert(score_index, current_score)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] &lt; score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                            subject_score_list.append(current_score)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] == score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> subject_score_list:</span><br><span class="line">    name_list = []</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> subject_score_dict.items():</span><br><span class="line">        <span class="keyword">if</span> value == score:</span><br><span class="line">            name_list.append(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name_list) &gt; <span class="number">1</span>:</span><br><span class="line">        name_list.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> name_list:</span><br><span class="line">            print(a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(name_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>입력예제 통과 후 제출했는데 python3로는 시간초과, PyPy3는 메모리 초과로 나왔다.</p><p>결국 다른 방식을 찾아봤다.</p><h3 id="sort-와-sorted-차이점"><a href="#sort-와-sorted-차이점" class="headerlink" title="sort()와 sorted() 차이점"></a>sort()와 sorted() 차이점</h3><ul><li><code>&lt;list&gt;.sort()</code>는 <code>list</code>의 내장 메소드이고, 원본 리스트의 순서를 정렬하는 함수다. 새로운 리스트를 만드는게 아니라서 이러한 혼동을 방지하기 위해서 <code>return none</code>을 반환한다.</li><li>‘sorted()’는 ‘sort()’와 달리 정렬 후 새로운 리스트로 반환한다. 리스트만 정렬가능한 <code>sort()</code>와 달리 <code>sorted()</code>는 <code>iterable</code>한 객체면 모두 사용 가능하다.<br><code>sort()</code>는 <code>sorted()</code>처럼 복사본을 만들지 않아서 좀 더 효율이 좋다.</li></ul><p><code>sort()</code>와 <code>sorted()</code>는 둘 다 파라미터로 <code>reverse</code>, <code>key</code>값을 받는데, <code>reverse</code>의 default값은 <code>reverse=False</code>로 오름차순 정렬, <code>reverse=True</code>는 내림차순 정렬이다.<br><code>key</code>는 각 리스트의 요소들을 정렬하기 전에, 정렬의 기준이 될 함수를 지정하는 파라미터다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><blockquote><p>내가 생각했을 때 소문자가 먼저 정렬된 뒤에 대문자가 나올 줄 알았는데, 둘이 섞여있다. 왜그럴까?</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split()</span><br><span class="line">[<span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.upper</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.lower</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><p>일반적으로 많이 사용하는 패턴은 객체의 인덱스 중 일부를 <code>key</code>로 사용해서 정렬한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student_tuples = [</span><br><span class="line">    (<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>),</span><br><span class="line">    (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(student_tuples, key=<span class="keyword">lambda</span> student: student[<span class="number">2</span>])   <span class="comment"># sort by age</span></span><br><span class="line">[(<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p><code>operator</code>모듈에 있는 <code>itemgetter()</code>, <code>attrgetter()</code>, <code>methodcaller()</code>를 이용한다면 더 빠르고 편리하게 만들 수 있다.</p><p>그 중에서 <code>itemgetter()</code>를 활용해보면</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="string">&#x27;name&#x27;</span>)(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tu&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="string">&#x27;tu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="number">1</span>)(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="built_in">slice</span>(<span class="number">2</span>,<span class="literal">None</span>))(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;CDEFG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 활용</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inventory = [(<span class="string">&#x27;apple&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;pear&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;orange&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcount = itemgetter(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(getcount, inventory))</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(inventory, key=getcount)</span><br><span class="line">[(<span class="string">&#x27;orange&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;apple&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;pear&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p><code>sort()</code>와 <code>sorted()</code> 모두 <code>key</code>값으로 중복된 값이 있다면, <strong>입력받은 순서대로 정렬된다.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(data, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><hr><p><code>sort()</code>를 이용해서 문제를 다시 풀어보면</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">student_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    student_score_list.append(<span class="built_in">input</span>().split())</span><br><span class="line">student_score_list.sort(key=<span class="keyword">lambda</span> x: (-<span class="built_in">int</span>(x[<span class="number">1</span>]), <span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="built_in">int</span>(x[<span class="number">3</span>]), x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> student_score_list:</span><br><span class="line">    print(student[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://docs.python.org/3/howto/sorting.html?highlight=sort">https://docs.python.org/3/howto/sorting.html?highlight=sort</a><br><a href="https://docs.python.org/3/library/operator.html#module-operator">https://docs.python.org/3/library/operator.html#module-operator</a><br><a href="https://stackoverflow.com/questions/22442378/what-is-the-difference-between-sortedlist-vs-list-sort">https://stackoverflow.com/questions/22442378/what-is-the-difference-between-sortedlist-vs-list-sort</a></p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210304 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/</guid>
      <pubDate>Thu, 04 Mar 2021 11:43:04 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTML-CSS-강의-내용-정리&quot;&gt;&lt;a href=&quot;#HTML-CSS-강의-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;HTML, CSS 강의 내용 정리&quot;&gt;&lt;/a&gt;HTML, CSS 강의 내용 정리&lt;/h1&gt;&lt;h2 id=&quot;적응형</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML-CSS-강의-내용-정리"><a href="#HTML-CSS-강의-내용-정리" class="headerlink" title="HTML, CSS 강의 내용 정리"></a>HTML, CSS 강의 내용 정리</h1><h2 id="적응형-웹-V-S-반응형-웹"><a href="#적응형-웹-V-S-반응형-웹" class="headerlink" title="적응형 웹 V.S 반응형 웹"></a>적응형 웹 V.S 반응형 웹</h2><ul><li><p>적응형(AWD)<br>적응형 웹은 각 기기에 적합한 UI 템플릿을 각각 제공<br>각 기기에 필요한 리소스만 다운로드 받아서 사용하기 때문에 로드 속도가 빠른 편</p></li><li><p>반응형(RWD)<br>미디어쿼리를 사용해서 하나의 UI 템플릿을 기기의 화면 크기에 맞게 변형<br>기기에 상관없이 모든 리소스를 다운로드 받아서 사용하기 때문에 로드 속도가 느린 편</p></li></ul><p>웹 제작 시 <code>mobile first</code> 방식으로 하는걸 추천</p><p><code>desktop first</code>로 설계된 페이지의 콘텐츠를 모바일에 넣으려고 하면 어떤걸 비워야 할 지 결정하기 힘들다.<br><code>mobile first</code>로 설계를 하게 되면 데스크탑에 어떤 컨텐츠를 채울지만 생각하면 된다.</p><blockquote><p><code>desktop first</code>는 코끼리를 냉장고에 넣어야 하는 것과 같다.</p></blockquote><p>모바일에서 구조 설계할 때 <code>off canvas</code>방식을 많이 사용한다.<br><code>off canvas</code> - 화면에서 안보이는 상태였다가 메뉴가 열릴 때 화면 밖에서 안으로 들어오는 방식</p><hr><p>반응형 이미지를 만들 때 CSS 속성으로</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br></pre></td></tr></table></figure><h2 id="max-width-100-를-주면-이미지-크기를-부모의-크기로-제한해주고-height-auto-는-이미지-크기가-attribute로-설정되어-있다면-높이는-줄어들지-않아서-원본-비율에-맞게-높이를-자동으로-조절해준다"><a href="#max-width-100-를-주면-이미지-크기를-부모의-크기로-제한해주고-height-auto-는-이미지-크기가-attribute로-설정되어-있다면-높이는-줄어들지-않아서-원본-비율에-맞게-높이를-자동으로-조절해준다" class="headerlink" title="max-width: 100%;를 주면 이미지 크기를 부모의 크기로 제한해주고, height: auto;는 이미지 크기가 attribute로 설정되어 있다면 높이는 줄어들지 않아서 원본 비율에 맞게 높이를 자동으로 조절해준다."></a><code>max-width: 100%;</code>를 주면 이미지 크기를 부모의 크기로 제한해주고, <code>height: auto;</code>는 이미지 크기가 <code>attribute</code>로 설정되어 있다면 높이는 줄어들지 않아서 원본 비율에 맞게 높이를 자동으로 조절해준다.</h2><p>다른 브라우저에서 지원하지 않는 속성이 있을 때,<br><code>polyfill + 속성</code>을 구글링 하면 대응할 수 있는 방법이 나올 수도 있다.</p><hr><h2 id="lt-picture-gt-태그는-하나의-이미지를-확대-축소하는-방법이-아닌-여러-이미지를-사이즈에-맞게-받아서-뷰포트에-맞게-대응할-수-있게-해주는-태그다-fallback으로-lt-img-gt-를-줘야-하고-반응형-웹에서-자주-사용된다"><a href="#lt-picture-gt-태그는-하나의-이미지를-확대-축소하는-방법이-아닌-여러-이미지를-사이즈에-맞게-받아서-뷰포트에-맞게-대응할-수-있게-해주는-태그다-fallback으로-lt-img-gt-를-줘야-하고-반응형-웹에서-자주-사용된다" class="headerlink" title="&lt;picture&gt;태그는 하나의 이미지를 확대 축소하는 방법이 아닌, 여러 이미지를 사이즈에 맞게 받아서  뷰포트에 맞게 대응할 수 있게 해주는 태그다. fallback으로 &lt;img&gt;를 줘야 하고 반응형 웹에서 자주 사용된다."></a><code>&lt;picture&gt;</code>태그는 하나의 이미지를 확대 축소하는 방법이 아닌, 여러 이미지를 사이즈에 맞게 받아서  뷰포트에 맞게 대응할 수 있게 해주는 태그다. fallback으로 <code>&lt;img&gt;</code>를 줘야 하고 반응형 웹에서 자주 사용된다.</h2><p><code>&lt;body&gt;</code>안에 <code>&lt;div class=&quot;containor&quot;&gt;</code> 같이 묶어주면 컴포넌트 나누기 편하다.</p><blockquote><p><code>&lt;body&gt;</code>에 배경을 줬을 때 <code>margin</code>을 준 부분까지 적용이 되는데 이유가 뭘까?</p></blockquote><p>시멘틱 태그를 주지 않아도 비슷한 역할을 <code>WAI-ARIA roles</code>를 이용하면 만들어 줄 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p><code>position: fixed</code>는 뷰포트 기준으로 위치를 조절할 수 있다.<br><code>position: sticky</code> = relative + fixed</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">wh</span>;</span><br></pre></td></tr></table></figure><p><code>fixed</code>된 상태에서 왼쪽과 오른쪽으로 맞추려고 하다보니 양쪽 끝으로 늘어나는 것 처럼 보인다.</p><h2 id="position-absolute상태에서-top-bottom-left-right에-0값을-주고-margin을-주면-가운데-정렬-느낌-낼-수-있다"><a href="#position-absolute상태에서-top-bottom-left-right에-0값을-주고-margin을-주면-가운데-정렬-느낌-낼-수-있다" class="headerlink" title="position: absolute상태에서 top,bottom,left,right에 0값을 주고 margin을 주면 가운데 정렬 느낌 낼 수 있다"></a><code>position: absolute</code>상태에서 top,bottom,left,right에 0값을 주고 margin을 주면 가운데 정렬 느낌 낼 수 있다</h2><p>flex-item들은 형제 레벨에 맞춰서 높이가 자동으로 조절된다.<br>flex-item들 끼리 마진 병합이 일어나지 않는다.</p><p>CSS에서 <code>display: none</code>값을 HTML5에서 태그 안에 <code>hidden</code>을 주면 비슷한 역할을 할 수 있다.</p><h2 id="cal"><a href="#cal" class="headerlink" title="cal()"></a>cal()</h2><p>CSS에서 calc() CSS함수를 사용하면 계산식을 지정할 수 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.h1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="built_in">cal</span>(<span class="number">50%</span> - <span class="number">10px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210303 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/</guid>
      <pubDate>Wed, 03 Mar 2021 11:47:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTML-CSS-강의-내용-정리&quot;&gt;&lt;a href=&quot;#HTML-CSS-강의-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;HTML, CSS 강의 내용 정리&quot;&gt;&lt;/a&gt;HTML, CSS 강의 내용 정리&lt;/h1&gt;&lt;h2 id=&quot;tra</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML-CSS-강의-내용-정리"><a href="#HTML-CSS-강의-내용-정리" class="headerlink" title="HTML, CSS 강의 내용 정리"></a>HTML, CSS 강의 내용 정리</h1><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p><code>transition</code>은 어떤 속성이 어떤 상황(ex.<code>:hover</code>)으로 인해 <code>A-&gt;B</code>로 변경될 때 그 과정을 일정 기간에 걸쳐서 자연스럽게 변화하는 과정을 보여준다. 이와 비슷한 기능을 하는 <code>@keyframes</code>가 있는데, <code>transition</code>보다 더 디테일하고 다양하게 변화를 줄 수 있다.<br>‘transition-delay’속성을 줄 때, <code>s</code>, <code>ms</code>단위를 사용할 수 있는데, 0초를 주더라고 꼭 <code>0s</code>로 s를 붙여야 한다. 다른 속성들과 다르게 0초의 단위를 생략할 수 없다.</p><h2 id="대화형-콘텐츠"><a href="#대화형-콘텐츠" class="headerlink" title="대화형 콘텐츠"></a>대화형 콘텐츠</h2><p><code>:hover</code>는 모든 태그에 대해서 사용이 가능하지만, <code>:focus</code>는 <code>a</code>, <code>input</code>, <code>button</code> 태그와 같이 <a href="https://developer.mozilla.org/ko/docs/Web/Guide/HTML/Content_categories#%EB%8C%80%ED%99%94%ED%98%95_%EC%BD%98%ED%85%90%EC%B8%A0">대화형 콘텐츠</a>의 요소만 사용이 가능하다.</p><blockquote><p>태그에 <code>tabindex=&quot;0&quot;</code>을 준다면 <code>tab</code>키를 받을 수 있어서 <code>:focus</code>를 사용가능하게 만들 수는 있다.</p></blockquote><h2 id="순서-입력"><a href="#순서-입력" class="headerlink" title="순서 입력"></a>순서 입력</h2><p>CSS로 <code>&lt;li&gt;</code>안에 순서대로 숫자를 입력할 때 <code>li::before&#123;content: &quot;1&quot;&#125;</code>하나씩 입력해도 되지만 100개가 넘는다면? 너무 노가다.. 해결 방법이 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::befor</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">counter</span>(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;li&gt;</code>에 순서대로 숫자가 입력된다.</p><h2 id="문자-숨기는-방법"><a href="#문자-숨기는-방법" class="headerlink" title="문자 숨기는 방법"></a>문자 숨기는 방법</h2><p><code>padding</code> <code>overflow: hidden</code><br><code>text-indent</code> <code>overflow: hidden</code><br><code>::after&#123;background: url()&#125;</code></p><h2 id="인용구"><a href="#인용구" class="headerlink" title="인용구"></a>인용구</h2><p><code>&lt;blockquote&gt;</code><br><code>&lt;q cite=&quot; &quot;&gt;</code> <code>cite</code>는 인용한 정보의 저작권 표시를 위한 속성. 값으로 <code>isbn: ~</code>책에 대한 내용 <code>http:// ~</code> 웹에 대한 내용</p><p><code>&lt;footer&gt;</code>는 제목을 가지지 않는게 좋다.</p><p><code>&lt;a href=&quot;tel: 01012341234&quot;&gt;</code> 링크를 누르면 자동으로 전화로 연결해줄 수 있다.</p><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p>Grid를 사용하면 배치에 대한 큰 걱정없이 논리성을 줌심으로 마크업할 수 있다.<br>단, <code>Internet Explorer</code>를 지원하지 않는 단점이 있는데,<br>전세계에서 <code>Internet Explorer</code>의 점유율은 2%미만을 차지하는데 우리나라는 높은 비중을 차지하고 있어서 현업에서 <code>Grid</code>를 사용하기는 힘들다고 한다.<br><a href="https://presscat.co.kr/blog/browser-market-share-mar2020/">웹 브라우저 시장 점유율(2020)</a></p><hr><p>클론 코딩은 완전히 똑같이 만드는게 아니라 그 페이지를 분석해보고, 장점은 가져오고 보완했으면 좋은 것들을 정리해서 만들어야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210302 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/02/20210302-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/02/20210302-TIL/</guid>
      <pubDate>Tue, 02 Mar 2021 12:29:57 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;[BAEKJOON]회문 문제 풀이 정리&lt;/li&gt;
&lt;li&gt;HTML, CSS 강의 내용 복</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h1><ul><li>[BAEKJOON]회문 문제 풀이 정리</li><li>HTML, CSS 강의 내용 복습</li></ul><h1 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h1><ul><li>Semantic 마크업 </li><li>웹 표준, 접근성</li><li>ARIA</li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/02/20210302-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 회문 17609번</title>
      <link>https://juhyeong-k.github.io/2021/03/01/BAEKJOON-%ED%9A%8C%EB%AC%B8-17609/</link>
      <guid>https://juhyeong-k.github.io/2021/03/01/BAEKJOON-%ED%9A%8C%EB%AC%B8-17609/</guid>
      <pubDate>Mon, 01 Mar 2021 13:37:52 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;회문-팰린드롬-palindrome&quot;&gt;&lt;a href=&quot;#회문-팰린드롬-palindrome&quot; class=&quot;headerlink&quot; title=&quot;회문/팰린드롬(palindrome)&quot;&gt;&lt;/a&gt;회문/팰린드롬(palindrome)&lt;/h1&gt;&lt;h2 id=</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="회문-팰린드롬-palindrome"><a href="#회문-팰린드롬-palindrome" class="headerlink" title="회문/팰린드롬(palindrome)"></a>회문/팰린드롬(palindrome)</h1><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.</p><p>여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.</p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><p>처음에 생각한 건 입력받은 문자열과 거꾸로 뒤집은 문자열을 비교하고, 같으면 0출력 다르면 문자열에서 문자 한 개를 빼고 다시 뒤집은 다음에 비교하는 반복문을 넣어서 만들어봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    words = <span class="built_in">list</span>(<span class="built_in">input</span>())</span><br><span class="line">    reverse_words = words[::-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> words == reverse_words:</span><br><span class="line">        print(<span class="number">0</span>) <span class="comment"># palindrome</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            new_words = <span class="built_in">list</span>(words) <span class="comment"># 연결 끊어내기 위해 list선언</span></span><br><span class="line">            new_words.pop(i)</span><br><span class="line">            reverse_new_words = new_words[::-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> new_words == reverse_new_words:</span><br><span class="line">                print(<span class="number">1</span>) <span class="comment"># pseudo palindrome</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> new_words != reverse_new_words:</span><br><span class="line">            print(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>정답을 제출했는데, 시간초과가 나왔다. 맞거나 틀리거나 둘 중 하나라고 생각했는데 시간초과라고 해서 당황했다. 시간복잡도에 대해서 제대로 생각해본 적이 없었던 것 같다.</p><p>이번엔 다른 방식으로 코드를 짜봤다.<br>왼쪽과 오른쪽 문자를 가운데에 수렴할 때까지 비교해서 계속 같으면 0출력, 다르면 왼쪽 혹은 오른쪽 문자 한 개를 제외하고 다시 비교해서 계속 같으면 1출력, 다르면 0출력</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrom</span>(<span class="params">words</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line">    result = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> words[left] == words[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> words[left+<span class="number">1</span>] == words[right]:</span><br><span class="line">            left += <span class="number">2</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            result = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> words[left] == words[right-<span class="number">1</span>]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">2</span></span><br><span class="line">            result = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> result:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(palindrom(<span class="string">&#x27;comwwtmoc&#x27;</span>))</span><br></pre></td></tr></table></figure><p>이번엔 결과가 틀렸다고 나왔다. 코드를 다시 살펴보니, 문자를 한 개만 제거하고 비교해야 하는데, 문자열이 맞지 않을 때마다 계속 제거하면서 비교하고 있었다. 그리고 유사 회문(pseudo palindrome)처리가 너무 애매해서 여기저기 찾아보면서 힌트를 얻었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pseudo_palindrom</span>(<span class="params">left, right, words</span>):</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> words[left] == words[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindrom</span>(<span class="params">words</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(words) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> words[left] == words[right]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func_1 = pseudo_palindrom(left+<span class="number">1</span>, right, words)</span><br><span class="line">            func_2 = pseudo_palindrom(left, right-<span class="number">1</span>, words)</span><br><span class="line">            <span class="keyword">if</span> func_1 <span class="keyword">or</span> func_2:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    print(palindrome(<span class="built_in">input</span>()))</span><br></pre></td></tr></table></figure><p>유사회문(pseudo palindrom)처리하는 함수를 따로 만들어서 왼쪽을 제거할 때, 오른쪽을 제거할 때의 경우를 모두 구해서 둘 중에 하나라도 True값이면 1이 출력되게 했다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/01/BAEKJOON-%ED%9A%8C%EB%AC%B8-17609/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210301 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/01/20210301-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/01/20210301-TIL/</guid>
      <pubDate>Mon, 01 Mar 2021 12:53:30 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-한-일&quot;&gt;&lt;a href=&quot;#오늘-한-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 한 일&quot;&gt;&lt;/a&gt;오늘 한 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;sigma 과제 풀이&lt;/li&gt;
&lt;li&gt;알고리즘 문제 풀이&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-한-일"><a href="#오늘-한-일" class="headerlink" title="오늘 한 일"></a>오늘 한 일</h1><ul><li>sigma 과제 풀이</li><li>알고리즘 문제 풀이</li></ul><h1 id="내일-할-일"><a href="#내일-할-일" class="headerlink" title="내일 할 일"></a>내일 할 일</h1><ul><li>HTML, CSS 강의 복습</li><li>알고리즘 문제 정리</li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/01/20210301-TIL/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
