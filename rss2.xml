<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JH&#39;s dev blog</title>
    <link>https://juhyeong-k.github.io/</link>
    
    <atom:link href="https://juhyeong-k.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>All about dev</description>
    <pubDate>Tue, 16 Mar 2021 11:38:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>20210316 TIL JS 예습</title>
      <link>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/</guid>
      <pubDate>Tue, 16 Mar 2021 01:27:10 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;17-생성자-함수에-의한-객체-생성&quot;&gt;&lt;a href=&quot;#17-생성자-함수에-의한-객체-생성&quot; class=&quot;headerlink&quot; title=&quot;17. 생성자 함수에 의한 객체 생성&quot;&gt;&lt;/a&gt;17. 생성자 함수에 의한 객체 생성&lt;/h1&gt;&lt;p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="17-생성자-함수에-의한-객체-생성"><a href="#17-생성자-함수에-의한-객체-생성" class="headerlink" title="17. 생성자 함수에 의한 객체 생성"></a>17. 생성자 함수에 의한 객체 생성</h1><p>생성자 함수(constructor)란 <code>new</code> 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말하고, 생성자 함수에 의해 생성된 객체를 인스턴스(intance)라 한다.<br>자바스크립트는 Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수를 제공한다.</p><p><code>new</code>연산자와 함께 호출하지 않으면 일반 함수로 호출된다.</p><blockquote><p>Object 생성자 함수를 사용해서 객체를 생성하는 것 보다 객체 리터럴을 이용하는게 더 직관적이고 편한 것 같은데 생성자 함수로 생성해야되는 이유가 있을까?</p></blockquote><p>공통된 프로퍼티를 여러 객체가 가져야 할 경우, 생성자 함수를 이용하면 간편하게 생성할 수 있다. 객체 리터럴은 직관적이고 편리하지만, 공통된 프로퍼티들을 갖는 여러 객체들에게 각각 프로퍼티를 입력해줘야 하는 단점이 있다.</p><p>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수고, 생성된 인스턴스를 초기화하는 것은 옵션이다.</p><p>생성자 함수의 인스턴스 생성 과정</p><ul><li>인스턴스 생성과 this 바인딩은 런타임 이전에 암묵적으로 자바스크립트 엔진에 의해 실행된다.</li><li>생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화 한 뒤(this에 바인딩 되어 있는 인스턴스에 프로퍼티나 메서드 추가) 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li><li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스의 바인딩 된 this가 암묵적으로 반환된다. 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시한 객체가 반환되기 때문에 생성자 함수의 기본 동작을 훼손하지 않으려면 생성자 함수 내부에서 return문을 반드시 생략해야 한다. 단, 원시값을 return 하면 무시되고 this가 암묵적으로 반환된다.</li></ul><p>객체에는 일반 객체와 함수 객체가 있는데, 둘을 구분할 수 있는 기준은 호출이 가능한지 아닌지로 할 수 있다. 즉 객체 내부 메소드 <code>[[call]]</code>을 가지고 있는 객체를 함수 객체라 할 수 있다. 함수 객체에서 일반함수와 생성자 함수를 구분하자면, constructor와 non-constructor로 구분할 수 있다. constructor는 내부 메서드 <code>[[construct]]</code>를 갖는 함수 객체로 생성자 함수로서 호출할 수 있는 함수를 말하고, non-constructor는 <code>[[construct]]</code>를 갖지 않는, 생성자 함수로서 호출할 수 없는 함수를 의미한다. </p><ul><li>constructor : 함수 선언문, 함수 표현식, 클래스</li><li>non-constructor : 메서드(ES6 메서드 축약 표현), 화살표 함수</li></ul><p>프로퍼티 값으로 함수를 사용하면 일반적으로 메소드라 칭하는데, ECMAScript의 사양에서 메소드는 ES6의 메서드 축약 표현만 의미한다.</p><p>사실 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하는지 안하는지에 따라 달라지기 때문이다. 즉, new 연산자 없이 constructor를 호출하면 일반 함수로 호출되고, new 연산자와 함께 cosntructor를 호출하면 생성자 함수로 호출된다.<br>생성자 함수와 일반 함수를 구별하기 위해서 생성자 함수의 이름을 파스칼 케이스로 명명하지만, 실수는 언제나 발생할 수 있다. 이런 위험성을 회피하기 위해 ES6에서 <code>new.target</code>을 지원한다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었을 때 함수 자신을 가리키고, new 연산자 없이 일반 함수로 호출되었다면 undefined를 의미한다. 따라서 함수 내부에서 new 연산자와 함께 재귀 호출을 통해 생성자 함수로 호출할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined다.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.target) &#123;</span><br><span class="line">    <span class="comment">// new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.radius = radius;</span><br><span class="line">  <span class="built_in">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());</span><br></pre></td></tr></table></figure><h1 id="26-배열"><a href="#26-배열" class="headerlink" title="26. 배열"></a>26. 배열</h1><p>배열(array)은 여러 개의 값을 순차적으로 나열한 자료 구조다. 배열이 가지고 있는 값을 요소(element)라고 부르고, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.</p><p>자바스크립트에 배열이라는 타입은 존재하지 않는다. 배열은 객체 타입이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> arr <span class="comment">// -&gt; object</span></span><br></pre></td></tr></table></figure><p>배열은 객체지만 일반 객체와는 구별되는 특징이 있다. 구분하는 가장 명확한 차이는 “값의 순서”와 “length 프로퍼티”다.</p><h3 id="자바스크립트-배열은-배열이-아니다"><a href="#자바스크립트-배열은-배열이-아니다" class="headerlink" title="자바스크립트 배열은 배열이 아니다"></a>자바스크립트 배열은 배열이 아니다</h3><p>자료구조(data structure)에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 즉, 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(dense array)이라 한다.</p><blockquote><p>검색 대상의 메모리 주소 = 배열의 시작 메모리 주소 + 인덱스 * 요소의 바이트 수</p></blockquote><p>예를 들어 메모리 주소 1000에서 시작하고 각 요소의 크기가 8바이트인 배열을 생각해보면,</p><ul><li>인덱스가 0인 요소의 메모리 주소: 1000 + 0 * 8 = 1000</li><li>인덱스가 1인 요소의 메모리 주소: 1000 + 1 * 8 = 1008</li><li>인덱스가 2인 요소의 메모리 주소: 1000 + 2 * 8 = 1016</li></ul><p>이렇게 표현될 수 있다. 이처럼 배열은 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있고 시간 복잡도 <code>O(1)</code>라고 표현할 수 있다. 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색(선형검색(linear search), 시간 복잡도 <code>O(n)</code>)해야 한다. 또한 배열에 요소를 삽입하거나 삭제하는 경우 배열의 요소를 연속적으로 유지하기 위해 요소들을 이동시켜야 하는 단점도 있다.</p><p>자바스크립트에서의 배열은 위에서 설명한 일반적인 의미의 배열과 다르다. 자바스크립트에서의 배열은 배열의 요소를 위한 각각의 메모리 공간을 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열(sparse array)이라 한다.<br><strong>자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다.</strong></p><p>자바스크립트 배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 가지며, 배열의 요소를 프로퍼티 값으로 갖고, length 프로퍼티를 갖는 특수한 객체다.</p><p>정리하자면 일반적인 배열은 인덱스로 배열 요소에 접근이 빠른 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 효율적이지 않지만, 자바스크립트 배열은 인덱스로 배열 요소에 접근이 느린 반면, 특정 요소를 검색하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다.</p><p>자바스크립트 배열의 length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제할 때 자동으로 갱신된다.<br>length 프로퍼티의 값은 배열의 길이를 바탕으로 결정되지만, 임의의 숫자 값을 명시적으로 할당할 수도 있다. 현재 length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>반대로 현재 legth 프로퍼티 값보다 큰 숫자 값을 할당하면 length 프로퍼티의 값은 변경이 되지만 실제 배열의 길이가 늘어나지는 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, 3, 4, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p><code>&lt;4 empty items&gt;</code>는 실제로 추가된 배열의 요소가 아니다. length 프로퍼티 값이 변경됐다고 해도 값 없이 비어 있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지도 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [,, <span class="number">3</span>,, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5 ]</span></span><br><span class="line">arr.length = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;2 empty items&gt;, 3, &lt;1 empty item&gt;, 5, &lt;4 empty items&gt; ]</span></span><br></pre></td></tr></table></figure><p>일반적인 배열의 length는 배열의 요소의 개수와 언제나 일치하지만, 희소 배열은 length와 배열의 요소 개수와 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.</p><p>자바스크립트는 문법적으로 희소 배열을 허용하지만 희소 배열은 사용하지 않는 것이 좋다. 희소 배열은 연속적인 값의 집합이라는 배열의 기본적인 개념과 맞지 않으며, 성능에도 좋지 않은 영향을 준다.</p><h3 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h3><p>객체와 마찬가지로 배열도 다양한 생성 방식이 있는데, 가장 일반적이고 간단한 배열 생성 방식은 배열 리터럴을 사용하는 것이다. 배열 리터럴은 0개 이상의 요소를 쉼표로 구분해서 대괄호(<code>[ ]</code>)로 묶는다.</p><p>Object 생성자 함수를 통해 객체를 생성할 수 있듯이 Array 생성자 함수를 통해 배열을 생성할 수도 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">대부분의 빌트인 생성자 함수(Object, Function, Array, Date, RegExp, Promise 등)는 </span></span><br><span class="line"><span class="comment">new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. </span></span><br><span class="line"><span class="comment">생성자 함수 내부에서 new.target을 확인하기 때문이다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>Array 생성자 함수에 전달되는 인수가 1개이고 숫자인 경우, length 프로퍼티 값이 인수인 배열을 생성한다. length 프로퍼티 값이 0은 아니지만 실제로 배열의 요소는 존재하지 않는 희소 배열이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br></pre></td></tr></table></figure><p>전달된 인수가 없는 경우 length 프로퍼티 값이 0인 빈 배열을 생성한다. 즉 배열 리터럴(<code>[ ]</code>)과 같다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 전달되는 인수가 2개 이상이면 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 전달되는 인수가 1개지만, 숫자가 아닌 인수이기 때문에 인수를 요소로 갖는 배열을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ &#123;&#125; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>전달된 인수가 2개 이상이거나 숫자가 아닌 경우 인수를 요소로 갖는 배열을 생성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="string">&#x27;string&#x27;</span>));</span><br></pre></td></tr></table></figure><p><code>Array.of</code>는 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span>, <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr1));</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: &#x27;a&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: &#x27;b&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: &#x27;c&#x27;, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 3, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="built_in">Array</span>.from(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;!&#x27;]</span></span><br></pre></td></tr></table></figure><p>ES6에서 도입된 <code>Array.from</code>메소드는 유사 배열 객체(array-like object) 또는 이터러블 객체(iterable object)를 인수로 전달 받아서 배열로 변환 후, 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.from에 length만 존재하는 유사 배열 객체를 전달하면 길이에 맞게 undefined를 요소로 채운다.</span></span><br><span class="line"><span class="keyword">const</span> arr3 = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [ undefined, undefined, undefined ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from은 두 번째 인수로 전달한 콜백 함수의 반환 값으로 구성된 배열을 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> arr4 = <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> i);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 배열 요소의 참조</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 인덱스가 2인 요소를 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 존재하지 않는 요소에 접근하면 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열도 마찬가지</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>,,<span class="number">3</span>,,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2[<span class="number">3</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr2));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;4&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 5, writable: true, enumerable: false, configurable: false &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line"><span class="comment">//배열 요소 추가</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="string">&#x27;1&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="comment">// 프로퍼티 추가</span></span><br><span class="line">arr[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">arr.bar = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1.1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[-<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 2, foo: 3, bar: 4, &#x27;1.1&#x27;: 5, &#x27;-1&#x27;: 6 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티는 배열의 length에 영향을 주지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(arr));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  length: &#123; value: 2, writable: true, enumerable: false, configurable: false &#125;,</span></span><br><span class="line"><span class="comment">  foo: &#123; value: 3, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  bar: &#123; value: 4, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;1.1&#x27;: &#123; value: 5, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">  &#x27;-1&#x27;: &#123; value: 6, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>인덱스는 요소의 위치를 나타내기 때문에 반드시 0 이상의 정수(정수 형태 문자열)를 사용해야 한다. 정수 이외에 값을 인덱스처럼 사용한다면 요소가 생성되는게 아닌 프로퍼티가 추가된다. 추가된 프로퍼티는 요소가 아니기 때문에 배열의 length 프로퍼티에 영향을 미치지 않는다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, &lt;1 empty item&gt;, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>배열도 객체이기 때문에 <code>delete</code>연산자를 이용해서 요소를 삭제할 수 있다. 위의 경우 1번 인덱스의 값을 삭제하면서 희소 배열이 되고 length 프로퍼티의 값은 변하지 않는다. 희소 배열을 만드는 delete 연산자는 사용하지 않는게 좋다. 만약 희소 배열로 만들지 않고 배열의 특정 요소를 완전히 삭제하려면 <code>Array.prototype.splice</code>메소드를 사용한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.slplice(삭제를 시작 할 인덱스, 삭제할 요소 개수)</span></span><br><span class="line">arr1.splice(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 1번 인덱스부터 2개 삭제</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [ 1, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.length); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 희소 배열로 만들어지는 경우</span></span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">delete</span> arr2[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [ 1, &lt;2 empty items&gt;, 4, 5 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 원본을 직접 변경하는 push 메소드</span></span><br><span class="line">arr1.push(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 새로운 배열을 생성하는 concat 메소드</span></span><br><span class="line"><span class="keyword">const</span> result = arr2.concat(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><p>자바스크립트에서 배열 메소드는 결과물을 반환하는 패턴이 두 가지 있다. 원본 배열(배열 메소드를 호추한 배열, 배열 메소드의 구현체 내부에서 this가 가리키는 객체)을 직접 변경하는 메소드(mutator method)와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드(accessor method)가 있다.<br>원본을 직접 변경하는 메소드는 외부 상태를 직접 변경하는 부수 효과(side effect)가 있으므로 가급적 원본 배열을 직접 변경하지 않는 메소드를 사용하는 편이 좋다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.push(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr.push</span></span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line">arr1.push(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr1 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr1 performance test: 0.134ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [arr.length] </span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line">arr2[arr2.length] = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;arr2 performance test&#x27;</span>);</span><br><span class="line"><span class="comment">// arr2 performance test: 0.01ms</span></span><br></pre></td></tr></table></figure><p>push 메소드는 원본 배열의 마지막 요소로 추가하고 변경된 lengh 프로퍼티 값을 반환한다.<br>마지막 요소로 추가할 요소가 하나뿐이라면 push 메소드보다 length 프로퍼티를 사용해서 배열의 마지막에 요소를 직접 추가하는게 더 빠르다.(push 메소드는 성능 면에서 좋지 않다.)</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/16/20210316-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210315 TIL JS 4회차</title>
      <link>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/</guid>
      <pubDate>Mon, 15 Mar 2021 04:57:29 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;11-함수&quot;&gt;&lt;a href=&quot;#11-함수&quot; class=&quot;headerlink&quot; title=&quot;11. 함수&quot;&gt;&lt;/a&gt;11. 함수&lt;/h1&gt;&lt;p&gt;인수(argument)는 함수 밖에서 함수 매개변수(parameter)에 순서대로 할당된다.&lt;br&gt;매</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="11-함수"><a href="#11-함수" class="headerlink" title="11. 함수"></a>11. 함수</h1><p>인수(argument)는 함수 밖에서 함수 매개변수(parameter)에 순서대로 할당된다.<br>매개변수는 0개 이상<br>함수 정의만으로 함수가 실행되지 않고 함수를 호출해야 실행이 된다.</p><p>변수 호이스팅과 함수 호이스팅은 미묘한 차이가 있다.<br>변수 선언문은 런타임 이전에 변수가 <code>undefined</code>로 초기화가 되고, 런타임에 값이 할당 되어지지만, 함수 선언문은 runtime 이전에 정의가 되어지기 때문에 함수 정의가 어느 위치에 있던 런타임 시 첫째줄에 호출을 해도 실행이 된다.</p><p>함수 표현식을 사용하면 변수 호이스팅이 발생해서 runtime 이전에 변수에 undefined로 초기화되고 런타임에 순서에 맞게 함수가 정의가 된다. 즉, 함수 표현식은 정의 이전에 호출할 수 없다.</p><p>함수 이름은 함수 몸체 안에서만 유효하다. 그래서 함수 표현식에서 함수 이름은 생략이 가능하다. 함수 몸체 안에서 사용할 때는 재귀를 사용할때 정도로 생각할 수 있는데, 굳이 함수 이름이 아닌 식별자로 넣어줘도 문제 없기 때문에, 함수 표현식에서 함수 이름은 생략한다.</p><p>함수 리터럴 - 함수객체를 생성하는 것</p><p>일반 객체와 함수 객체의 차이는 호출 가능/불가능 차이</p><blockquote><p>함수 선언문과 함수 표현식 둘 중 어떤걸 사용하는게 좋을까?<br>함수 선언문은 함수 객체가 런타임 이전에 만들어지고 함수 표현식은 런타임 때 만들어진다. 결국 함수 객체를 생성하는 시점에 차이가 있다. 둘 중 어느걸 사용해도 상관은 없지만 일관성 있게 사용해야 한다.(결국 나중에 애로우 함수를 사용할 것이기 때문에..)</p></blockquote><p>함수가 호출이 되면 함수가 정의된 부분으로 돌아가서 함수 코드블록을 실행하기 때문에, 함수도 제어문의 일종이라고 볼 수 있다.</p><blockquote><p>{ }는 블록문일까 객체 리터럴일까?</p></blockquote><p><code>&#123; &#125;</code>는 블록문 일수도 객체 리터럴일 수도 있다. <code>&#123; &#125;</code>는 중의적 표현이기 때문에 자바스크립트 엔진이 코드의 문맥에 따라 해석을 달리한다. <code>&#123; &#125;</code>가 단독을 존재하면 블록문으로 해석하고, <code>&#123; &#125;</code>가 값으로 평가되어야 할 문맥(할당연산자의 우변)에서 피연산자로 사용되면 객체 리터럴로 해석한다.</p><p>자바스크립트는 매개변수(parameter)와 인수(arguments)의 개수가 일치하지 않아도 오류가 발생하지 않는다.<br>매개변수보다 인수가 적을 경우, 함수를 호출하면서 파라미터에 있는 변수를 선언하기 때문에 <code>undefined</code>로 초기화가 되고, 값이 전달되지 않은 파라미터 변수는 <code>undefined</code>를 가지고 진행한다.</p><p>매개변수보다 인수가 많을 경우, 파라미터를 초과하는 값들은 사라지게 될 것 같지만 함수 내에서 <code>arguments</code>를 불러보면 유사 배열 객체로 인수들이 저장되어 있는 것을 확인할 수 있다.</p><p>이렇게 자바스크립트에서 매개변수와 인수의 개수가 맞지 않거나 입력 받는 타입이 다를 때 오류를 발생시키지 않기 때문에, 함수 내부에서 확인을 하고 오류를 발생시키는 것도 좋은 방법이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br></pre></td></tr></table></figure><p>위와 같이 매개변수로 <code>...args</code>를 주면, 파이썬의 <code>*args</code>와 비슷하게 여러 개의 매개변수를 받을 수 있고, 배열로 저장된다.</p><p>함수에서 <code>return</code>이 생략되어도 자바스크립트 엔진이 마지막에 <code>return</code>을 만들어 줘서 <code>undefined</code>값이 리턴된다.</p><p>jQuery에서 파라미터를 하나만 받는 이유</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">  data: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Lee&#x27;</span> &#125;,</span><br><span class="line">  cache: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 파라미터로 하나의 객체에 담아서 주는 이유? 프로퍼티가 여러 개 들어갈수록 순서를 지켜야 하고, 타입도 생각을 해야하기 때문에</span></span><br><span class="line"><span class="comment">// 파라미터를 하나만 줘서 가독성 좋게 만들었다.</span></span><br><span class="line"><span class="comment">// 프로퍼티 키가 프로퍼티 값을 설명해주고, 순서를 지키지 않아도 되기 때문에 파라미터는 적을수록 좋다.</span></span><br><span class="line"><span class="comment">// 단점으로 객체 참조할 수 있기 때문에 함수를 거쳐서 원본이 수정될 수 있다.</span></span><br><span class="line"><span class="comment">// 그래서 원본이 수정되지 않게 객체를 동결시켜야하는 경우가 있다.</span></span><br><span class="line"><span class="comment">// 혹은 객체를 카피(깊은 복사)해서 따로 관리하게 할 수도 있다.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>변수는 값을 재사용하는 것 처럼, 함수는 로직을 재사용하는 것이다.</p><p>중첩함수(nested function)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 중첩 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 외부 함수의 변수를 참조할 수 있다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(x + y); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수의 역할을 한다.</p><p>콜백 함수(callback function)<br>함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수(callback function)라 하고, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복 호출한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">repeat</span>(<span class="params">n, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f(i); <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반복 호출할 함수를 인수로 전달한다.</span></span><br><span class="line">repeat(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure><h1 id="13-스코프"><a href="#13-스코프" class="headerlink" title="13. 스코프"></a>13. 스코프</h1><p>모든 식별자(변수 이름, 함수 이름, 클래스 이름)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정되는 것을 스코프라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다.(식별자를 검색하는 규칙)</p><p>전역 변수 - 함수 내부가 아닌 모든 변수<br>지역 변수 - 함수 몸체 내부의 변수</p><p><code>var</code>키워드는 같은 스코프 내에서 중복 선언이 허용되지만, <code>let</code>과 <code>const</code>키워드는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p><p>모든 스코프는 하나의 계측적 구조로 연결되고, 모든 지역 스코프의 최상위 스코프는 전역 스코프다. 스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 한다. 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색(identifier resolution)한다.</p><p>렉시컬 환경(Lexical Environment)<br>스코프 체인은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결(chaining)한 것이다.</p><p>블록 레벨 스코프(block level scope)와 함수 레벨 스코프(function level scope)<br>모든 코드 블록(if, for, while, try 등)이 지역 스코프를 만드는 것을 블록 레벨 스코프라 하고, 함수의 코드 블록에서 만 지역 스코프를 만드는 것을 함수 레벨 스코프라 한다.</p><p>자바스크립트에서 <code>var</code>키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. for반복문 안에서 사용되는 <code>i</code>변수는 반복문 안에서만 사용되지만, <code>var</code>키워드로 선언하면 전역 변수가 되기 때문에 의도치 않은 전역 변수 값이 할당된다.<br>ES6에서ES6에 도입된 <code>let</code>, <code>const</code>키워드는 블록 레벨 스코프를 지원한다.</p><p>렉시컬 스코프(lexical scope)와 동적 스코프(dynamic scope)<br>렉시컬 스코프는 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하고, 동적 스코프는 함수를 어디서 정의 했는지에 따라 함수의 상위 스코프를 결정한다.<br>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.<br>결국 렉시컬 스코프는 함수가 호출된 위치는 상위 스코프 경정에 어떠한 영향도 주지 않고 함수의 상위 스코프는 언제나 자신이 정의된 스코프다.<br>이처럼 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다. 함수 정의(함수 선언문, 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.</p><h1 id="15-let-const와-블록-레벨-스코프"><a href="#15-let-const와-블록-레벨-스코프" class="headerlink" title="15. let, const와 블록 레벨 스코프"></a>15. let, const와 블록 레벨 스코프</h1><p><code>var</code>키워드의 문제점은 변수의 중복 선언을 허용하고, 함수 레벨 스코프를 지원하고, 변수 호이스팅이 발생하기 때문에 문제가 된다.</p><p>이러한 단점을 보안하기 위해 ES6에서 나온게 <code>let</code>, <code>const</code>키워드다.<br><code>let</code>, <code>const</code>키워드는 중복 선언을 금지하고, 블록 레벨 스코프를 지원한다. 그리고 변수 호이스팅이 발생하지 않는 것 처럼 보이는데, <code>let</code>키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. 이러한 구간을 일시적 사각지대(Temporal Dead Zone, TDZ)라고 부른다.</p><p><code>let</code>키워드는 재할당이 가능하다.<br><code>const</code>키워드는 재할당이 금지된 변수</p><blockquote><p>왜 const는 상수가 아닐까?</p></blockquote><p><code>const</code>키워드로 변수에 객체를 할당하면 객체는 참조되는 값이기 때문에 수정이 가능하다. 재할당이 금지된거지 참조가 금지된게 아니라서 상수라고 표현할 수 없다.</p><p><code>const</code>로 선언하고, 재할당이 필요하다고 인지할 때 <code>let</code>으로 바꾸는 걸 추천. 생각보다 재할당 할 일이 없다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/15/20210315-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 이진수 변환 10829번</title>
      <link>https://juhyeong-k.github.io/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/</guid>
      <pubDate>Sun, 14 Mar 2021 09:13:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;자연수 N이 주어진다. N을 이진수로 바꿔서 출력하는 프로그램을 작성하시오.&lt;/p&gt;
&lt;p&gt;첫째 줄에 자연수 N이 주어진다. (</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>자연수 N이 주어진다. N을 이진수로 바꿔서 출력하는 프로그램을 작성하시오.</p><p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000,000,000,000)</p><p>N을 이진수로 바꿔서 출력한다. 이진수는 0으로 시작하면 안 된다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>문제를 보고 제일 처음 생각난 건 파이썬 내장함수 <code>bin()</code>을 활용하면 바로 풀 수 있겠다는 생각이 들었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 파이썬 내장함수 bin() 활용</span></span><br><span class="line">print(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">input</span>()))[<span class="number">2</span>:])</span><br><span class="line"><span class="comment"># 성공</span></span><br></pre></td></tr></table></figure><p>제출에 통과는 했지만 이렇게 푸는 건 도움이 되지 않는다 생각되어서 다른 방법을 생각해봤다.</p><p>10진수에서 2진수로 변환할 때 보통 소인수분해를 이용해서 구한다. 53을 2로 나눈 값과 나머지를 구하고 나눈 값을 또 다시 나눠서 값과 나머지를 구하고… 이렇게 나눠지지 않을 때 까지 나눈 뒤에 나머지 값들을 역순으로 정렬하면 이진수 값이 나온다. 이 방법 그대로 재귀함수를 사용하면 풀 수 있다고 생각하고 탈출 조건으로 몫이 0일 때 <code>return</code>한다고 하고 pseudo 코드를 작성하고 그 코드로 실행을 해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;out:</span></span><br><span class="line"><span class="string">53</span></span><br><span class="line"><span class="string">TypeError: unsupported operand type(s) for +: &#x27;NoneType&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>예상과 다르게 <code>TypeError</code>가 발생했다. 생각해보니 <code>return</code> 값으로 <code>None</code>이 나오기 때문에 타입이 다른 문자열 타입과 더하지 못했다. <code>return</code> 값으로 타입을 맞추기 위해 빈 문자열(<code>&#39;&#39;</code>)을 주고 다시 실행해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;out:</span></span><br><span class="line"><span class="string">53</span></span><br><span class="line"><span class="string">110101</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>예상대로 출력이 잘 되었고 제출 후 통과했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 이진수 변환 - 10829번</span></span><br><span class="line"><span class="comment"># 첫째 줄에 자연수 N이 주어진다.</span></span><br><span class="line"><span class="comment"># N을 이진수로 바꿔 출력하고</span></span><br><span class="line"><span class="comment"># 이진수는 0으로 시작하면 안된다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이썬 내장함수 bin() 활용</span></span><br><span class="line">print(<span class="built_in">bin</span>(<span class="built_in">int</span>(<span class="built_in">input</span>()))[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - 변수를 사용한 방법</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    remainder = n % <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(remainder)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - 변수를 사용하지 않는 방법</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="built_in">str</span>(n % <span class="number">2</span>)</span><br><span class="line">print(factorization(n))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 소인수 분해 - str대신 f-string으로</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> factorization(n // <span class="number">2</span>) + <span class="string">f&#x27;<span class="subst">&#123;n % <span class="number">2</span>&#125;</span>&#x27;</span></span><br><span class="line">print(factorization(n))</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/14/BAEKJOON-%EC%9D%B4%EC%A7%84%EC%88%98-%EB%B3%80%ED%99%98-10829%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210314 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/14/20210314-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/14/20210314-TIL/</guid>
      <pubDate>Sun, 14 Mar 2021 00:40:08 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS-예습-정리&quot;&gt;&lt;a href=&quot;#JS-예습-정리&quot; class=&quot;headerlink&quot; title=&quot;JS 예습 정리&quot;&gt;&lt;/a&gt;JS 예습 정리&lt;/h1&gt;&lt;h2 id=&quot;12-함수&quot;&gt;&lt;a href=&quot;#12-함수&quot; class=&quot;headerlink</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS-예습-정리"><a href="#JS-예습-정리" class="headerlink" title="JS 예습 정리"></a>JS 예습 정리</h1><h2 id="12-함수"><a href="#12-함수" class="headerlink" title="12. 함수"></a>12. 함수</h2><h3 id="함수란"><a href="#함수란" class="headerlink" title="함수란?"></a>함수란?</h3><p>함수는 일련의 과정을 문(statement)으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.</p><p>함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 함수는 값이며 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.<br>매개변수(parameter)와 인수(argument)를 잘 구별해서 사용하자.</p><h3 id="함수의-사용-이유"><a href="#함수의-사용-이유" class="headerlink" title="함수의 사용 이유"></a>함수의 사용 이유</h3><p>함수는 필요할 때 여러번 호출할 수 있다. 즉, 실행 시점을 개발자가 결정할 수 있고 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 여러번 작성하는 것이 아니라 미리 정의된 함수를 재사용하는 것이 효율적이다. 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용 측면에서 유용하다. 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</p><h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>함수 리터럴은 function 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.<br>함수이름 - 함수 이름은 식별자이기 때문에 식별자 네이밍 규칙을 준수해야 한다. 함수 이름은 생략할 수 있고, 이름이 있는 함수를 기명 함수(named function), 이름이 없는 함수를 무명/익명 함수(anonymous function)라고 한다.</p><blockquote><p>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다?</p></blockquote><p>매개변수 목록 - 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 함수를 호출할 때 각 매개변수에는 지정한 인수가 순서대로 할당된다. 즉, 매개변수 목록은 순서에 의미가 있다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 결국 <strong>매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.</strong></p><p>함수 몸체 - 함수 몸체는 함수 호출에 의해 실행된다.</p><p>리터럴은 값을 생성하기 위한 표기법. 함수 리터럴도 평가되어 값을 생성하고 이 값은 객체다. 함수는 객체다.</p><blockquote><p>함수는 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다?</p></blockquote><h3 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h3><p>함수를 호출하기 전에 인수를 전달받을 매개변수와 실행할 문들, 반환될 값을 지정하는 것을 함수 정의라고 한다. 정의 된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.<br>함수 정의 -&gt; 함수 객체</p><ul><li>함수 선언문(function declaration)</li><li>함수 표현식(function expression)</li><li>Function 생성자 함수(function constructor)</li><li>화살표 함수(arrow funtion) ES6</li></ul><p>선언 vs 정의<br>선언(declaration)과 정의(definition)를 간단히 구분하려면 ‘메모리 주소에 할당하는가?’로 구분할 수 있다. C언어에서 컴파일러를 통해 식별자의 존재만 알리는 거라면 선언한다고 하고, 컴파일러가 변수를 생성해 식별자와 메모리 주소가 연결되면 정의로 구분한다. 자바스크립트에서는 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 이 경계가 모호하다.</p><p>함수 리터럴과 함수 선언문의 차이<br>함수 리터럴과 함수 선언문 동작 방식</p><h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><p>자바스크립트의 함수는 값처럼 변수에 할당할 수 도 있고, 프로퍼티 값이 될 수 도 있다.</p><blockquote><p>함수가 배열의 요소도 될 수 있다?</p></blockquote><p>이처럼 값의 성질을 갖는 객체를 일급 객체(first-cass object)라 한다. 자바스크립트의 함수는 일급 객체다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다.</p><p>함수 선언문과 함수 표현식이 생성되는 시점이 다르다.(호이스팅)</p><p>함수 호이스팅과 변수 호이스팅의 미묘한 차이</p><p>함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅 발생</p><p>함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기 때문에 함수 선언문 대신에 함수 표현식을 사용할 것을 권장한다.</p><h3 id="매개변수와-인수"><a href="#매개변수와-인수" class="headerlink" title="매개변수와 인수"></a>매개변수와 인수</h3><blockquote><p>함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않는다?<br>함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만, 그렇지 않은 겨우에도 에러가 발생하지 않는다. 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 <code>undefined</code>다.</p></blockquote><p>파이썬에서는 매개변수와 인수의 개수가 다르면 에러가 발생하는데… 파이썬의 <code>Asterisk(*)</code>와 비슷한 건가?</p><blockquote><p>자바스크립트에서 초과된 인수는 암묵적으로 argumnets 객체의 프로퍼티로 보관된다?</p></blockquote><p>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다<br>자바스크립트는 동적 타입 언어다. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</p><p>함수 내부에서 적절한 인수가 전달되었는지 확인하더라도 부적절한 호출을 사전에 방지할 수 없고 에러는 런타임에 발생하게 되므로, 타입스크립트와 같은 정적 타입을 선언할 수 있는 자바스크립트의 상위 확장을 도입해서 캄파일 시점에 부적절한 호출을 방지하는 것도 하나의 방법이다.</p><p>인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값을 할당하는 방법도 있다.</p><h3 id="매개변수의-최대-개수"><a href="#매개변수의-최대-개수" class="headerlink" title="매개변수의 최대 개수"></a>매개변수의 최대 개수</h3><p>매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 바뀌므로 함수를 사용하는 코드 전체가 영향을 받기 때문에 유지보수성이 나빠진다. 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.(이상적인 매개변수 개수는 0개이며 적을 수록 좋다)</p><h3 id="반환문"><a href="#반환문" class="headerlink" title="반환문"></a>반환문</h3><p>함수 호출은 표현식이다. 함수 호출 표현식은 <code>return</code> 키워드가 반환한 표현식의 평가 결과, 즉 반환값으로 평가된다.</p><p>반환문의 두 가지 역할</p><ul><li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li><li>반환뮨은 return 키워드 뒤에 오는 표현식을 평가해 반환한다. 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.</li></ul><p>return 키워드와 반환값으로 사용할 표현식 사이에 줄바꿈이 있다면 세미콜론 자동 삽입 기능(ASI)에 의해서 세미콜론이 쿠가되어 의도치 않은 결과가 발생할 수 있다.</p><h3 id="참조에-의한-전달과-외부-상태의-변경"><a href="#참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="참조에 의한 전달과 외부 상태의 변경"></a>참조에 의한 전달과 외부 상태의 변경</h3><p>매개변수에 값을 전달하는 방식으로 원시값은 값의 의한 전달, 객체는 참조에 의한 전달 방식으로 동작한다. 원시 타입의 인수를 전달 받은 매개변수는 변경 불가능한(immutable) 값이기 때문에, 재할당을 통해 새로운 원시값으로 교체하고, 객체 타입의 인수를 전달 받은 매개변수는 변경 가능한(mutable) 값이므로 참조를 통해 원본에 직접 접근해 변경 추가 가능하다.</p><p>이와 같이 객체 타입 인수는 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원복 객체가 변경되는 부수 효과(side effect)가 발생한다. 이렇게 되면 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다. 함수 내부의 동작을 유심히 관찰하지 않으면 외부 상태가 변하는지 아닌지 알기 어렵기 때문이다. 이런 문제를 해결하는 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.</p><p>외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라고 한다. 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.</p><h3 id="즉시-실행-함수"><a href="#즉시-실행-함수" class="headerlink" title="즉시 실행 함수"></a>즉시 실행 함수</h3><p>즉시 실행 함수는 함수 정의와 동시에 즉시 호출되는 함수를 말한다. 즉시 실행 함수는 단 한 번만 호출되고 다시 호출할 수 없다. 즉시 실행 함수는 반드시 그룹 연산자<code>(...)</code>로 감싸야 한다. 자바스크립트 엔진이 암묵적으로 수행하는 ASI에 의해 함수 선언문이 끝나는 위치, 즉 함수 코드 블록의 닫는 중괄호 뒤에 <code>;</code>세미콜론이 암묵적으로 추가되기 때문이다. 그룹 연산자의 피연산자는 값으로 평가되므로 기명, 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 익명 즉시 실행 함수</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="재귀-함수"><a href="#재귀-함수" class="headerlink" title="재귀 함수"></a>재귀 함수</h3><p>함수가 자기 자신을 호출하는 것을 재귀 호출(recursive call)이라 한다. 재귀 함수(recursive function)는 재귀 호출을 수행하는 함수를 말한다.</p><p>재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있고, 이로 인해 스택 오버플로 에러를 발생시킬 수 있으므로 반복문을 사용하는 것 보다 재귀 함수를 사용한는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.</p><h3 id="콜백-함수"><a href="#콜백-함수" class="headerlink" title="콜백 함수"></a>콜백 함수</h3><p>콜백 함수와 고차 함수…</p><h3 id="순수-함수와-비순수-함수"><a href="#순수-함수와-비순수-함수" class="headerlink" title="순수 함수와 비순수 함수"></a>순수 함수와 비순수 함수</h3><p>어떤 외부 상태에 의존, 변경하지 않는, 즉 부수 효과가 없는 함수를 순수 함수(pure function)라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수를 비순수 함수(impure function)라 한다.</p><blockquote><p>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수다? 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 반환값을 만든다. 함수의 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/14/20210314-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210313 TIL - 제어문 문제풀이</title>
      <link>https://juhyeong-k.github.io/2021/03/13/20210313-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/13/20210313-TIL/</guid>
      <pubDate>Sat, 13 Mar 2021 13:28:59 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS-제어문-연습문제&quot;&gt;&lt;a href=&quot;#JS-제어문-연습문제&quot; class=&quot;headerlink&quot; title=&quot;JS 제어문 연습문제&quot;&gt;&lt;/a&gt;JS 제어문 연습문제&lt;/h1&gt;&lt;p&gt;exercise 1 ~ 10 풀이&lt;/p&gt;
&lt;figure cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS-제어문-연습문제"><a href="#JS-제어문-연습문제" class="headerlink" title="JS 제어문 연습문제"></a>JS 제어문 연습문제</h1><p>exercise 1 ~ 10 풀이</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라.</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span> &amp;&amp; x &lt; <span class="number">20</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오.</span></span><br><span class="line"><span class="comment">// 변수 하나에 짝수를 계속 더해주는데, 문자열로 바꿔서 더한다.</span></span><br><span class="line"><span class="keyword">var</span> even_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        even_str = even_str + (i + <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(even_str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">9</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span>) <span class="built_in">console</span>.log(i);</span><br><span class="line">    i--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    sumOfNum += i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> !== <span class="number">0</span> &amp;&amp; i % <span class="number">3</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        sumOfNum += i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오.</span></span><br><span class="line"><span class="keyword">var</span> sumOfNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span> || i % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        sumOfNum += i</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumOfNum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + j === <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`[ <span class="subst">$&#123;i&#125;</span>, <span class="subst">$&#123;j&#125;</span> ]`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/13/20210313-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210312 TIL - JS 3회차</title>
      <link>https://juhyeong-k.github.io/2021/03/12/20210312-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/12/20210312-TIL/</guid>
      <pubDate>Fri, 12 Mar 2021 06:45:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;8-제어문&quot;&gt;&lt;a href=&quot;#8-제어문&quot; class=&quot;headerlink&quot; title=&quot;8. 제어문&quot;&gt;&lt;/a&gt;8. 제어문&lt;/h1&gt;&lt;h3 id=&quot;블록문-block-statement-compound-statement&quot;&gt;&lt;a href=&quot;#블</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="8-제어문"><a href="#8-제어문" class="headerlink" title="8. 제어문"></a>8. 제어문</h1><h3 id="블록문-block-statement-compound-statement"><a href="#블록문-block-statement-compound-statement" class="headerlink" title="블록문(block statement/compound statement)"></a>블록문(block statement/compound statement)</h3><p>0 개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부른다. 블록문은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.</p><h3 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h3><p>if..else문</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if문</span></span><br><span class="line"><span class="keyword">if</span> (조건식) &#123;코드블록&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if..else문</span></span><br><span class="line"><span class="keyword">if</span> (조건식) &#123;</span><br><span class="line">  <span class="comment">// 조건식이 참이면 코드블록 실행</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식이 거짓이면 이 코드블록 실행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>조건식 - <code>true</code>,<code>false</code>로 평가되는 표현식<br>만약 조건식이 불린 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 불린 값으로 암묵적 타입변환이 일어난다.</p><p>들여쓰기는 2칸이 일반적이다.(callback hell)</p><h3 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h3><p>for문</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (변수 선언문 또는 할당문; 조건식; 증감식) &#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for문 실행 순서</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">1. i 선언 후 0값 할당</span></span><br><span class="line"><span class="string">2. 조건식 비교(true)</span></span><br><span class="line"><span class="string">3. true값이기 때문에 코드블록 실행</span></span><br><span class="line"><span class="string">4. 증감식에 의해 i값 +1(i=1)</span></span><br><span class="line"><span class="string">5. 조건식 비교(true)</span></span><br><span class="line"><span class="string">6. true값이기 때문에 코드블록 실행</span></span><br><span class="line"><span class="string">7. 증감식에 의해 i값 +1(i=2)</span></span><br><span class="line"><span class="string">8. 조건식 비교(false)</span></span><br><span class="line"><span class="string">9. false이므로 for 문의 실행 종료</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>while문</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (조건식) &#123;</span><br><span class="line">  조건식이 참이면 반복 실행될 문;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 무한루프</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// count가 3이면 코드 블록 탈출</span></span><br><span class="line">  <span class="keyword">if</span> (count === <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">// 0 1 2</span></span><br></pre></td></tr></table></figure><p>break - 코드블록 탈출<br>많은 횟수를 반복하게 되면 stackoverflow 에러가 발생한다고 한다.</p><p>for문은 몇 번 반복해야 되는지 알 때, while문은 몇 번 반복해야 되는지 모를 때 사용한다.</p><h1 id="9-타입-변환과-단축-평가"><a href="#9-타입-변환과-단축-평가" class="headerlink" title="9. 타입 변환과 단축 평가"></a>9. 타입 변환과 단축 평가</h1><h3 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h3><p>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit coercion)이라 하고 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것을 암묵적 타입 변환(implicit coercion)이라고 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 명시적 타입 변환</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 암묵적 타입 변환</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = y + <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str, str); <span class="comment">// string 10</span></span><br></pre></td></tr></table></figure><p>숫자 타입은 연산 목적, 문자 타입은 표시 목적, 타입마다 사용하려고 하는 의미가 다르다.</p><p>문자열 연결 연산자에서 암묵적 타입 변환이 일어났더라도 변수에 부수 효과(side effect)가 생기지 않는다. (한 번 쓰고 버린다)</p><p>자바스크립트 엔진은 불린 타입이 아닌 값을 Truthy 값(참) 또는 Falsy 값(거짓)으로 구분한다.<br>Falsy 값으로는</p><ul><li>false</li><li>undefined</li><li>null</li><li>0, -0</li><li>NaN</li><li>‘’(빈 문자열)<br>나머지는 Truthy 값이다.</li></ul><p><code>null</code>과 <code>undefined</code>는 둘 다 Falsy 값이지만, <code>null</code>은 숫자로 타입 변환하면 0이지만, <code>undefined</code>는 <code>NaN</code>이다.</p><p>암묵적 타입 변환을 보면 사용하지 않을 것 같지만, 실제로 암묵적 타입 변환을 이용해서 명시적 타입으로 변환하는 경우가 많다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 문자열</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 숫자</span></span><br><span class="line">+<span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불린</span></span><br><span class="line">!<span class="string">&#x27;0&#x27;</span> / !!<span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h3><p>논리 연산자를 사용한 단축 평가로 논리합(<code>||</code>)연산자와 논리곱(<code>&amp;&amp;</code>)연산자가 사용된다. 논리합, 논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.</p><p>논리곱(<code>&amp;&amp;</code>)연산자는 두 개의 피연산자 모두 true로 평가 될 때 true를 반환한다. 먼저 오는 피연산자가 true로 평가된다면, 뒤에 오는 피연산자에 의해 결정이 되기 때문에 뒤에 오는 피연산자가 반환된다.<br>논리합(<code>||</code>)연산자는 두 개의 피연산자 중 하나만 true로 평가되어도 true를 반환하기 때문에, 먼저오는 피연산자가 true로 평가되면, 먼저 오는 피연산자가 반환되고, 먼저 오는 피연산자가 false, 뒤에 오는 피연산자가 true라면 뒤에 오는 피연산자가 반환된다.</p><p>이처럼 논리곱(<code>&amp;&amp;</code>)연산자와 논리합(<code>||</code>)연산자는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 피연산자의 값 그대로 반환한다. 이를 단축 평가(short-circuit evaluation)라 한다.<br>단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 논리합(||)</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Cat</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Dog</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> || <span class="literal">false</span>  <span class="comment">// Cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;)</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// Dog</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">&#x27;Dog&#x27;</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;Cat&#x27;</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>단축 평가를 사용하면 if문을 대체할 수 있다. 어떤 조건이 Truthy값일 때 무언가를 해야 한다면 논리곱(<code>&amp;&amp;</code>)연산자 표현식으로, 조건이 Falsy값일 때 무언가를 해야 한다면 논리합(<code>||</code>)연산자 표현식으로 if문을 대체할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 조건이 true일 때</span></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">// done이 true라면 message에 &#x27;완료&#x27;를 할당</span></span><br><span class="line">message = done &amp;&amp; <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 주어진 조건이 false일 때</span></span><br><span class="line"><span class="keyword">if</span> (!done) message = <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if 문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">// done이 false라면 message에 &#x27;미완료&#x27;를 할당</span></span><br><span class="line">message = done || <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 미완료</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문</span></span><br><span class="line"><span class="keyword">if</span> (done) message = <span class="string">&#x27;완료&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>      message = <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if...else 문은 삼항 조건 연산자로 대체 가능하다.</span></span><br><span class="line">message = done ? <span class="string">&#x27;완료&#x27;</span> : <span class="string">&#x27;미완료&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// 완료</span></span><br></pre></td></tr></table></figure><h1 id="10-객체-리터럴"><a href="#10-객체-리터럴" class="headerlink" title="10. 객체 리터럴"></a>10. 객체 리터럴</h1><p>다른 언어들이 클래스 기반의 객체 지향 언어라면, 자바스크립트는 프로토 타입 기반의 객체 지향 언어다.<br>인스턴스 - class로 뽑아낸 메모리 상에 존재하는 실체</p><p>JS의 장점 - 문자열, 객체 리터럴(class기반 언어보다 훨씬 낫다. 왜?)</p><p>리터럴 - 값을 만들어 내는 표기법</p><p>객체 리터럴({}) - 클래스가 없는 객체, 코드블럭과 햇갈리면 안된다.</p><p>우리가 관심이 있는 것을 추상화 해서 나열한 것을 객체라고 한다.<br>비슷한 것들을 묶어 하나로 표현한게 객체다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&#x27;Kim&#x27;</span>; <span class="comment">// 프로퍼티 값의 갱신</span></span><br><span class="line">person.location <span class="comment">// undefined</span></span><br><span class="line">person.location = <span class="string">&#x27;INCHEON&#x27;</span> <span class="comment">// 프로퍼티의 동적 추가</span></span><br><span class="line"></span><br><span class="line">consoel.log(person.age); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p><code>.</code> - 프로퍼티 접근 연산자(마침표 표기법)<br>자바스크립트는 인스턴스가 만들어진 이후에도 프로퍼티를 갱신하고 추가할 수 있다.(프로퍼티 동적 추가)<br>자바스크립트 객체의 프로퍼티 값은 값으로 평가될 수 있는 모든 것이 올 수 있다. 함수도 값으로 평가되기 때문에 올 수 있다.</p><p><code>delete</code>명령으로 프로퍼티를 삭제할 수 있지만, 굳이 지울 필요는 없는 것 같다.(Anti-pattern)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello! <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 이후 부터 </span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello! <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>this.name</code> - 자신의 프로퍼티에 접근하려면 <code>this</code>로 표현</p><p>프로퍼티 키는 문법적으로 식별자는 아니지만, 식별자의 의미를 갖고 있다. 식별자 명령 규칙에 맞는 프로퍼티 키라면 따옴표 생략이 가능하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;JH&#x27;</span>, <span class="comment">// 식별자 명령 규칙을 따랐기 때문에 따옴표 생략 가능</span></span><br><span class="line">  <span class="string">&#x27;last-name&#x27;</span>: <span class="string">&#x27;Kim&#x27;</span> <span class="comment">// 식별자 명령 규칙에 위배되기 때문에 따옴표로 감싸서 문자열로 만들어줌</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName) <span class="comment">// JH</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;firstName&#x27;</span>]) <span class="comment">// JH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;last-name&#x27;</span>]) <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure><p>불편한 대괄호 표기법 사용보다 네이밍 규칙을 지켜서 마침표 표기법을 사용하는게 편하다.<br>예외 경우가 있는데, 숫자가 프로퍼티 키로 온다면 유사 배열 객체로 사용 가능</p><p>메소드 - 프로퍼티 값이 함수로 표현된 프로퍼티를 메소드라고 부른다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>; <span class="comment">// Anti-pattern</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y; y</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><h1 id="11-원시값과-객체의-비교"><a href="#11-원시값과-객체의-비교" class="headerlink" title="11. 원시값과 객체의 비교"></a>11. 원시값과 객체의 비교</h1><p>자바스크립트에서 제공하는 7가지 데이터 타입은 크게 원시 타입(primitive type)과 객체(object / reference type)타입 으로 구분할 수 있다.</p><h3 id="원시값"><a href="#원시값" class="headerlink" title="원시값"></a>원시값</h3><p>원시 타입 - 변경 불가능한 값(immutable value), 한번 생성된 원시값은 읽기 전용값으로 변경할 수 없다.<br>원시 값을 변경할 수 없는 것이지, 변수 값을 변경할 수 없는 건 아니다. 변수는 언제든지 재할당을 통해 교체할 수 있다.</p><p>문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 접근할 수 있다.<br>유사 배열 객체(array-like object) - 배열처럼 인덱스 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.</p><p>값에 의한 전달(Pass by vlaue)<br>원시값을 갖는 변수를 다른 변수에 할당 했을 때, 같은 주소를 가리키는게 아닌 새로운 주소로 원시값이 할당되고 그 주소를 가리키기 때문에, 두 개의 변수의 값은 서로 영향을 끼치지 않는다.</p><p>정확히 표현하면 값에 의한 전달은 값을 전달하는게 아닌 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.</p><h3 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h3><p>변수에 객체를 할당하게 되면 객체가 값으로 할당되는게 아닌, 객체를 값으로 갖고 있는 메모리 주소를 변수의 값으로 갖게 되고, 그 메모리 주소를 참조해서 접근할 수 있다.</p><p>객체의 메모리 주소값이 변수의 값이고, 그 값은 원시값이기 때문에, 해당 변수를 다른 변수에 할당 한다면, 객체가 아닌 객체의 메모리 주소가 복사되어서 결국 두 개의 변수가 하나의 객체를 참조하게 되고, 하나의 객체에 변경이 생기면 양쪽의 변수에 영향을 끼치게 된다.</p><p>값을 할당했을 때 메모리 주소가 바뀌냐 안 바뀌냐에 따라 immutable vlaue, mutable value로 나뉘게 된다.</p><p>객체는 메모리 뒷 공간에 여유를 갖고 있는 힙에 저장이 되고, 스택은 확정된 메모리 공간으로 공간 없이 쌓이기 때문에 원시값 같은 값들이 들어갈 수 있다.</p><blockquote><p>만약 100개의 변수가 하나의 객체를 참조한다면, 어느 변수가 객체의 변경을 만들어 냈는지 확인하기 힘들텐데, 이런 부작용을 생각을 못했던 걸까? 도대체 왜 객체를 이렇게 만들었을까?</p></blockquote><p>우선 객체는 메모리 크기가 정해져 있지 않아서 사이즈 값이 클 때, 원시값으로 복사된다면 메모리가 감당하기 힘들고 원시값이 하는 일의 수십배 가까운 힘이 들기 때문에 하나의 값을 참조해서 효율을 높혔다.</p><p>객체를 원시값으로 만들면 좋았지만 옛날에는 메모리가 KB단위였고, 메모리도 비쌌기 때문에 눈물을 머금고 독특한 동작으로 만들었을 뿐이라고 한다. 현대에 와서는 메모리가 GB단위로 메모리에 큰 부담이 없어서 객체를 원시값으로 바꾸려는 움직임도 있다고 한다.(메모리보단 퍼포먼스)</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/12/20210312-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210311 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/</guid>
      <pubDate>Thu, 11 Mar 2021 01:35:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;javaScript chap.9 ~ 11 예습&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;d</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>javaScript chap.9 ~ 11 예습</del></li><li><del>JS 용어 정리</del></li></ul><h1 id="JS-예습-내용"><a href="#JS-예습-내용" class="headerlink" title="JS 예습 내용"></a>JS 예습 내용</h1><h2 id="9-타입-변환과-단축-평가"><a href="#9-타입-변환과-단축-평가" class="headerlink" title="9. 타입 변환과 단축 평가"></a>9. 타입 변환과 단축 평가</h2><p>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit coercion) 또는 타입 캐스팅(type casting)이라 한다.</p><p>의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환 되는 것을 암묵적 타입 변환(implicit coercion)또는 타입 강제 변환(type coercion)이라고 한다.</p><p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불린과 같은 원시 타입 중 하나로 타입을 자동 변환한다.</p><p>템플릿 리터럴의 표현식 삽입(<code>&#39;$&#123;1 + 1&#125;&#39;</code>)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>비교 연산자의 역할은 불린 값을 만드는 것이다. 비교 연산자는 피연산자의 크기를 비교해야 하므로 문맥상 모두 숫자 타입이어야 한다. 자바스크립트 엔진은 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">&#x27;&#x27;</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="string">&#x27;1&#x27;</span> <span class="comment">// 1</span></span><br><span class="line">+<span class="string">&#x27;string&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+ture <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">null</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>+</code>단항 연산자는 피연산자가 숫자 타입이 아닐 경우 숫자 타입으로 암묵적 타입 변환을 수행한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>)    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)     <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;str&#x27;</span>) <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><p>제어문(if, for) 또는 삼항 조건 연산자의 조건식은 불린 값으로 평가되어야 하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불린 타입으로 암묵적 타입 변환한다.<br>이때 자바스크립트 엔진은 불린 타입이 아닌 값을 Truthy 값, Falsy 값으로 구분한다. Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.<br>Falsy 값으로는,</p><ul><li>flase</li><li>undefined</li><li>null</li><li>0, -0</li><li>NaN</li><li>‘’(빈 문자열)<br>논리합 연산자(<code>||</code>)와 논리곱 연산자(<code>&amp;&amp;</code>) 표현식의 평가 결과는 불린 값이 아닐 수도 있다.<br>2개의 피 연산자 중 어느 한쪽으로 평가된다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &amp;&amp; <span class="string">&#x27;dog&#x27;</span> <span class="comment">// dog</span></span><br></pre></td></tr></table></figure>논리곱 연산자(<code>&amp;&amp;</code>)는 두번 째 피연산자의 결과를 그대로 반환한다.<br>단축 평가(short-circuit evaluation)는 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것이다.<blockquote><p>논리 연산자의 결과로 불린 값을 반환하는게 아닌 피연산자의 값을 반환할까?</p></blockquote></li></ul><p>단축 평가를 사용해서 if문을, 삼항 조건 연산자는 if..else문을 대체할 수 있다.</p><p>옵셔널 체이닝 연산자(<code>?.</code>) - 좌항의 피연산자가 <code>null</code>또는<code>undefined</code>인 경우 <code>undefined</code>를 반환, 그렇지 않으면 우항의 프로퍼티 참조</p><p>null 병합 연산자(<code>??</code>) - 좌항의 피연산자가<code>null</code>또는<code>undefined</code>인 경우 우항의 피연산자 반환, 그렇지 않으면 좌항의 피연산자 반환</p><h3 id="10-객체-리터럴"><a href="#10-객체-리터럴" class="headerlink" title="10. 객체 리터럴"></a>10. 객체 리터럴</h3><p>객체는 프로퍼티와 메소드의 집합이다.</p><ul><li>프로퍼티(property): 객체의 상태를 나타내는 값(data), 키(key)와 값(vlaue)로 구성<br>키(key): 빈 문자열을 포함하는 모든 문자열 또는 심벌 값, 네이밍 규칙을 따르는 이름을 권장 따르지 않을 경우 반드시 따옴표를 사용해야 한다.<br>값(value): 자바스크립트에서 사용할 수 있는 모든 값</li><li>메소드(method): 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior), 객체에 묶여있는 함수<br>객체는 상태와 동작을 하나의 단위로 구조화할 수 있어서 유용하다.(프로퍼티+메소드)</li></ul><p>객체 리터럴 - 객체를 생성하기 위한 표기법<br>중괄호({..})내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크팁트 엔진은 객체 리터럴을 해석해 객체를 생성한다.</p><p>프로퍼티 접근 방법</p><ul><li>마침표 표기법(dot notation)<br>마침표 프로퍼티 접근 연산자(<code>.</code>)</li><li>대괄호 표기법(bracket notation)<br>대괄호 프로퍼티 접근 연산자(<code>[...]</code>) 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 그렇지 않은 경우 자바스크립트 엔진은 식별자로 해석한다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[name]); <span class="comment">// ReferenceError: name is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하지만, 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문에 ReferenceError라고 하는데, 왜 찾지 못했다고 했을까? 프로퍼티 키와 식별자의 차이를 알아야할 것 같다.</li></ul><p>프로퍼티 축약 표현</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 축약 표현</span></span><br><span class="line"><span class="keyword">var</span> objects = &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objects); <span class="comment">// &#123;x: 1, t: 2&#125;</span></span><br></pre></td></tr></table></figure><p>계산된 프로퍼티 이름 - 문자 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 평가식을 사용해서 프로퍼티 키를 동적으로 생성할 수 있다. 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>`</span>-$&#123;++i&#125;<span class="string">`]: i,</span></span><br><span class="line"><span class="string">    [`</span>$&#123;prefix&#125;<span class="string">`-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>`</span>-$&#123;++i&#125;<span class="string">`]: i</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(obj); // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="11-원시값과-객체의-비교"><a href="#11-원시값과-객체의-비교" class="headerlink" title="11. 원시값과 객체의 비교"></a>11. 원시값과 객체의 비교</h3><p>원시 타입(primitive type)의 값은 변경 불가능한 값(immutable value)이다. 한 번 생성 된 원시값은 읽기 전용(read only)값으로 변경할 수 없다. 즉, 변수 값이 아닌, 원시값 자체를 변경할 수 없다는 뜻<br>변수 값은 재할당을 통해 변경(교체)가능하다.</p><hr><h2 id="JS-2회차-용어-정리"><a href="#JS-2회차-용어-정리" class="headerlink" title="JS 2회차 용어 정리"></a>JS 2회차 용어 정리</h2><ul><li><p>부동소수점<br>컴퓨터는 숫자를 표현할 때 2진수를 사용하는데, 소수점 자리를 2진수로 표현하지 못하는 소수가 있다. 그래서 가장 근사치의 값을 저장하게 되는데, 그 방법이 두 가지가 있다. 하나는 고정 소수점 방식, 다른 하나는 부동 소수점 방식이다. 고정 소수점 방식을 사용하게 되면 표현할 수 있는 범위가 매우 적다. 그래서 대부분 부동 소수점 방식으로 많이 표현한다.  부동 소수점 방식은 하나의 실수를 가수부와 지수부로 나누어 표현한다. 부동 소수점 방식을 사용해도 항상 실수 의 표현은 오차가 존재한다. 그래서 언제나 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐이라는 것을 알아야 한다.</p></li><li><p>네이밍 컨벤션<br>하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한 눈에 구분하기 위해 규정한 규칙이다. 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다. 이 외에도 스네이크 케이스, 케밥 케이스, 헝가리안 케이스 가 있다.</p></li><li><p>예약어<br>프로그램을 작성하는데 필요한 명령문, 자료형 등 미리 컴퓨터가 지정해둔 명칭, 식별자로 사용 불가능하다.</p></li><li><p>키워드<br>언어에서 특별한 의미를 가지는 단어, 문법의 일부를 의미한다. 구문 분석의 대상이다.<br><del>예약어와 키워드를 같다고 생각하기 쉬운데, 예를 들면 <code>var</code>는 특별한 의미를 가지기 때문에 키워드이지만, 식별자로 사용할 수 있기 때문에 예약어는 아니다.</del> 아직 잘 모르겠다.</p></li><li><p>표현식(expression)<br>값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 즉, 값으로 평가되는 문은 모두 표현식이다.</p></li><li><p>문(statement)<br>프로그램을 구성하는 기본 단위 이자 최소 실행 단위. 문의 집합으로 이뤄진게 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.</p></li><li><p>토큰(token)<br>토큰은 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</p></li><li><p>세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)<br>자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 ASI 기능이 암묵적으로 수행된다.</p></li><li><p>표현식인 문과 표현식이 아닌 문<br>구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식인 문은 값으로 평가되어서 변수에 할당할 수 있지만, 표현식이 아닌 문은 값으로 평가할 수 어서 변수에 할당하면 에러가 발생한다.</p></li><li><p>완료 값(completion value)<br>크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined가 출력되는데, 이를 완료 값이라고 한다. 완료 값은 표현식의 평가 결과가 아니기 때문에, 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.</p></li><li><p>템플릿 리터럴(template literal)<br>ES6부터 도입된 문자열 표기법이다. 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 백틱을 사용해 표현한다.</p></li><li><p>멀티라인 문자열(multi-line string)<br>일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않아서 공백(white space)을 표현하려면 백슬래시(<code>\</code>)로 시작하는 이스케이프 시퀀스(escape sequence)를 사용해야 했지만, 템플릿 리터럴에서는 표현이 가능하다.</p></li><li><p>문자열 연산자<br><code>+</code>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고 나머지 경우는 덧셈 연산자로 동작한다.</p></li><li><p>표현식 삽입(expression interpolation)<br><code>$&#123;..&#125;</code> 중괄호 안에 표현식을 넣어서 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210310 TIL - JS 2회차</title>
      <link>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/</guid>
      <pubDate>Wed, 10 Mar 2021 03:54:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS-수업-내용-정리&quot;&gt;&lt;a href=&quot;#JS-수업-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;JS 수업 내용 정리&quot;&gt;&lt;/a&gt;JS 수업 내용 정리&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;식별자 네이밍 규칙&lt;br&gt;변수는 (스코프 안에서) </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS-수업-내용-정리"><a href="#JS-수업-내용-정리" class="headerlink" title="JS 수업 내용 정리"></a>JS 수업 내용 정리</h1><ul><li>식별자 네이밍 규칙<br>변수는 (스코프 안에서) 고유한 이름을 가지고 있어야 한다.<br>식별자는 문자, 숫자, 언더스코어(_), 달러 기호($)만 포함 가능<br>숫자로 시작하는 것은 허용x<br>예약어(<code>const</code>,<code>var</code>)를 식별자로 사용할 수 없다.</li></ul><p>식별자로 쓸 수 있는 이름 유효한 언어</p><p>유니코드 문자도 가능하지만 권장하지 않는다.</p><p>자바스크립트는 대소문자를 구별한다.</p><p>변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.(지키기 어렵지만 지키도록 노력해야함)</p><p>네이밍 컨벤션(naming convention) - 개발자들끼리의 약속<br>네이밍 컨벤션은 정말 꼭 지켜야 한다. 별거 아닌 거라고 생각해서는 안된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 카멜 케이스(camelCase) - 일반적으로 많이 사용(변수, 함수)</span></span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"><span class="comment">// 스네이크 케이스(snake_case) - </span></span><br><span class="line"><span class="keyword">var</span> first_name;</span><br><span class="line"><span class="comment">// 파스칼 케이스(PascalCase) - 일반적으로 많이 사용(생성자 이름, 클래스 이름)</span></span><br><span class="line"><span class="keyword">var</span> FirstName;</span><br></pre></td></tr></table></figure><p>쉽게 가리키는 건 없다. 어려운 걸 안 가리킬 뿐</p><p>값 - 메모리 공간 안에 있는 알맹이<br>표현식 - 값으로 평가되는 문<br>문 - 프로그램을 구성하는 최소 실행 단위<br>ex) 세미콜론으로 끝나는 단위</p><p>문을 기준을 보면 토큰</p><h1 id="6-데이터-타입"><a href="#6-데이터-타입" class="headerlink" title="6. 데이터 타입"></a>6. 데이터 타입</h1><ul><li>원시 타입(primitive type)<br>기본 자료형 이라고도 부른다.</li></ul><p>실수는 약간의 데이터 손실이 있을 수 있다.<br>0.1 + 0.2 = 0.3000000000004<br>부동소수점 방식으로 관리<br>.앞과 뒤를 따로 관리</p><p>문자 - 한 문자<br>문자열 - 여러 개의 문자(다른 언어에서는 객체로 관리하는데 JS에서는 원시 타입으로 관리)<br>undefined - <strong><code>var</code> 키워드</strong>로 선언된 변수에 암묵적으로 할당되는 값<br>null - 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</p><ul><li>객체 타입<br>object<br>reference tpye</li></ul><h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>숫자 타입 - 모두 실수로 처리된다</p><ul><li>숫자 타입의 특별한 값<br>Infinity - 양의 무한대</li><li>Infinity - 음의 무한대<br>NaN - 산술 연산 불가(not a number) 오류를 내지 않기 위해 만들어진 값<br><code>1 * &#39;a&#39;</code>는 다른 언어에서 오류가 나오지만, JS에서는 <code>NaN</code><br><code>1 * &#39;10&#39;</code>여기서는 문자 ‘10’을 숫자 10으로 바꿔서 결과값으로 숫자 10이 나온다.(숫자 10을 문자로 잘 못 표현했다고 판단)</li></ul><h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>문자열은 따옴표(<code>&#39;&#39;</code>, <code>&quot;&quot;</code>, 백틱)으로 텍스트를 감싼다.<br>일반적으로 작은따옴표(‘’)사용</p><h2 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h2><p>ES6에서 도입된 표기법 - asi때문에 일반 문자열 내에서는 줄바꿈이 안된다.<br>일반 문자열 내에서 줄바꿈을 하려면 이스케이프 시퀀스를 이용 - 불편하기 때문에 ES6에서 템플릿 리터럴이 도입된 것</p><p>asi - 세미콜론 자동 삽입 기능</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Juhyeong&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>);</span><br></pre></td></tr></table></figure><h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ul><li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li><li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li><li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li></ul><h2 id="동적-타이핑"><a href="#동적-타이핑" class="headerlink" title="동적 타이핑"></a>동적 타이핑</h2><p>타입을 신경안쓰기 때문에 사용이 편리하다.<br>타입을 교차하면서 할당을 하다보면, 현재 어떤 값이 들어있는지 파악하기 힘들다. 에러로 이어진다.<br>ex) <code>boolean</code>값이 들어있을 줄 알았는데 <code>number</code>값이 들어가 있었다.<br>가장 좋은 방법은 변수를 재할당 하지 않는다면 햇갈리지 않는다.<br>재할당 하는 건 안 좋은 습관?<br>재할당은 변수를 사용해서 발생한 일. 변수를 안 쓰면?? 그건 불가능. 꼭 필요한 변수만 사용. 필요없는 변수는 빨리 돌아가시게 한다.(스코프) 그러면 실수의 발생이 줄어든다.<br>변수를 사용할 때 이 값을 왜 재사용하는지 한 번 생각해봐야 한다. 이유가 존재하면 사용<br>(6챕터 데이터 타입 - 변수를 사용할 때 주의할 사항을 참조하자)</p><blockquote><p>컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.<br>-마틴 파울러(Martin fowler), “리팩토링”의 저자</p></blockquote><h1 id="7-연산자"><a href="#7-연산자" class="headerlink" title="7. 연산자"></a>7. 연산자</h1><p>Side Effect - 부수 효과(대부분 부정적인 효과)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x++ <span class="comment">// x = x + 1</span></span><br><span class="line"><span class="comment">// 부수 효과가 있기 때문에 안 쓰는게 속 편하다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x == <span class="string">&#x27;1&#x27;</span>) <span class="comment">//true 타입을 먼저 같게 만들고 비교) 동등 비교</span></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="string">&#x27;1&#x27;</span>) / flase(타입 그대로 비교) 일치 비교</span><br><span class="line"></span><br><span class="line"><span class="comment">//자바스크립트에서 if문을 잘 안쓰려고 노력하고 삼항 연산자를 사용하는게..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항 연산자는 표현식이기 때문에 바로 할당이 가능해서 한번 만 할당해도 되지만</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if는 표현식이 아니기 때문에 변수에 바로 할당 못한다. 그래서 할당을 두 번 해야 함</span></span><br><span class="line"><span class="keyword">if</span>..</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>..</span><br></pre></td></tr></table></figure><h1 id="8-제어문"><a href="#8-제어문" class="headerlink" title="8. 제어문"></a>8. 제어문</h1><h2 id="제어문-control-flow-statement"><a href="#제어문-control-flow-statement" class="headerlink" title="제어문(control flow statement)"></a>제어문(control flow statement)</h2><p>제어문은 <code>가독성</code>적인 측면에서 부정적이다. 직관적인 코드의 흐름을 혼란스럽게 만든다. for문 대신에 lmada, if문 대신에 삼항 조건 연산자를 사용해서 대체할 수 있기 때문에 자바스크립트는 제어문은 안 쓸수 있다.</p><h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><p>블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>조건문(conditional statement)은 불린(boolean)값으로 평가될 수 있는 표현식이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식1이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (조건식<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식2가 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 문이 하나뿐이라면 중괄호를 생략할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>)      kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>              kind = <span class="string">&#x27;영&#x27;</span>;</span><br></pre></td></tr></table></figure><p>피연산자는 반드시 값이여야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다. 0이 아닌 모든 숫자는 true 취급한다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">&#x27;양수&#x27;</span> : <span class="string">&#x27;음수&#x27;</span>) : <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure><h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (표현식) &#123;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">1</span>이 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">2</span>가 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 일치하는 표현식을 갖는 <span class="keyword">case</span> 문이 없을 때 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break문을 안쓴다면 폴스루(fall through)가 일어난다.</p><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><p>반복문(loop statement)<br>for문 쓸줄 알아야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210309 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/</guid>
      <pubDate>Tue, 09 Mar 2021 01:10:54 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;JavaScript chap.1 ~ 8 예습&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;de</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>JavaScript chap.1 ~ 8 예습</del></li><li><del>내일 team ruberduck 활동을 위한 JS 용어 정리</del></li></ul><p>ECMA Script - 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정하고, 각 브라우저 제조사는 ECMA Script 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. (자바스크립트의 뼈대(core))</p><h2 id="리터럴-literal-과-표현식-expression-과-문-statement"><a href="#리터럴-literal-과-표현식-expression-과-문-statement" class="headerlink" title="리터럴(literal)과 표현식(expression)과 문(statement)"></a>리터럴(literal)과 표현식(expression)과 문(statement)</h2><p>리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식(notation)</p><p>표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다.(리터럴도 값으로 평가되기 때문에 표현식이다)</p><p>문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되어 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 토큰 - 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</span></span><br><span class="line"><span class="comment">// var, sum, =, 1, +, 2, ; 모두 토큰이다</span></span><br></pre></td></tr></table></figure><p>문의 종료를 나타낼 때 세미콜론을 준다. 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 코드 블록 뒤에 세미콜론을 붙이지 않는다.<br>사실 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 <strong>세미콜론 자동 삽입 기능</strong>이 암묵적을 수행되지만, 세미콜론 자동 삽입 기능과 개발자의 예측이 일치하지 않는 경우도 있기 때문에, 세미콜론을 붙이는 걸 추천한다.</p><p><strong>표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.</strong></p><h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><p>자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)이다. 문자열이 생성되면 그 문자열을 변경할 수 없다.</p><p>일반 문자열(따옴표)과 달리 템플릿 리터럴(백틱) 내에서는 이스케이프 시퀀스(\n, \b 등)를 사용하지 않고도 줄바꿈이 허용되고 모든 공백도 있는 그대로 적용된다.</p><p>표현식 삽입(<code>$&#123;&#125;</code>)은 반드시 템플릿 리터럴 내에서 사용해야 한다. 템플릿 리터럴이 아닌 일반 문자열에서 표현식 삽입은 문자열 취급한다.</p><p><a href="https://mulder21c.github.io/2019/01/30/what-is-cross-browsing/">Cross-Browsing이란?</a></p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 유기농 배추 1012번</title>
      <link>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</guid>
      <pubDate>Mon, 08 Mar 2021 10:51:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.</p><p>(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)</p><p>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.</p><p>예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.</p><p>(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)</p><p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.</p><p>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>처음에 든 생각은 2차원 배열에서 인접해 있는 요소를 어떻게 표현해야될 지 고민이 많았다.<br>알고리즘에 대해서 공부하고 푸는 문제가 아니기 때문에 여러 고민을 해봤다.<br>입력 값으로 받는 배열의 크기 없이, 배추의 갯수만으로 좌표를 받아서 찾아도 문제를 해결할 수 있을 것 같아 설계를 해봤다. 고민을 하다보니 인접해 있는 배추를 찾을 때, 그 인접한 배추도 다시 인접한 배추를 찾아야 된다고 생각해서 재귀함수를 사용하는 방법으로 고민을 해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_cabbage</span>(<span class="params">cabbage_location, cabbage_group, index_tuple</span>):</span></span><br><span class="line">    x, y = index_tuple</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &lt; <span class="number">9</span> <span class="keyword">and</span> (x+<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x+<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x+<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x-<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> (x-<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x-<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x-<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x, y+<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &lt; <span class="number">9</span> <span class="keyword">and</span> (x, y+<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y+<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y+<span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">if</span> (x, y-<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &gt; <span class="number">0</span> <span class="keyword">and</span> (x, y-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y-<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y-<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 탈출 조건...?</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    cabbage_num = <span class="built_in">input</span>().split()[<span class="number">2</span>]</span><br><span class="line">    cabbage_location = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(cabbage_num)):</span><br><span class="line">        x, y = <span class="built_in">input</span>().split()</span><br><span class="line">        cabbage_location.append((x, y))</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(cabbage_location) &gt; <span class="number">0</span>:</span><br><span class="line">        cabbage_group = []</span><br><span class="line">        cabbage_group.append(cabbage_location.pop())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            search_cabbage(cabbage_location, cabbage_group, cabbage_group[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>재귀 함수 탈출 조건을 구현하지 못해서 일단 여기까지 작성해보고 다음에 알고리즘 공부 후 다시 풀어봐야겠다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
