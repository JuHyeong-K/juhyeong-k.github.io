<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JH&#39;s dev blog</title>
    <link>https://juhyeong-k.github.io/</link>
    
    <atom:link href="https://juhyeong-k.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>All about dev</description>
    <pubDate>Thu, 11 Mar 2021 12:47:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>20210311 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/</guid>
      <pubDate>Thu, 11 Mar 2021 01:35:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;~ javaScript chap.9 ~ 11 예습 ~&lt;/li&gt;
&lt;li&gt;JS 용어 정리&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li>~ javaScript chap.9 ~ 11 예습 ~</li><li>JS 용어 정리</li></ul><h1 id="JS-예습-내용"><a href="#JS-예습-내용" class="headerlink" title="JS 예습 내용"></a>JS 예습 내용</h1><h2 id="9-타입-변환과-단축-평가"><a href="#9-타입-변환과-단축-평가" class="headerlink" title="9. 타입 변환과 단축 평가"></a>9. 타입 변환과 단축 평가</h2><p>개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(explicit coercion) 또는 타입 캐스팅(type casting)이라 한다.</p><p>의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환 되는 것을 암묵적 타입 변환(implicit coercion)또는 타입 강제 변환(type coercion)이라고 한다.</p><p>암묵적 타입 변환이 발생하면 문자열, 숫자, 불린과 같은 원시 타입 중 하나로 타입을 자동 변환한다.</p><p>템플릿 리터럴의 표현식 삽입(<code>&#39;$&#123;1 + 1&#125;&#39;</code>)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> &gt; <span class="number">0</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>비교 연산자의 역할은 불린 값을 만드는 것이다. 비교 연산자는 피연산자의 크기를 비교해야 하므로 문맥상 모두 숫자 타입이어야 한다. 자바스크립트 엔진은 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">&#x27;&#x27;</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="string">&#x27;1&#x27;</span> <span class="comment">// 1</span></span><br><span class="line">+<span class="string">&#x27;string&#x27;</span> <span class="comment">// NaN</span></span><br><span class="line">+ture <span class="comment">// 1</span></span><br><span class="line">+<span class="literal">false</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">null</span> <span class="comment">// 0</span></span><br><span class="line">+<span class="literal">undefined</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>+</code>단항 연산자는 피연산자가 숫자 타입이 아닐 경우 숫자 타입으로 암묵적 타입 변환을 수행한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;&#x27;</span>)    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)     <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;str&#x27;</span>) <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)  <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure><p>제어문(if, for) 또는 삼항 조건 연산자의 조건식은 불린 값으로 평가되어야 하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불린 타입으로 암묵적 타입 변환한다.<br>이때 자바스크립트 엔진은 불린 타입이 아닌 값을 Truthy 값, Falsy 값으로 구분한다. Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다.<br>Falsy 값으로는,</p><ul><li>flase</li><li>undefined</li><li>null</li><li>0, -0</li><li>NaN</li><li>‘’(빈 문자열)<br>논리합 연산자(<code>||</code>)와 논리곱 연산자(<code>&amp;&amp;</code>) 표현식의 평가 결과는 불린 값이 아닐 수도 있다.<br>2개의 피 연산자 중 어느 한쪽으로 평가된다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;cat&#x27;</span> &amp;&amp; <span class="string">&#x27;dog&#x27;</span> <span class="comment">// dog</span></span><br></pre></td></tr></table></figure>논리곱 연산자(<code>&amp;&amp;</code>)는 두번 째 피연산자의 결과를 그대로 반환한다.<br>단축 평가(short-circuit evaluation)는 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것이다.<blockquote><p>논리 연산자의 결과로 불린 값을 반환하는게 아닌 피연산자의 값을 반환할까?</p></blockquote></li></ul><p>단축 평가를 사용해서 if문을, 삼항 조건 연산자는 if..else문을 대체할 수 있다.</p><p>옵셔널 체이닝 연산자(<code>?.</code>) - 좌항의 피연산자가 <code>null</code>또는<code>undefined</code>인 경우 <code>undefined</code>를 반환, 그렇지 않으면 우항의 프로퍼티 참조</p><p>null 병합 연산자(<code>??</code>) - 좌항의 피연산자가<code>null</code>또는<code>undefined</code>인 경우 우항의 피연산자 반환, 그렇지 않으면 좌항의 피연산자 반환</p><h3 id="10-객체-리터럴"><a href="#10-객체-리터럴" class="headerlink" title="10. 객체 리터럴"></a>10. 객체 리터럴</h3><p>객체는 프로퍼티와 메소드의 집합이다.</p><ul><li>프로퍼티(property): 객체의 상태를 나타내는 값(data), 키(key)와 값(vlaue)로 구성<br>키(key): 빈 문자열을 포함하는 모든 문자열 또는 심벌 값, 네이밍 규칙을 따르는 이름을 권장 따르지 않을 경우 반드시 따옴표를 사용해야 한다.<br>값(value): 자바스크립트에서 사용할 수 있는 모든 값</li><li>메소드(method): 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior), 객체에 묶여있는 함수<br>객체는 상태와 동작을 하나의 단위로 구조화할 수 있어서 유용하다.(프로퍼티+메소드)</li></ul><p>객체 리터럴 - 객체를 생성하기 위한 표기법<br>중괄호({..})내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 자바스크팁트 엔진은 객체 리터럴을 해석해 객체를 생성한다.</p><p>프로퍼티 접근 방법</p><ul><li>마침표 표기법(dot notation)<br>마침표 프로퍼티 접근 연산자(<code>.</code>)</li><li>대괄호 표기법(bracket notation)<br>대괄호 프로퍼티 접근 연산자(<code>[...]</code>) 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 그렇지 않은 경우 자바스크립트 엔진은 식별자로 해석한다.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[name]); <span class="comment">// ReferenceError: name is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하지만, 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지 못했기 때문에 ReferenceError라고 하는데, 왜 찾지 못했다고 했을까? 프로퍼티 키와 식별자의 차이를 알아야할 것 같다.</li></ul><p>프로퍼티 축약 표현</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: x,</span><br><span class="line">    y: y</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 축약 표현</span></span><br><span class="line"><span class="keyword">var</span> objects = &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objects); <span class="comment">// &#123;x: 1, t: 2&#125;</span></span><br></pre></td></tr></table></figure><p>계산된 프로퍼티 이름 - 문자 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 평가식을 사용해서 프로퍼티 키를 동적으로 생성할 수 있다. 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">&#x27;-&#x27;</span> + ++i] = i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&#x27;prop&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>`</span>-$&#123;++i&#125;<span class="string">`]: i,</span></span><br><span class="line"><span class="string">    [`</span>$&#123;prefix&#125;<span class="string">`-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">    [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>`</span>-$&#123;++i&#125;<span class="string">`]: i</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(obj); // &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure><h3 id="11-원시값과-객체의-비교"><a href="#11-원시값과-객체의-비교" class="headerlink" title="11. 원시값과 객체의 비교"></a>11. 원시값과 객체의 비교</h3><p>원시 타입(primitive type)의 값은 변경 불가능한 값(immutable value)이다. 한 번 생성 된 원시값은 읽기 전용(read only)값으로 변경할 수 없다. 즉, 변수 값이 아닌, 원시값 자체를 변경할 수 없다는 뜻<br>변수 값은 재할당을 통해 변경(교체)가능하다.</p><hr><h2 id="JS-2회차-용어-정리"><a href="#JS-2회차-용어-정리" class="headerlink" title="JS 2회차 용어 정리"></a>JS 2회차 용어 정리</h2><ul><li><p>부동소수점<br>컴퓨터는 숫자를 표현할 때 2진수를 사용하는데, 소수점 자리를 2진수로 표현하지 못하는 소수가 있다. 그래서 가장 근사치의 값을 저장하게 되는데, 그 방법이 두 가지가 있다. 하나는 고정 소수점 방식, 다른 하나는 부동 소수점 방식이다. 고정 소수점 방식을 사용하게 되면 표현할 수 있는 범위가 매우 적다. 그래서 대부분 부동 소수점 방식으로 많이 표현한다.  부동 소수점 방식은 하나의 실수를 가수부와 지수부로 나누어 표현한다. 부동 소수점 방식을 사용해도 항상 실수 의 표현은 오차가 존재한다. 그래서 언제나 컴퓨터에서 실수를 표현하는 방법은 정확한 표현이 아닌 언제나 근사치를 표현할 뿐이라는 것을 알아야 한다.</p></li><li><p>네이밍 컨벤션<br>하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한 눈에 구분하기 위해 규정한 규칙이다. 자바스크립트에서는 일반적으로 변수나 함수의 이름에는 카멜케이스를 사용하고 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다. 이 외에도 스네이크 케이스, 케밥 케이스, 헝가리안 케이스 가 있다.</p></li><li><p>예약어<br>프로그램을 작성하는데 필요한 명령문, 자료형 등 미리 컴퓨터가 지정해둔 명칭, 식별자로 사용 불가능하다.</p></li><li><p>키워드<br>언어에서 특별한 의미를 가지는 단어, 문법의 일부를 의미한다. 구문 분석의 대상이다.<br>예약어와 키워드를 같다고 생각하기 쉬운데, 예를 들면 <code>var</code>는 특별한 의미를 가지기 때문에 키워드이지만, 식별자로 사용할 수 있기 때문에 예약어는 아니다.</p></li><li><p>표현식(expression)<br>값으로 평가될 수 있는 문, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다. 즉, 값으로 평가되는 문은 모두 표현식이다.</p></li><li><p>문(statement)<br>프로그램을 구성하는 기본 단위 이자 최소 실행 단위. 문의 집합으로 이뤄진게 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.</p></li><li><p>토큰(token)<br>토큰은 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.</p></li><li><p>세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)<br>자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 ASI 기능이 암묵적으로 수행된다.</p></li><li><p>표현식인 문과 표현식이 아닌 문<br>구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식인 문은 값으로 평가되어서 변수에 할당할 수 있지만, 표현식이 아닌 문은 값으로 평가할 수 어서 변수에 할당하면 에러가 발생한다.</p></li><li><p>완료 값(completion value)<br>크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined가 출력되는데, 이를 완료 값이라고 한다. 완료 값은 표현식의 평가 결과가 아니기 때문에, 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.</p></li><li><p>템플릿 리터럴(template literal)<br>ES6부터 도입된 문자열 표기법이다. 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 백틱을 사용해 표현한다.</p></li><li><p>멀티라인 문자열(multi-line string)<br>일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않아서 공백(white space)을 표현하려면 백슬래시(<code>\</code>)로 시작하는 이스케이프 시퀀스(escape sequence)를 사용해야 했지만, 템플릿 리터럴에서는 표현이 가능하다.</p></li><li><p>문자열 연산자<br><code>+</code>연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고 나머지 경우는 덧셈 연산자로 동작한다.</p></li><li><p>표현식 삽입(expression interpolation)<br><code>$&#123;..&#125;</code> 중괄호 안에 표현식을 넣어서 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다.</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/11/20210311-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210310 TIL - JS 2회차</title>
      <link>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/</guid>
      <pubDate>Wed, 10 Mar 2021 03:54:01 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;JS-수업-내용-정리&quot;&gt;&lt;a href=&quot;#JS-수업-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;JS 수업 내용 정리&quot;&gt;&lt;/a&gt;JS 수업 내용 정리&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;식별자 네이밍 규칙&lt;br&gt;변수는 (스코프 안에서) </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="JS-수업-내용-정리"><a href="#JS-수업-내용-정리" class="headerlink" title="JS 수업 내용 정리"></a>JS 수업 내용 정리</h1><ul><li>식별자 네이밍 규칙<br>변수는 (스코프 안에서) 고유한 이름을 가지고 있어야 한다.<br>식별자는 문자, 숫자, 언더스코어(_), 달러 기호($)만 포함 가능<br>숫자로 시작하는 것은 허용x<br>예약어(<code>const</code>,<code>var</code>)를 식별자로 사용할 수 없다.</li></ul><p>식별자로 쓸 수 있는 이름 유효한 언어</p><p>유니코드 문자도 가능하지만 권장하지 않는다.</p><p>자바스크립트는 대소문자를 구별한다.</p><p>변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.(지키기 어렵지만 지키도록 노력해야함)</p><p>네이밍 컨벤션(naming convention) - 개발자들끼리의 약속<br>네이밍 컨벤션은 정말 꼭 지켜야 한다. 별거 아닌 거라고 생각해서는 안된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 카멜 케이스(camelCase) - 일반적으로 많이 사용(변수, 함수)</span></span><br><span class="line"><span class="keyword">var</span> firstName;</span><br><span class="line"><span class="comment">// 스네이크 케이스(snake_case) - </span></span><br><span class="line"><span class="keyword">var</span> first_name;</span><br><span class="line"><span class="comment">// 파스칼 케이스(PascalCase) - 일반적으로 많이 사용(생성자 이름, 클래스 이름)</span></span><br><span class="line"><span class="keyword">var</span> FirstName;</span><br></pre></td></tr></table></figure><p>쉽게 가리키는 건 없다. 어려운 걸 안 가리킬 뿐</p><p>값 - 메모리 공간 안에 있는 알맹이<br>표현식 - 값으로 평가되는 문<br>문 - 프로그램을 구성하는 최소 실행 단위<br>ex) 세미콜론으로 끝나는 단위</p><p>문을 기준을 보면 토큰</p><h1 id="6-데이터-타입"><a href="#6-데이터-타입" class="headerlink" title="6. 데이터 타입"></a>6. 데이터 타입</h1><ul><li>원시 타입(primitive type)<br>기본 자료형 이라고도 부른다.</li></ul><p>실수는 약간의 데이터 손실이 있을 수 있다.<br>0.1 + 0.2 = 0.3000000000004<br>부동소수점 방식으로 관리<br>.앞과 뒤를 따로 관리</p><p>문자 - 한 문자<br>문자열 - 여러 개의 문자(다른 언어에서는 객체로 관리하는데 JS에서는 원시 타입으로 관리)<br>undefined - <strong><code>var</code> 키워드</strong>로 선언된 변수에 암묵적으로 할당되는 값<br>null - 값이 없다는 것을 의도적으로 명시할 때 사용하는 값</p><ul><li>객체 타입<br>object<br>reference tpye</li></ul><h2 id="숫자-타입"><a href="#숫자-타입" class="headerlink" title="숫자 타입"></a>숫자 타입</h2><p>숫자 타입 - 모두 실수로 처리된다</p><ul><li>숫자 타입의 특별한 값<br>Infinity - 양의 무한대</li><li>Infinity - 음의 무한대<br>NaN - 산술 연산 불가(not a number) 오류를 내지 않기 위해 만들어진 값<br><code>1 * &#39;a&#39;</code>는 다른 언어에서 오류가 나오지만, JS에서는 <code>NaN</code><br><code>1 * &#39;10&#39;</code>여기서는 문자 ‘10’을 숫자 10으로 바꿔서 결과값으로 숫자 10이 나온다.(숫자 10을 문자로 잘 못 표현했다고 판단)</li></ul><h2 id="문자열-타입"><a href="#문자열-타입" class="headerlink" title="문자열 타입"></a>문자열 타입</h2><p>문자열은 따옴표(<code>&#39;&#39;</code>, <code>&quot;&quot;</code>, 백틱)으로 텍스트를 감싼다.<br>일반적으로 작은따옴표(‘’)사용</p><h2 id="템플릿-리터럴"><a href="#템플릿-리터럴" class="headerlink" title="템플릿 리터럴"></a>템플릿 리터럴</h2><p>ES6에서 도입된 표기법 - asi때문에 일반 문자열 내에서는 줄바꿈이 안된다.<br>일반 문자열 내에서 줄바꿈을 하려면 이스케이프 시퀀스를 이용 - 불편하기 때문에 ES6에서 템플릿 리터럴이 도입된 것</p><p>asi - 세미콜론 자동 삽입 기능</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="string">&#x27;Juhyeong&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> last = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;My name is &#x27;</span> + first + <span class="string">&#x27; &#x27;</span> + last + <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>.`</span>);</span><br></pre></td></tr></table></figure><h2 id="데이터-타입의-필요성"><a href="#데이터-타입의-필요성" class="headerlink" title="데이터 타입의 필요성"></a>데이터 타입의 필요성</h2><ul><li>값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해</li><li>값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해</li><li>메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해</li></ul><h2 id="동적-타이핑"><a href="#동적-타이핑" class="headerlink" title="동적 타이핑"></a>동적 타이핑</h2><p>타입을 신경안쓰기 때문에 사용이 편리하다.<br>타입을 교차하면서 할당을 하다보면, 현재 어떤 값이 들어있는지 파악하기 힘들다. 에러로 이어진다.<br>ex) <code>boolean</code>값이 들어있을 줄 알았는데 <code>number</code>값이 들어가 있었다.<br>가장 좋은 방법은 변수를 재할당 하지 않는다면 햇갈리지 않는다.<br>재할당 하는 건 안 좋은 습관?<br>재할당은 변수를 사용해서 발생한 일. 변수를 안 쓰면?? 그건 불가능. 꼭 필요한 변수만 사용. 필요없는 변수는 빨리 돌아가시게 한다.(스코프) 그러면 실수의 발생이 줄어든다.<br>변수를 사용할 때 이 값을 왜 재사용하는지 한 번 생각해봐야 한다. 이유가 존재하면 사용<br>(6챕터 데이터 타입 - 변수를 사용할 때 주의할 사항을 참조하자)</p><blockquote><p>컴퓨터가 이해하는 코드는 어떤 바보도 쓸 수 있다. 하지만 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 쓴다.<br>-마틴 파울러(Martin fowler), “리팩토링”의 저자</p></blockquote><h1 id="7-연산자"><a href="#7-연산자" class="headerlink" title="7. 연산자"></a>7. 연산자</h1><p>Side Effect - 부수 효과(대부분 부정적인 효과)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x++ <span class="comment">// x = x + 1</span></span><br><span class="line"><span class="comment">// 부수 효과가 있기 때문에 안 쓰는게 속 편하다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x == <span class="string">&#x27;1&#x27;</span>) <span class="comment">//true 타입을 먼저 같게 만들고 비교) 동등 비교</span></span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="string">&#x27;1&#x27;</span>) / flase(타입 그대로 비교) 일치 비교</span><br><span class="line"></span><br><span class="line"><span class="comment">//자바스크립트에서 if문을 잘 안쓰려고 노력하고 삼항 연산자를 사용하는게..</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항 연산자는 표현식이기 때문에 바로 할당이 가능해서 한번 만 할당해도 되지만</span></span><br><span class="line"><span class="keyword">var</span> result = x % <span class="number">2</span> ? <span class="string">&#x27;홀수&#x27;</span> : <span class="string">&#x27;짝수&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if는 표현식이 아니기 때문에 변수에 바로 할당 못한다. 그래서 할당을 두 번 해야 함</span></span><br><span class="line"><span class="keyword">if</span>..</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>..</span><br></pre></td></tr></table></figure><h1 id="8-제어문"><a href="#8-제어문" class="headerlink" title="8. 제어문"></a>8. 제어문</h1><h2 id="제어문-control-flow-statement"><a href="#제어문-control-flow-statement" class="headerlink" title="제어문(control flow statement)"></a>제어문(control flow statement)</h2><p>제어문은 <code>가독성</code>적인 측면에서 부정적이다. 직관적인 코드의 흐름을 혼란스럽게 만든다. for문 대신에 lmada, if문 대신에 삼항 조건 연산자를 사용해서 대체할 수 있기 때문에 자바스크립트는 제어문은 안 쓸수 있다.</p><h2 id="블록문"><a href="#블록문" class="headerlink" title="블록문"></a>블록문</h2><p>블록문(block statement)은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제어문</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>조건문(conditional statement)은 불린(boolean)값으로 평가될 수 있는 표현식이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식1이 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (조건식<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// 조건식2가 참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 문이 하나뿐이라면 중괄호를 생략할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">0</span>)      kind = <span class="string">&#x27;양수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">0</span>) kind = <span class="string">&#x27;음수&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>              kind = <span class="string">&#x27;영&#x27;</span>;</span><br></pre></td></tr></table></figure><p>피연산자는 반드시 값이여야 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0은 false로 취급된다. 0이 아닌 모든 숫자는 true 취급한다.</span></span><br><span class="line"><span class="keyword">var</span> kind = num ? (num &gt; <span class="number">0</span> ? <span class="string">&#x27;양수&#x27;</span> : <span class="string">&#x27;음수&#x27;</span>) : <span class="string">&#x27;영&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">// 양수</span></span><br></pre></td></tr></table></figure><h3 id="switch-문"><a href="#switch-문" class="headerlink" title="switch 문"></a>switch 문</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (표현식) &#123;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">1</span>이 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">2</span>가 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 일치하는 표현식을 갖는 <span class="keyword">case</span> 문이 없을 때 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break문을 안쓴다면 폴스루(fall through)가 일어난다.</p><h2 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h2><p>반복문(loop statement)<br>for문 쓸줄 알아야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/10/20210310-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210309 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/</guid>
      <pubDate>Tue, 09 Mar 2021 01:10:54 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;JavaScript chap.1 ~ 8 예습&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;de</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>JavaScript chap.1 ~ 8 예습</del></li><li><del>내일 team ruberduck 활동을 위한 JS 용어 정리</del></li></ul><p>ECMA Script - 자바스크립트의 표준 사양인 ECMA-262를 말하며, 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등 핵심 문법을 규정하고, 각 브라우저 제조사는 ECMA Script 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다. (자바스크립트의 뼈대(core))</p><h2 id="리터럴-literal-과-표현식-expression-과-문-statement"><a href="#리터럴-literal-과-표현식-expression-과-문-statement" class="headerlink" title="리터럴(literal)과 표현식(expression)과 문(statement)"></a>리터럴(literal)과 표현식(expression)과 문(statement)</h2><p>리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식(notation)</p><p>표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 표현식이 평가되면 새로운 값을 생성하거나 기존의 값을 참조한다.(리터럴도 값으로 평가되기 때문에 표현식이다)</p><p>문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문은 여러 토큰으로 구성되어 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 토큰 - 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소</span></span><br><span class="line"><span class="comment">// var, sum, =, 1, +, 2, ; 모두 토큰이다</span></span><br></pre></td></tr></table></figure><p>문의 종료를 나타낼 때 세미콜론을 준다. 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문에 코드 블록 뒤에 세미콜론을 붙이지 않는다.<br>사실 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 <strong>세미콜론 자동 삽입 기능</strong>이 암묵적을 수행되지만, 세미콜론 자동 삽입 기능과 개발자의 예측이 일치하지 않는 경우도 있기 때문에, 세미콜론을 붙이는 걸 추천한다.</p><p><strong>표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.</strong></p><h1 id="데이터-타입"><a href="#데이터-타입" class="headerlink" title="데이터 타입"></a>데이터 타입</h1><p>자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값(immutable value)이다. 문자열이 생성되면 그 문자열을 변경할 수 없다.</p><p>일반 문자열(따옴표)과 달리 템플릿 리터럴(백틱) 내에서는 이스케이프 시퀀스(\n, \b 등)를 사용하지 않고도 줄바꿈이 허용되고 모든 공백도 있는 그대로 적용된다.</p><p>표현식 삽입(<code>$&#123;&#125;</code>)은 반드시 템플릿 리터럴 내에서 사용해야 한다. 템플릿 리터럴이 아닌 일반 문자열에서 표현식 삽입은 문자열 취급한다.</p><p><a href="https://mulder21c.github.io/2019/01/30/what-is-cross-browsing/">Cross-Browsing이란?</a></p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/09/20210309-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 유기농 배추 1012번</title>
      <link>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/</guid>
      <pubDate>Mon, 08 Mar 2021 10:51:12 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.</p><p>(한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다)</p><p>한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.</p><p>예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.</p><p>(0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.)</p><p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다.</p><p>각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>처음에 든 생각은 2차원 배열에서 인접해 있는 요소를 어떻게 표현해야될 지 고민이 많았다.<br>알고리즘에 대해서 공부하고 푸는 문제가 아니기 때문에 여러 고민을 해봤다.<br>입력 값으로 받는 배열의 크기 없이, 배추의 갯수만으로 좌표를 받아서 찾아도 문제를 해결할 수 있을 것 같아 설계를 해봤다. 고민을 하다보니 인접해 있는 배추를 찾을 때, 그 인접한 배추도 다시 인접한 배추를 찾아야 된다고 생각해서 재귀함수를 사용하는 방법으로 고민을 해봤다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_cabbage</span>(<span class="params">cabbage_location, cabbage_group, index_tuple</span>):</span></span><br><span class="line">    x, y = index_tuple</span><br><span class="line">    <span class="keyword">if</span> (x+<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &lt; <span class="number">9</span> <span class="keyword">and</span> (x+<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x+<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x+<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x-<span class="number">1</span>, y) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> x &gt; <span class="number">0</span> <span class="keyword">and</span> (x-<span class="number">1</span>, y) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x-<span class="number">1</span>, y))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x-<span class="number">1</span>, y))</span><br><span class="line">    <span class="keyword">if</span> (x, y+<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &lt; <span class="number">9</span> <span class="keyword">and</span> (x, y+<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y+<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y+<span class="number">1</span>))  </span><br><span class="line">    <span class="keyword">if</span> (x, y-<span class="number">1</span>) <span class="keyword">in</span> cabbage_location <span class="keyword">and</span> y &gt; <span class="number">0</span> <span class="keyword">and</span> (x, y-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> cabbage_group:</span><br><span class="line">        cabbage_group.append(cabbage_location.pop(cabbage_location.index((x, y-<span class="number">1</span>))))</span><br><span class="line">        search_cabbage(cabbage_location, cabbage_group, (x, y-<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># 탈출 조건...?</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    cabbage_num = <span class="built_in">input</span>().split()[<span class="number">2</span>]</span><br><span class="line">    cabbage_location = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(cabbage_num)):</span><br><span class="line">        x, y = <span class="built_in">input</span>().split()</span><br><span class="line">        cabbage_location.append((x, y))</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(cabbage_location) &gt; <span class="number">0</span>:</span><br><span class="line">        cabbage_group = []</span><br><span class="line">        cabbage_group.append(cabbage_location.pop())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            search_cabbage(cabbage_location, cabbage_group, cabbage_group[<span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>재귀 함수 탈출 조건을 구현하지 못해서 일단 여기까지 작성해보고 다음에 알고리즘 공부 후 다시 풀어봐야겠다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/08/BAEKJOON-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94-1012%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210308 TIL - JS 1일차</title>
      <link>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/</guid>
      <pubDate>Mon, 08 Mar 2021 01:16:44 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;[BAEKJOON]유기농 양배추 1012번 문제 풀이&lt;/del&gt;&lt;/li&gt;
&lt;l</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>[BAEKJOON]유기농 양배추 1012번 문제 풀이</del></li><li><del>JS 강의 내용 정리</del></li></ul><p>자바스크립트는 애초에 개발자가 아닌 비개발자가 사용할 것이라는 전제 하에 만들어진 언어라서, 오류를<br> 최대한 내지 않기 위해 실수를 해도 알아서 커버해주는 <strong>암묵적인 행동</strong>을 한다.(오류를<br> 내지 않기 때문에 코드를 이해하기 어렵다) 그래서 자바스크립트에서 더욱이 기본 개념과 동작원리를 잘<br> 알아야 한다.</p><h1 id="JS-수업-내용-정리"><a href="#JS-수업-내용-정리" class="headerlink" title="JS 수업 내용 정리"></a>JS 수업 내용 정리</h1><p>수업 중에 나오는 개발 용어를 잘 정리하자</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">20</span></span><br></pre></td></tr></table></figure><p>우리는 <code>10 + 20</code>의 결과를 30이라고 바로 생각해내서 과정이 없는 것 처럼 느껴지지만, 사실 <code>10</code>이라는 문자가 무엇인지, <code>+</code>와 <code>20</code>이 무엇인지 알고 계산하는 과정을 거쳐야 한다.<br>비슷하게 컴퓨터는 <code>10</code>이라는 문자를 보고 <code>parsing</code>을 통해 숫자 <code>10</code>이라는 것을 인지한다. 정확히 말하면 자바스크립트 엔진이 <code>10 + 20</code>을 보고 <code>+</code>연산을 하기 전에 <code>10</code>과 <code>20</code>을 기억하고, <code>+</code>연산을 하게 된다.</p><h2 id="메모리"><a href="#메모리" class="headerlink" title="메모리"></a>메모리</h2><p>메모리는 데이터를 저장할 수 있는 메모리 셀(cell)의 집합체다. 메모리 셀 하나의 크기는 1Byte(8bit)이고, 컴퓨터는 메모리 셀 하나의 크기로 데이터를 저장(write)하거나 읽는다.(read)<br>각 셀은 메모리 공간의 위치를 나타내는 메모리 주소(memory address)를 갖는다. 4GB기준 약 0~43억개의 메모리 주소를 갖는다.</p><p>컴퓨터에서 기억은 메모리가 담당하고, 연산은 CPU가 담당한다.</p><blockquote><p>왜 1Byte의 크기는 5bit, 7bit, 10bit 등의 단위가 아닌 8bit라고 할까?<br>컴퓨터 아키텍처가 영문권인 곳에서 발전했기 때문. 영문권에서 문자를 하나를 표현하는데 7bit ~ 8bit정도면 충분하다.</p></blockquote><p><a href="https://zepeh.tistory.com/313">https://zepeh.tistory.com/313</a></p><p><code>10 + 20</code>의 과정을 살펴보면,<br><code>10</code>을 2진수로 바꿔서 메모리 셀에 저장하는데, OS가 그 역할을 한다. JS엔진이 OS에게 메모리에 저장해달라고 요청을 하면 OS가 빈 위치에 2진수로 변환된 <code>10</code>을 저장한다.<br><code>20</code>도 마찬가지로 2진수로 바꿔서 메모리 셀에 저장된다.<br><code>+</code>연산은 CPU가 담당하는데, 메모리에 저장된 <code>10</code>과<code>20</code>을 CPU에 있는 고속메모리에 잠깐 저장하고, <code>+</code>연산을 해서 나온 결과값을 다시 메모리 셀에 저장하고 고속메모리에 저장된 <code>10</code>과 <code>20</code>은 버려진다.</p><p>여기서 메모리 셀에 <code>30</code>이라는 결과가 저장되었지만, 메모리 주소를 알 수 없기 때문에 재사용할 수 없다.</p><p>만약 메모리 주소를 알고 직접 접근하는 것은 매우 위험하다. 만약 운영체제가 사용하고 있는 값을 변경하게 되면 시스템을 멈추게 하는 치명적인 오류가 발생하고 있기 때문에 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않는다.</p><h2 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h2><p>프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여서 재사용하기 위해 변수라는 메커니즘을 제공한다.</p><p>변수의 정의로는</p><ol><li>하나의 값을 저장하기 위해 확보한 메모리 공간</li><li>메모리 공간을 식별하기 위해 붙인 이름</li></ol><p><code>a = 1</code>을 예시로 보면 <code>1</code>은 하나의 값을 저장하기 위해 메모리에 확보된 값이고, <code>a</code>는 그 공간을 식별하기 위해 붙인 이름이다. 둘 사이의 <code>=</code>가 있기 때문에 두 개의 정의가 나올 수 있다.<br>변수는 하나의 값을 저장하는데, 여러 개의 값을 저장하고 싶다면 객체 같은 자료구조를 사용하면 하나의 그룹으로 저장할 수 있다.</p><p>변수에 값을 저장하는 것을 할당(assignment)한다 하고, 변수에 저장된 값을 일어 들이는 것을 참조(reference)라고 한다.</p><h2 id="식별자"><a href="#식별자" class="headerlink" title="식별자"></a>식별자</h2><p>변수 이름을 식별자(identifier)라고도 한다. 식별자는 어떤 값을 구분해서 식별할 수 있는 고유한 이름을 말하고, 변수 이름 뿐만 아니라 메모리에 중복 없이 접근이 가능한 것들도 식별자라 한다. (함수, 클래스 등)</p><p><strong>식별자는 값이 아니라 메모리 주소를 기억하고 있다.</strong> 식별자가 기억하고 있는 메모리 주소를 통해서 메모리 공간에 저장된 값에 접근할 수 있다.</p><h2 id="변수-선언"><a href="#변수-선언" class="headerlink" title="변수 선언"></a>변수 선언</h2><p>저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비하는 것</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>변수를 선언할 때 <code>var</code>,<code>const</code>,<code>let</code>과 같은 keyword를 사용한다.<br>keyword - 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">10</span> + <span class="number">20</span></span><br><span class="line"><span class="comment">// var -&gt; keyword, result -&gt; 식별자, &#x27;=&#x27; -&gt; 할당 연산자</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score;</span><br></pre></td></tr></table></figure><p>변수를 선언 후 값을 할당하지 않았기 때문에 확보된 메모리 공간은 비어있을 것으로 추측되지만, <strong>확보된 메모리 공간에는 <code>undefined</code>라는 암묵적인 값이 할당 되어 초기화된다.</strong></p><p>메모리 공간은 지운다라는 개념이 없고 덮어씌운다라는 개념이 존재하기 때문에, C언어에서는 변수를 선언 하면서 값을 초기화 해주지 않으면, 그 변수는 예상치 못한 값이 나올 수도 있다.</p><blockquote><p>숫자형은 메모리 공간에 8Byte를 차지하는데, undefined는 얼마를 차지할까?<br>모른다. ES에도 정의가 되어 있지 않다. 결국 브라우저 마다 알아서 정의를 하기 때문에 알 수가 없다.</p></blockquote><h2 id="호이스팅"><a href="#호이스팅" class="headerlink" title="호이스팅"></a>호이스팅</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> score;</span><br></pre></td></tr></table></figure><p>위의 실행 결과로 <code>ReferenceError: score is not defined</code>를 예상할 수 있지만, 결과값으로 <code>undefined</code>가 나오는 것을 확인할 수 있다.<br>자바스크립트는 인터프리터 언어라서 위에서 한 줄씩 읽어나갈텐데, 왜 <code>score</code>변수가 먼저 선언된 것 처럼 보일까?<br>그 이유는 그렇게 만들었기 때문이다. 다시 말하지만 자바스크립트는 애초에 비개발자를 위한 언어로 만들어져서 변수 선언을 뒤에 할 경우 에러가 발생하는 것을 막기 위해<br><strong>자바스크립트의 선언문은 runtime 이전에 먼저 실행된다.</strong><br>이 처럼 변수 선언문이 코드의 선두로 끌어 올려진는 것 처럼 동작하는 자바스크립트의 고유의 특징을 <strong>변수 호이스팅(variable hoisting)</strong>이라 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(score);</span><br><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(score);</span><br></pre></td></tr></table></figure><p>위의 결과로는</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>어떻게 이런 값이 나왔을까? <code>var score = 100;</code>은 <code>shorthand</code>이다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 위와 아래는 동일한 명령</span></span><br><span class="line"><span class="keyword">var</span> score;</span><br><span class="line">score = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>선언문인 <code>var score</code>가 runtime전에 실행되면서 위의 <code>console.log(score)</code>결과로 <code>undefined</code>가 출력되고, 그 다음 순서인 <code>score = 100;</code>이 실행되면서 아래의 <code>console.log(score)</code>의 결과로 <code>100</code>이 출력되는 것이다.</p><p>자바스크립트는 어디서 만들어졌나? 각 브라우저별로 알아서 개발함. 그래서 자바스크립트의 실행 환경은 브라우저마다 다 다르다. 다만, ECMA Script 표준을 지키고 있다.<br>ES는 버전이 ES1부터3, 5부터11까지 있고, 6부터 모던 자바스크립트라고 부를 정도로 5와 6사이에 많은 변화가 있었다. 그 중 대표적으로 ES5에서 변수 선언은 <code>var</code>만 가능했지만, 6에서 <code>let</code>, <code>const</code> 추가 도입됐다.</p><blockquote><p><code>var</code>에 문제가 있어서 <code>let</code>과 <code>const</code>를 도입했는데, 왜 아직까지 <code>var</code>가 사용이 가능할까?<br>자바스크립트는 하위호환성을 유지하기 때문에 <code>var</code> 변수 선언도 지금까지 유지되고 있다.(자바스크립트의 과거 문법도 공부해야 한다)</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/JS/">JS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/08/20210308-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HTML/CSS 강의에 대한 회고</title>
      <link>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/</link>
      <guid>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/</guid>
      <pubDate>Sun, 07 Mar 2021 10:42:24 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;2주 동안 들었던 HTML/CSS 강의 에 대한 회고를 작성해보려고 한다.&lt;/p&gt;
&lt;p&gt;사실 강의를 듣기 전까지, HTML과 CSS에 크게 관심이 없었다. HTML과 CSS를 온라인 강의로 잠깐 접해본 적이 있는데, 그 당시만 해도 이걸 배워서 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>2주 동안 들었던 HTML/CSS 강의 에 대한 회고를 작성해보려고 한다.</p><p>사실 강의를 듣기 전까지, HTML과 CSS에 크게 관심이 없었다. HTML과 CSS를 온라인 강의로 잠깐 접해본 적이 있는데, 그 당시만 해도 이걸 배워서 어떻게 써먹어야될지도 몰랐고 재미도 없어서 그냥 이론만 듣고 말았다. 그래서 이번 HTML/CSS 강의도 그런 내용이겠구나 생각하고 있었다. 첫 날, 둘 째날 강의를 계속 들으면서 HTML이 어떻게 만들어졌고 어떤 역사를 가지고 지금까지 발전을 했는지, HTML을 작성할 때 어떤 흐름으로 작성을 해야되는지 설명을 들으면서 강의 자체에 재미를 붙이게 됐다.</p><p>2주라는 기간 동안 배운 많은 내용들을 내가 전부 흡수하지 못해 아쉬움이 크지만, 이번 강의를 들으면서 내가 HTML을 작성할 때는 어떤 흐름으로 작성을 하고 어떤 부분을 고려해서 작성을 해야되는지 감을 잡는 계기가 됐고, CSS도 배우기 전까지는 정말 어렵다고 생각됐는데, 내가 보여지는 것만 보고 판단을 해서 어렵게 느껴졌었고, 내가 사용한 property들의 목적을 알고 있어야 문제가 생겨도 왜 문제가 생겼는지 원인을 판단할 수 있고, 특히, CSS에서는 본래의 목적으로 사용하는게 아닌, 다른 용도(<del>꼼수</del>)로 사용하는 경우도 많기 때문에 왜 이런 property를 사용하는지 정확하게 알고 있어야 한다는걸 알게 됐다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/Retrospective/">Retrospective</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      <category domain="https://juhyeong-k.github.io/tags/Retrospective/">Retrospective</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/07/HTML-CSS-%EA%B0%95%EC%9D%98%EC%97%90-%EB%8C%80%ED%95%9C-%ED%9A%8C%EA%B3%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210307 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/</guid>
      <pubDate>Sun, 07 Mar 2021 04:39:50 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;오늘-할-일&quot;&gt;&lt;a href=&quot;#오늘-할-일&quot; class=&quot;headerlink&quot; title=&quot;오늘 할 일&quot;&gt;&lt;/a&gt;오늘 할 일&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;del&gt;[BAEKJOON] 국영수 10825번 글 내용 추가(sort, sorted)</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="오늘-할-일"><a href="#오늘-할-일" class="headerlink" title="오늘 할 일"></a>오늘 할 일</h1><ul><li><del>[BAEKJOON] 국영수 10825번 글 내용 추가(sort, sorted)</del></li><li><del>20210304 TIL, 20210303 TIL 수업 내용 정리 추가</del></li><li><del>HTML, CSS 회고 작성</del></li></ul>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/07/20210307-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[BAEKJOON] 국영수 10825번</title>
      <link>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/</link>
      <guid>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/</guid>
      <pubDate>Fri, 05 Mar 2021 03:36:26 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h1&gt;&lt;p&gt;도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h1><p>도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로그램을 작성하시오.</p><p>국어 점수가 감소하는 순서로<br>국어 점수가 같으면 영어 점수가 증가하는 순서로<br>국어 점수와 영어 점수가 같으면 수학 점수가 감소하는 순서로<br>모든 점수가 같으면 이름이 사전 순으로 증가하는 순서로 (단, 아스키 코드에서 대문자는 소문자보다 작으므로 사전순으로 앞에 온다.)</p><p>첫째 줄에 도현이네 반의 학생의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 한 줄에 하나씩 각 학생의 이름, 국어, 영어, 수학 점수가 공백으로 구분해 주어진다. 점수는 1보다 크거나 같고, 100보다 작거나 같은 자연수이다. 이름은 알파벳 대소문자로 이루어진 문자열이고, 길이는 10자리를 넘지 않는다.</p><h1 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h1><p>처음 든 생각은 <code>input()</code>으로 들어오는 값을 어떤 방식으로 저장할지 고민이었다.<br><code>dictionary</code>로 저장할 경우 순서를 구분하기 힘들 것 같고, <code>list</code>로 저장할 경우 <code>key:value</code>를 구분하기 힘들 것 같아서, 그냥 둘 다 써보기로 했다.</p><p>입력받은 이름과 국영수 점수들을 <code>dict</code>에 <code>&#123;name: [국, 영, 수]&#125;</code>형태로 저장하고, list에는<code>[[국, 영,수]]</code> 국영수 점수만 저장했다.</p><p>이제 어떻게 정렬할지 고민을 해봤는데, 쉽게 떠오르지는 않았다.<br><code>input()</code>을 입력 받을 때, <code>current_score</code>라는 이름의 <code>list</code>를 두고 위에 저장된 <code>list</code>의 값과 비교해보기로 했다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">subject_score_dict = &#123;&#125;</span><br><span class="line">subject_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    name, korean_score, english_score, math_score = <span class="built_in">input</span>().split()</span><br><span class="line">    korean_score, english_score, math_score = <span class="built_in">int</span>(korean_score), <span class="built_in">int</span>(english_score), <span class="built_in">int</span>(math_score)</span><br><span class="line">    subject_score_dict[name] = [korean_score, english_score, math_score]</span><br><span class="line">    current_score = [korean_score, english_score, math_score]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subject_score_list) == <span class="number">0</span>:</span><br><span class="line">        subject_score_list.append(current_score)</span><br><span class="line">        print(<span class="string">&#x27;첫 번째 값&#x27;</span>,subject_score_list) <span class="comment">###</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> score_index, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(subject_score_list):</span><br><span class="line">            <span class="comment"># 국어 점수 비교</span></span><br><span class="line">            <span class="keyword">if</span> current_score[<span class="number">0</span>] &gt; score[<span class="number">0</span>]:</span><br><span class="line">                subject_score_list.insert(score_index, current_score)</span><br><span class="line">                print(<span class="string">&#x27;cs[0]&gt;s[0]&#x27;</span>,subject_score_list) <span class="comment">###</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] &lt; score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] == score[<span class="number">0</span>]:</span><br><span class="line">                <span class="comment"># 영어 점수 비교</span></span><br><span class="line">                <span class="keyword">if</span> current_score[<span class="number">1</span>] &lt; score[<span class="number">1</span>]:</span><br><span class="line">                    subject_score_list.insert(score_index, current_score)</span><br><span class="line">                    print(<span class="string">&#x27;cs[1]&lt;s[1]&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] &gt; score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                        subject_score_list.append(current_score)</span><br><span class="line">                        print(<span class="string">&#x27;cs[1]&gt;s[1]이지만, 마지막 요소라서 리스트 맨뒤에 추가&#x27;</span>, subject_score_list)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] == score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 수학 점수 비교</span></span><br><span class="line">                    <span class="keyword">if</span> current_score[<span class="number">2</span>] &gt; score[<span class="number">2</span>]:</span><br><span class="line">                        subject_score_list.insert(score_index, current_score)</span><br><span class="line">                        print(<span class="string">&#x27;cs[2]&gt;s[2]&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] &lt; score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                            subject_score_list.append(current_score)</span><br><span class="line">                            print(<span class="string">&#x27;cs[2]&lt;s[2]이지만, 마지막 요소라서 리스트 맨뒤에 추가&#x27;</span>, subject_score_list)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] == score[<span class="number">2</span>]:</span><br><span class="line">                        print(<span class="string">&#x27;cs[2]==s[2] 중복된 값이라서 추가x&#x27;</span>, subject_score_list) <span class="comment">###</span></span><br><span class="line">                        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>정해진 순서대로 점수들을 배치하고, 중복된 점수들은 value값을 <code>dict</code>에서 찾아서 key값들을 같이 불러올거라서 제외했다.</p><p>이제 국영수 점수가 똑같은 사람들의 이름과 각 점수에 해당하는 사람들의 이름을 불러오면 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 중복되는 값을 제거하고, dict에서 이름 찾을 때, 중복된 값이면 여러개가 저장될 텐데 거기서 네임 정렬 후 출력해주면 될 듯</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> subject_score_list:</span><br><span class="line">    name_list = []</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> subject_score_dict.items():</span><br><span class="line">        <span class="keyword">if</span> value == score:</span><br><span class="line">            name_list.append(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name_list) &gt; <span class="number">1</span>:</span><br><span class="line">        name_list.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> name_list:</span><br><span class="line">            print(a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(name_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>중복된 점수의 이름을 불러올 때, 내림차순으로 정렬 후 출력해주고, 중복된 점수가 아닐 때는 해당하는 이름만 불러오면 끝이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">subject_score_dict = &#123;&#125;</span><br><span class="line">subject_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    name, korean_score, english_score, math_score = <span class="built_in">input</span>().split()</span><br><span class="line">    korean_score, english_score, math_score = <span class="built_in">int</span>(korean_score), <span class="built_in">int</span>(english_score), <span class="built_in">int</span>(math_score)</span><br><span class="line">    subject_score_dict[name] = [korean_score, english_score, math_score]</span><br><span class="line">    current_score = [korean_score, english_score, math_score]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(subject_score_list) == <span class="number">0</span>:</span><br><span class="line">        subject_score_list.append(current_score)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> score_index, score <span class="keyword">in</span> <span class="built_in">enumerate</span>(subject_score_list):</span><br><span class="line">            <span class="keyword">if</span> current_score[<span class="number">0</span>] &gt; score[<span class="number">0</span>]:</span><br><span class="line">                subject_score_list.insert(score_index, current_score)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] &lt; score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> current_score[<span class="number">0</span>] == score[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> current_score[<span class="number">1</span>] &lt; score[<span class="number">1</span>]:</span><br><span class="line">                    subject_score_list.insert(score_index, current_score)</span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] &gt; score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                        subject_score_list.append(current_score)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">elif</span> current_score[<span class="number">1</span>] == score[<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> current_score[<span class="number">2</span>] &gt; score[<span class="number">2</span>]:</span><br><span class="line">                        subject_score_list.insert(score_index, current_score)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] &lt; score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">if</span> score_index == <span class="built_in">len</span>(subject_score_list) - <span class="number">1</span>:</span><br><span class="line">                            subject_score_list.append(current_score)</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> current_score[<span class="number">2</span>] == score[<span class="number">2</span>]:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">for</span> score <span class="keyword">in</span> subject_score_list:</span><br><span class="line">    name_list = []</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> subject_score_dict.items():</span><br><span class="line">        <span class="keyword">if</span> value == score:</span><br><span class="line">            name_list.append(name)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(name_list) &gt; <span class="number">1</span>:</span><br><span class="line">        name_list.sort()</span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> name_list:</span><br><span class="line">            print(a)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(name_list[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>입력예제 통과 후 제출했는데 python3로는 시간초과, PyPy3는 메모리 초과로 나왔다.</p><p>결국 다른 방식을 찾아봤다.</p><h3 id="sort-와-sorted-차이점"><a href="#sort-와-sorted-차이점" class="headerlink" title="sort()와 sorted() 차이점"></a>sort()와 sorted() 차이점</h3><ul><li><code>&lt;list&gt;.sort()</code>는 <code>list</code>의 내장 메소드이고, 원본 리스트의 순서를 정렬하는 함수다. 새로운 리스트를 만드는게 아니라서 이러한 혼동을 방지하기 위해서 <code>return none</code>을 반환한다.</li><li>‘sorted()’는 ‘sort()’와 달리 정렬 후 새로운 리스트로 반환한다. 리스트만 정렬가능한 <code>sort()</code>와 달리 <code>sorted()</code>는 <code>iterable</code>한 객체면 모두 사용 가능하다.<br><code>sort()</code>는 <code>sorted()</code>처럼 복사본을 만들지 않아서 좀 더 효율이 좋다.</li></ul><p><code>sort()</code>와 <code>sorted()</code>는 둘 다 파라미터로 <code>reverse</code>, <code>key</code>값을 받는데, <code>reverse</code>의 default값은 <code>reverse=False</code>로 오름차순 정렬, <code>reverse=True</code>는 내림차순 정렬이다.<br><code>key</code>는 각 리스트의 요소들을 정렬하기 전에, 정렬의 기준이 될 함수를 지정하는 파라미터다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><blockquote><p>내가 생각했을 때 소문자가 먼저 정렬된 뒤에 대문자가 나올 줄 알았는데, 둘이 섞여있다. 왜그럴까?</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split()</span><br><span class="line">[<span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;This&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.upper</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(<span class="string">&quot;This is a test string from Andrew&quot;</span>.split(), key=<span class="built_in">str</span>.lower</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;Andrew&#x27;</span>, <span class="string">&#x27;from&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;This&#x27;</span>]</span><br></pre></td></tr></table></figure><hr><p>일반적으로 많이 사용하는 패턴은 객체의 인덱스 중 일부를 <code>key</code>로 사용해서 정렬한다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>student_tuples = [</span><br><span class="line">    (<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>),</span><br><span class="line">    (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>),</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(student_tuples, key=<span class="keyword">lambda</span> student: student[<span class="number">2</span>])   <span class="comment"># sort by age</span></span><br><span class="line">[(<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>)]</span><br></pre></td></tr></table></figure><p><code>operator</code>모듈에 있는 <code>itemgetter()</code>, <code>attrgetter()</code>, <code>methodcaller()</code>를 이용한다면 더 빠르고 편리하게 만들 수 있다.</p><p>그 중에서 <code>itemgetter()</code>를 활용해보면</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="string">&#x27;name&#x27;</span>)(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tu&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="string">&#x27;tu&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="number">1</span>)(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>itemgetter(<span class="built_in">slice</span>(<span class="number">2</span>,<span class="literal">None</span>))(<span class="string">&#x27;ABCDEFG&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;CDEFG&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 활용</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>inventory = [(<span class="string">&#x27;apple&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;pear&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;orange&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getcount = itemgetter(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(getcount, inventory))</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(inventory, key=getcount)</span><br><span class="line">[(<span class="string">&#x27;orange&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;banana&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;apple&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;pear&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><p><code>sort()</code>와 <code>sorted()</code> 모두 <code>key</code>값으로 중복된 값이 있다면, <strong>입력받은 순서대로 정렬된다.</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = [(<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(data, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">&#x27;blue&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;red&#x27;</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><hr><p><code>sort()</code>를 이용해서 문제를 다시 풀어보면</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">student_score_list = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())):</span><br><span class="line">    student_score_list.append(<span class="built_in">input</span>().split())</span><br><span class="line">student_score_list.sort(key=<span class="keyword">lambda</span> x: (-<span class="built_in">int</span>(x[<span class="number">1</span>]), <span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="built_in">int</span>(x[<span class="number">3</span>]), x[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> student_score_list:</span><br><span class="line">    print(student[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://docs.python.org/3/howto/sorting.html?highlight=sort">https://docs.python.org/3/howto/sorting.html?highlight=sort</a><br><a href="https://docs.python.org/3/library/operator.html#module-operator">https://docs.python.org/3/library/operator.html#module-operator</a><br><a href="https://stackoverflow.com/questions/22442378/what-is-the-difference-between-sortedlist-vs-list-sort">https://stackoverflow.com/questions/22442378/what-is-the-difference-between-sortedlist-vs-list-sort</a></p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/BAEKJOON/">BAEKJOON</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/BAEKJOON/">BAEKJOON</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/05/BAEKJOON-%EA%B5%AD%EC%98%81%EC%88%98-10825%EB%B2%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210304 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/</guid>
      <pubDate>Thu, 04 Mar 2021 11:43:04 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTML-CSS-강의-내용-정리&quot;&gt;&lt;a href=&quot;#HTML-CSS-강의-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;HTML, CSS 강의 내용 정리&quot;&gt;&lt;/a&gt;HTML, CSS 강의 내용 정리&lt;/h1&gt;&lt;h2 id=&quot;적응형</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML-CSS-강의-내용-정리"><a href="#HTML-CSS-강의-내용-정리" class="headerlink" title="HTML, CSS 강의 내용 정리"></a>HTML, CSS 강의 내용 정리</h1><h2 id="적응형-웹-V-S-반응형-웹"><a href="#적응형-웹-V-S-반응형-웹" class="headerlink" title="적응형 웹 V.S 반응형 웹"></a>적응형 웹 V.S 반응형 웹</h2><ul><li><p>적응형(AWD)<br>적응형 웹은 각 기기에 적합한 UI 템플릿을 각각 제공<br>각 기기에 필요한 리소스만 다운로드 받아서 사용하기 때문에 로드 속도가 빠른 편</p></li><li><p>반응형(RWD)<br>미디어쿼리를 사용해서 하나의 UI 템플릿을 기기의 화면 크기에 맞게 변형<br>기기에 상관없이 모든 리소스를 다운로드 받아서 사용하기 때문에 로드 속도가 느린 편</p></li></ul><p>웹 제작 시 <code>mobile first</code> 방식으로 하는걸 추천</p><p><code>desktop first</code>로 설계된 페이지의 콘텐츠를 모바일에 넣으려고 하면 어떤걸 비워야 할 지 결정하기 힘들다.<br><code>mobile first</code>로 설계를 하게 되면 데스크탑에 어떤 컨텐츠를 채울지만 생각하면 된다.</p><blockquote><p><code>desktop first</code>는 코끼리를 냉장고에 넣어야 하는 것과 같다.</p></blockquote><p>모바일에서 구조 설계할 때 <code>off canvas</code>방식을 많이 사용한다.<br><code>off canvas</code> - 화면에서 안보이는 상태였다가 메뉴가 열릴 때 화면 밖에서 안으로 들어오는 방식</p><hr><p>반응형 이미지를 만들 때 CSS 속성으로</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br></pre></td></tr></table></figure><h2 id="max-width-100-를-주면-이미지-크기를-부모의-크기로-제한해주고-height-auto-는-이미지-크기가-attribute로-설정되어-있다면-높이는-줄어들지-않아서-원본-비율에-맞게-높이를-자동으로-조절해준다"><a href="#max-width-100-를-주면-이미지-크기를-부모의-크기로-제한해주고-height-auto-는-이미지-크기가-attribute로-설정되어-있다면-높이는-줄어들지-않아서-원본-비율에-맞게-높이를-자동으로-조절해준다" class="headerlink" title="max-width: 100%;를 주면 이미지 크기를 부모의 크기로 제한해주고, height: auto;는 이미지 크기가 attribute로 설정되어 있다면 높이는 줄어들지 않아서 원본 비율에 맞게 높이를 자동으로 조절해준다."></a><code>max-width: 100%;</code>를 주면 이미지 크기를 부모의 크기로 제한해주고, <code>height: auto;</code>는 이미지 크기가 <code>attribute</code>로 설정되어 있다면 높이는 줄어들지 않아서 원본 비율에 맞게 높이를 자동으로 조절해준다.</h2><p>다른 브라우저에서 지원하지 않는 속성이 있을 때,<br><code>polyfill + 속성</code>을 구글링 하면 대응할 수 있는 방법이 나올 수도 있다.</p><hr><h2 id="lt-picture-gt-태그는-하나의-이미지를-확대-축소하는-방법이-아닌-여러-이미지를-사이즈에-맞게-받아서-뷰포트에-맞게-대응할-수-있게-해주는-태그다-fallback으로-lt-img-gt-를-줘야-하고-반응형-웹에서-자주-사용된다"><a href="#lt-picture-gt-태그는-하나의-이미지를-확대-축소하는-방법이-아닌-여러-이미지를-사이즈에-맞게-받아서-뷰포트에-맞게-대응할-수-있게-해주는-태그다-fallback으로-lt-img-gt-를-줘야-하고-반응형-웹에서-자주-사용된다" class="headerlink" title="&lt;picture&gt;태그는 하나의 이미지를 확대 축소하는 방법이 아닌, 여러 이미지를 사이즈에 맞게 받아서  뷰포트에 맞게 대응할 수 있게 해주는 태그다. fallback으로 &lt;img&gt;를 줘야 하고 반응형 웹에서 자주 사용된다."></a><code>&lt;picture&gt;</code>태그는 하나의 이미지를 확대 축소하는 방법이 아닌, 여러 이미지를 사이즈에 맞게 받아서  뷰포트에 맞게 대응할 수 있게 해주는 태그다. fallback으로 <code>&lt;img&gt;</code>를 줘야 하고 반응형 웹에서 자주 사용된다.</h2><p><code>&lt;body&gt;</code>안에 <code>&lt;div class=&quot;containor&quot;&gt;</code> 같이 묶어주면 컴포넌트 나누기 편하다.</p><blockquote><p><code>&lt;body&gt;</code>에 배경을 줬을 때 <code>margin</code>을 준 부분까지 적용이 되는데 이유가 뭘까?</p></blockquote><p>시멘틱 태그를 주지 않아도 비슷한 역할을 <code>WAI-ARIA roles</code>를 이용하면 만들어 줄 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span> / <span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><p><code>position: fixed</code>는 뷰포트 기준으로 위치를 조절할 수 있다.<br><code>position: sticky</code> = relative + fixed</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 0;</span><br><span class="line"><span class="selector-tag">right</span>: 0;</span><br><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">wh</span>;</span><br></pre></td></tr></table></figure><p><code>fixed</code>된 상태에서 왼쪽과 오른쪽으로 맞추려고 하다보니 양쪽 끝으로 늘어나는 것 처럼 보인다.</p><h2 id="position-absolute상태에서-top-bottom-left-right에-0값을-주고-margin을-주면-가운데-정렬-느낌-낼-수-있다"><a href="#position-absolute상태에서-top-bottom-left-right에-0값을-주고-margin을-주면-가운데-정렬-느낌-낼-수-있다" class="headerlink" title="position: absolute상태에서 top,bottom,left,right에 0값을 주고 margin을 주면 가운데 정렬 느낌 낼 수 있다"></a><code>position: absolute</code>상태에서 top,bottom,left,right에 0값을 주고 margin을 주면 가운데 정렬 느낌 낼 수 있다</h2><p>flex-item들은 형제 레벨에 맞춰서 높이가 자동으로 조절된다.<br>flex-item들 끼리 마진 병합이 일어나지 않는다.</p><p>CSS에서 <code>display: none</code>값을 HTML5에서 태그 안에 <code>hidden</code>을 주면 비슷한 역할을 할 수 있다.</p><h2 id="cal"><a href="#cal" class="headerlink" title="cal()"></a>cal()</h2><p>CSS에서 calc() CSS함수를 사용하면 계산식을 지정할 수 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.h1</span>&#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="built_in">cal</span>(<span class="number">50%</span> - <span class="number">10px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/04/20210304-TIL/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>20210303 TIL</title>
      <link>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/</link>
      <guid>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/</guid>
      <pubDate>Wed, 03 Mar 2021 11:47:24 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;HTML-CSS-강의-내용-정리&quot;&gt;&lt;a href=&quot;#HTML-CSS-강의-내용-정리&quot; class=&quot;headerlink&quot; title=&quot;HTML, CSS 강의 내용 정리&quot;&gt;&lt;/a&gt;HTML, CSS 강의 내용 정리&lt;/h1&gt;&lt;h2 id=&quot;tra</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="HTML-CSS-강의-내용-정리"><a href="#HTML-CSS-강의-내용-정리" class="headerlink" title="HTML, CSS 강의 내용 정리"></a>HTML, CSS 강의 내용 정리</h1><h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><p><code>transition</code>은 어떤 속성이 어떤 상황(ex.<code>:hover</code>)으로 인해 <code>A-&gt;B</code>로 변경될 때 그 과정을 일정 기간에 걸쳐서 자연스럽게 변화하는 과정을 보여준다. 이와 비슷한 기능을 하는 <code>@keyframes</code>가 있는데, <code>transition</code>보다 더 디테일하고 다양하게 변화를 줄 수 있다.<br>‘transition-delay’속성을 줄 때, <code>s</code>, <code>ms</code>단위를 사용할 수 있는데, 0초를 주더라고 꼭 <code>0s</code>로 s를 붙여야 한다. 다른 속성들과 다르게 0초의 단위를 생략할 수 없다.</p><h2 id="대화형-콘텐츠"><a href="#대화형-콘텐츠" class="headerlink" title="대화형 콘텐츠"></a>대화형 콘텐츠</h2><p><code>:hover</code>는 모든 태그에 대해서 사용이 가능하지만, <code>:focus</code>는 <code>a</code>, <code>input</code>, <code>button</code> 태그와 같이 <a href="https://developer.mozilla.org/ko/docs/Web/Guide/HTML/Content_categories#%EB%8C%80%ED%99%94%ED%98%95_%EC%BD%98%ED%85%90%EC%B8%A0">대화형 콘텐츠</a>의 요소만 사용이 가능하다.</p><blockquote><p>태그에 <code>tabindex=&quot;0&quot;</code>을 준다면 <code>tab</code>키를 받을 수 있어서 <code>:focus</code>를 사용가능하게 만들 수는 있다.</p></blockquote><h2 id="순서-입력"><a href="#순서-입력" class="headerlink" title="순서 입력"></a>순서 입력</h2><p>CSS로 <code>&lt;li&gt;</code>안에 순서대로 숫자를 입력할 때 <code>li::before&#123;content: &quot;1&quot;&#125;</code>하나씩 입력해도 되지만 100개가 넘는다면? 너무 노가다.. 해결 방법이 있다.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">::befor</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">counter</span>(number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;li&gt;</code>에 순서대로 숫자가 입력된다.</p><h2 id="문자-숨기는-방법"><a href="#문자-숨기는-방법" class="headerlink" title="문자 숨기는 방법"></a>문자 숨기는 방법</h2><p><code>padding</code> <code>overflow: hidden</code><br><code>text-indent</code> <code>overflow: hidden</code><br><code>::after&#123;background: url()&#125;</code></p><h2 id="인용구"><a href="#인용구" class="headerlink" title="인용구"></a>인용구</h2><p><code>&lt;blockquote&gt;</code><br><code>&lt;q cite=&quot; &quot;&gt;</code> <code>cite</code>는 인용한 정보의 저작권 표시를 위한 속성. 값으로 <code>isbn: ~</code>책에 대한 내용 <code>http:// ~</code> 웹에 대한 내용</p><p><code>&lt;footer&gt;</code>는 제목을 가지지 않는게 좋다.</p><p><code>&lt;a href=&quot;tel: 01012341234&quot;&gt;</code> 링크를 누르면 자동으로 전화로 연결해줄 수 있다.</p><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p>Grid를 사용하면 배치에 대한 큰 걱정없이 논리성을 줌심으로 마크업할 수 있다.<br>단, <code>Internet Explorer</code>를 지원하지 않는 단점이 있는데,<br>전세계에서 <code>Internet Explorer</code>의 점유율은 2%미만을 차지하는데 우리나라는 높은 비중을 차지하고 있어서 현업에서 <code>Grid</code>를 사용하기는 힘들다고 한다.<br><a href="https://presscat.co.kr/blog/browser-market-share-mar2020/">웹 브라우저 시장 점유율(2020)</a></p><hr><p>클론 코딩은 완전히 똑같이 만드는게 아니라 그 페이지를 분석해보고, 장점은 가져오고 보완했으면 좋은 것들을 정리해서 만들어야 한다.</p>]]></content:encoded>
      
      
      <category domain="https://juhyeong-k.github.io/categories/TIL/">TIL</category>
      
      
      <category domain="https://juhyeong-k.github.io/tags/TIL/">TIL</category>
      
      <category domain="https://juhyeong-k.github.io/tags/HTML/">HTML</category>
      
      <category domain="https://juhyeong-k.github.io/tags/CSS/">CSS</category>
      
      
      <comments>https://juhyeong-k.github.io/2021/03/03/20210303-TIL/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
